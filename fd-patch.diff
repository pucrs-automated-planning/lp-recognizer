diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/CHANGES.md fast-downward/CHANGES.md
--- fast-downward-original/CHANGES.md	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/CHANGES.md	2020-06-17 03:29:39.510765700 -0300
@@ -0,0 +1,40 @@
+# Release notes
+
+Fast Downward has been in development since 2003, but the current
+timed release model was not adopted until 2019. This file documents
+the changes since the first timed release, Fast Downward 19.06.
+
+For more details, check the repository history
+(<http://hg.fast-downward.org>) and the issue tracker
+(<http://issues.fast-downward.org>). Repository branches are named
+after the corresponding tracker issues.
+
+## Changes since the last release
+
+- LP solver: updated build instructions of the open solver interface.
+  <http://issues.fast-downward.org/issue752>
+  <http://issues.fast-downward.org/issue925>
+  The way we recommend building OSI now links dynamically against the
+  solvers and uses zlib. If your existing OSI installation stops
+  working, try installing zlib (sudo apt install zlib1g-dev) or
+  re-install OSI (http://www.fast-downward.org/LPBuildInstructions).
+
+- LP solver: added support for version 12.9 of CPLEX.
+  <http://issues.fast-downward.org/issue925>
+  Older versions are still supported but we recommend using 12.9.
+  In our experiments, we saw performance differences between version
+  12.8 and 12.9, as well as between using static and dynamic linking.
+  However, on average there was no significant advantage for any
+  configuration. See the issue for details.
+
+- LP solver: added support for the solver [SoPlex](https://soplex.zib.de/)
+  <http://issues.fast-downward.org/issue752>
+  The relative performance of CPLEX and SoPlex depends on the domain and
+  configuration with each solver outperforming the other in some cases.
+  See the issue for a more detailed discussion of performance.
+
+
+## Fast Downward 19.06
+
+Released on June 11, 2019.
+First time-based release.
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/domain.pddl fast-downward/domain.pddl
--- fast-downward-original/domain.pddl	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/domain.pddl	2020-07-09 16:16:12.585929600 -0300
@@ -0,0 +1,49 @@
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;;; 4 Op-blocks world
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(define (domain BLOCKS)
+  (:requirements :strips :typing :equality)
+  (:types block)
+  (:predicates (on ?x ?y - block)
+	       (ontable ?x - block)
+	       (clear ?x - block)
+	       (handempty)
+	       (holding ?x - block)
+	       )
+
+  (:action pick-up
+	     :parameters (?x - block)
+	     :precondition (and (clear ?x) (ontable ?x) (handempty))
+	     :effect
+	     (and (not (ontable ?x))
+		   (not (clear ?x))
+		   (not (handempty))
+		   (holding ?x)))
+
+  (:action put-down
+	     :parameters (?x - block)
+	     :precondition (holding ?x)
+	     :effect
+	     (and (not (holding ?x))
+		   (clear ?x)
+		   (handempty)
+		   (ontable ?x)))
+  (:action stack
+	     :parameters (?x ?y - block)
+	     :precondition (and (holding ?x) (clear ?y) (not (= ?x ?y)))
+	     :effect
+	     (and (not (holding ?x))
+		   (not (clear ?y))
+		   (clear ?x)
+		   (handempty)
+		   (on ?x ?y)))
+  (:action unstack
+	     :parameters (?x ?y - block)
+	     :precondition (and (on ?x ?y) (clear ?x) (handempty) (not (= ?x ?y)))
+	     :effect
+	     (and (holding ?x)
+		   (clear ?y)
+		   (not (clear ?x))
+		   (not (handempty))
+		   (not (on ?x ?y)))))
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/driver/portfolios/seq_opt_fdss_1.py fast-downward/driver/portfolios/seq_opt_fdss_1.py
--- fast-downward-original/driver/portfolios/seq_opt_fdss_1.py	2020-07-09 18:54:18.596504300 -0300
+++ fast-downward/driver/portfolios/seq_opt_fdss_1.py	2020-06-17 03:29:39.510765700 -0300
@@ -13,8 +13,10 @@
            "shrink_strategy=shrink_bisimulation(greedy=false),"
            "label_reduction=exact(before_shrinking=true,before_merging=false),"
            "max_states=200000))"]),
-    (455, ["--search",
-           "astar(lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]),admissible=true),mpd=true)"]),
+    (455, ["--evaluator",
+           "lmc=lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]),admissible=true)",
+           "--search",
+           "astar(lmc,lazy_evaluator=lmc)"]),
     (569, ["--search",
            "astar(lmcut())"]),
      ]
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/driver/portfolios/seq_opt_fdss_2.py fast-downward/driver/portfolios/seq_opt_fdss_2.py
--- fast-downward-original/driver/portfolios/seq_opt_fdss_2.py	2020-07-09 18:54:18.598498200 -0300
+++ fast-downward/driver/portfolios/seq_opt_fdss_2.py	2020-06-17 03:29:39.510765700 -0300
@@ -13,8 +13,10 @@
            "shrink_strategy=shrink_bisimulation(greedy=false),"
            "label_reduction=exact(before_shrinking=true,before_merging=false),"
            "max_states=200000))"]),
-    (1, ["--search",
-           "astar(lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]),admissible=true),mpd=true)"]),
+    (1, ["--evaluator",
+           "lmc=lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]),admissible=true)",
+           "--search",
+           "astar(lmc,lazy_evaluator=lmc)"]),
     (1, ["--search",
            "astar(lmcut())"]),
     (1, ["--search",
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/driver/portfolios/seq_sat_fdss_2018.py fast-downward/driver/portfolios/seq_sat_fdss_2018.py
--- fast-downward-original/driver/portfolios/seq_sat_fdss_2018.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/driver/portfolios/seq_sat_fdss_2018.py	2020-06-17 03:29:38.811362900 -0300
@@ -0,0 +1,340 @@
+# -*- coding: utf-8 -*-
+"""
+This is the "Fast Downward Stone Soup 2018" sequential portfolio that participated in the IPC 2018
+satisficing and bounded-cost tracks. For more information, see the planner abstract:
+
+Jendrik Seipp and Gabriele RÃ¶ger.
+Fast Downward Stone Soup 2018.
+In Ninth International Planning Competition (IPC 2018), Deterministic Part, pp. 80-82. 2018.
+https://ai.dmi.unibas.ch/papers/seipp-roeger-ipc2018.pdf
+"""
+
+OPTIMAL = False
+CONFIGS = [
+    (26, [
+        "--evaluator",
+        "hlm=lmcount(lm_rhw(reasonable_orders=true),transform=adapt_costs(one))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--search",
+        "lazy(alt([single(hff),single(hff,pref_only=true),single(hlm),single(hlm,pref_only=true),type_based([hff,g()])],boost=1000),preferred=[hff,hlm],cost_type=one,reopen_closed=false,randomize_successors=true,preferred_successors_first=false,bound=BOUND)"]),
+    (25, [
+        "--landmarks",
+        "lmg=lm_rhw(only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=true,no_orders=true)",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true,transform=adapt_costs(one))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--search",
+        "lazy(alt([type_based([g()]),single(hlm),single(hlm,pref_only=true),single(hff),single(hff,pref_only=true)],boost=0),preferred=[hlm],reopen_closed=false,cost_type=plusone,bound=BOUND)"]),
+    (135, [
+        "--evaluator",
+        "hlm=lmcount(lm_rhw(reasonable_orders=true),transform=adapt_costs(one))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--search",
+        "lazy(alt([single(hff),single(hff,pref_only=true),single(hlm),single(hlm,pref_only=true)],boost=1000),preferred=[hff,hlm],cost_type=one,reopen_closed=false,randomize_successors=false,preferred_successors_first=true,bound=BOUND)"]),
+    (59, [
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--evaluator",
+        "hlm=lmcount(lm_rhw(reasonable_orders=true),transform=adapt_costs(one))",
+        "--search",
+        "eager_greedy([hff,hlm],preferred=[hff,hlm],cost_type=one,bound=BOUND)"]),
+    (23, [
+        "--evaluator",
+        "hlm=lmcount(lm_rhw(reasonable_orders=true),transform=adapt_costs(one))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--search",
+        "lazy(alt([single(hff),single(hff,pref_only=true),single(hlm),single(hlm,pref_only=true)],boost=1000),preferred=[hff,hlm],cost_type=one,reopen_closed=false,randomize_successors=true,preferred_successors_first=true,bound=BOUND)"]),
+    (57, [
+        "--landmarks",
+        "lmg=lm_rhw(only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=true,no_orders=true)",
+        "--evaluator",
+        "hcg=cg(transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true,transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(plusone))",
+        "--search",
+        "lazy(alt([single(sum([g(),weight(hlm,10)])),single(sum([g(),weight(hlm,10)]),pref_only=true),single(sum([g(),weight(hff,10)])),single(sum([g(),weight(hff,10)]),pref_only=true),single(sum([g(),weight(hcg,10)])),single(sum([g(),weight(hcg,10)]),pref_only=true)],boost=1000),preferred=[hlm,hcg],reopen_closed=false,cost_type=plusone,bound=BOUND)"]),
+    (17, [
+        "--evaluator",
+        "hcea=cea(transform=adapt_costs(one))",
+        "--evaluator",
+        "hlm=lmcount(lm_rhw(reasonable_orders=true),transform=adapt_costs(one))",
+        "--search",
+        "lazy_greedy([hcea,hlm],preferred=[hcea,hlm],cost_type=one,bound=BOUND)"]),
+    (12, [
+        "--evaluator",
+        "hadd=add(transform=adapt_costs(one))",
+        "--evaluator",
+        "hlm=lmcount(lm_rhw(reasonable_orders=true),transform=adapt_costs(one))",
+        "--search",
+        "lazy(alt([type_based([g()]),single(hadd),single(hadd,pref_only=true),single(hlm),single(hlm,pref_only=true)]),preferred=[hadd,hlm],cost_type=one,bound=BOUND)"]),
+    (26, [
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--search",
+        "lazy(alt([single(sum([g(),weight(hff,10)])),single(sum([g(),weight(hff,10)]),pref_only=true)],boost=2000),preferred=[hff],reopen_closed=false,cost_type=one,bound=BOUND)"]),
+    (28, [
+        "--evaluator",
+        "hcg=cg(transform=adapt_costs(one))",
+        "--evaluator",
+        "hlm=lmcount(lm_rhw(reasonable_orders=true),transform=adapt_costs(one))",
+        "--search",
+        "eager(alt([type_based([g()]),single(hcg),single(hcg,pref_only=true),single(hlm),single(hlm,pref_only=true)]),preferred=[hcg,hlm],cost_type=one,bound=BOUND)"]),
+    (29, [
+        "--landmarks",
+        "lmg=lm_rhw(only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=true,no_orders=false)",
+        "--evaluator",
+        "hcea=cea(transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true,transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(plusone))",
+        "--search",
+        "lazy(alt([single(hlm),single(hlm,pref_only=true),single(hff),single(hff,pref_only=true),single(hcea),single(hcea,pref_only=true)],boost=0),preferred=[hlm,hcea],reopen_closed=false,cost_type=plusone,bound=BOUND)"]),
+    (88, [
+        "--evaluator",
+        "hcea=cea(transform=adapt_costs(one))",
+        "--evaluator",
+        "hlm=lmcount(lm_rhw(reasonable_orders=true),transform=adapt_costs(one))",
+        "--search",
+        "lazy_wastar([hcea,hlm],w=3,preferred=[hcea,hlm],cost_type=one,bound=BOUND)"]),
+    (8, [
+        "--evaluator",
+        "hcg=cg(transform=adapt_costs(one))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--search",
+        "lazy(alt([single(sum([g(),weight(hff,10)])),single(sum([g(),weight(hff,10)]),pref_only=true),single(sum([g(),weight(hcg,10)])),single(sum([g(),weight(hcg,10)]),pref_only=true)],boost=100),preferred=[hcg],reopen_closed=false,cost_type=one,bound=BOUND)"]),
+    (54, [
+        "--evaluator",
+        "hgoalcount=goalcount(transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hff=ff()",
+        "--search",
+        "lazy(alt([single(sum([g(),weight(hff,10)])),single(sum([g(),weight(hff,10)]),pref_only=true),single(sum([g(),weight(hgoalcount,10)])),single(sum([g(),weight(hgoalcount,10)]),pref_only=true)],boost=2000),preferred=[hff,hgoalcount],reopen_closed=false,cost_type=one,bound=BOUND)"]),
+    (24, [
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--evaluator",
+        "hlm=lmcount(lm_rhw(reasonable_orders=true),transform=adapt_costs(one))",
+        "--search",
+        "eager(alt([type_based([g()]),single(sum([g(),weight(hff,3)])),single(sum([g(),weight(hff,3)]),pref_only=true),single(sum([g(),weight(hlm,3)])),single(sum([g(),weight(hlm,3)]),pref_only=true)]),preferred=[hff,hlm],cost_type=one,bound=BOUND)"]),
+    (29, [
+        "--landmarks",
+        "lmg=lm_rhw(reasonable_orders=false,only_causal_landmarks=false,disjunctive_landmarks=false,conjunctive_landmarks=true,no_orders=false)",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=false,transform=adapt_costs(one))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--evaluator",
+        "hblind=blind()",
+        "--search",
+        "lazy(alt([type_based([g()]),single(sum([g(),weight(hblind,2)])),single(sum([g(),weight(hblind,2)]),pref_only=true),single(sum([g(),weight(hlm,2)])),single(sum([g(),weight(hlm,2)]),pref_only=true),single(sum([g(),weight(hff,2)])),single(sum([g(),weight(hff,2)]),pref_only=true)],boost=4419),preferred=[hlm],reopen_closed=true,cost_type=one,bound=BOUND)"]),
+    (30, [
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--search",
+        "lazy_wastar([hff],w=3,preferred=[hff],cost_type=one,bound=BOUND)"]),
+    (28, [
+        "--evaluator",
+        "hcg=cg(transform=adapt_costs(plusone))",
+        "--search",
+        "lazy(alt([type_based([g()]),single(hcg),single(hcg,pref_only=true)],boost=0),preferred=[hcg],reopen_closed=true,cost_type=plusone,bound=BOUND)"]),
+    (58, [
+        "--evaluator",
+        "hcg=cg(transform=adapt_costs(one))",
+        "--evaluator",
+        "hlm=lmcount(lm_rhw(reasonable_orders=true),transform=adapt_costs(one))",
+        "--search",
+        "lazy(alt([type_based([g()]),single(sum([g(),weight(hcg,3)])),single(sum([g(),weight(hcg,3)]),pref_only=true),single(sum([g(),weight(hlm,3)])),single(sum([g(),weight(hlm,3)]),pref_only=true)]),preferred=[hcg,hlm],cost_type=one,bound=BOUND)"]),
+    (26, [
+        "--evaluator",
+        "hcea=cea(transform=adapt_costs(one))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hblind=blind()",
+        "--search",
+        "eager(alt([single(sum([g(),weight(hblind,10)])),single(sum([g(),weight(hblind,10)]),pref_only=true),single(sum([g(),weight(hff,10)])),single(sum([g(),weight(hff,10)]),pref_only=true),single(sum([g(),weight(hcea,10)])),single(sum([g(),weight(hcea,10)]),pref_only=true)],boost=536),preferred=[hff],reopen_closed=false,bound=BOUND)"]),
+    (27, [
+        "--evaluator",
+        "hcea=cea(transform=adapt_costs(one))",
+        "--search",
+        "eager_greedy([hcea],preferred=[hcea],cost_type=one,bound=BOUND)"]),
+    (50, [
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--search",
+        "eager(alt([single(sum([g(),weight(hff,3)])),single(sum([g(),weight(hff,3)]),pref_only=true)]),preferred=[hff],cost_type=one,bound=BOUND)"]),
+    (28, [
+        "--evaluator",
+        "hgoalcount=goalcount(transform=adapt_costs(one))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hblind=blind()",
+        "--evaluator",
+        "hcg=cg()",
+        "--search",
+        "lazy(alt([type_based([g()]),single(sum([weight(g(),2),weight(hblind,3)])),single(sum([weight(g(),2),weight(hblind,3)]),pref_only=true),single(sum([weight(g(),2),weight(hff,3)])),single(sum([weight(g(),2),weight(hff,3)]),pref_only=true),single(sum([weight(g(),2),weight(hcg,3)])),single(sum([weight(g(),2),weight(hcg,3)]),pref_only=true),single(sum([weight(g(),2),weight(hgoalcount,3)])),single(sum([weight(g(),2),weight(hgoalcount,3)]),pref_only=true)],boost=3662),preferred=[hff],reopen_closed=true,bound=BOUND)"]),
+    (29, [
+        "--evaluator",
+        "hgoalcount=goalcount(transform=adapt_costs(one))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hblind=blind()",
+        "--evaluator",
+        "hcg=cg()",
+        "--search",
+        "lazy(alt([single(sum([weight(g(),2),weight(hblind,3)])),single(sum([weight(g(),2),weight(hblind,3)]),pref_only=true),single(sum([weight(g(),2),weight(hff,3)])),single(sum([weight(g(),2),weight(hff,3)]),pref_only=true),single(sum([weight(g(),2),weight(hcg,3)])),single(sum([weight(g(),2),weight(hcg,3)]),pref_only=true),single(sum([weight(g(),2),weight(hgoalcount,3)])),single(sum([weight(g(),2),weight(hgoalcount,3)]),pref_only=true)],boost=3662),preferred=[hff],reopen_closed=true,bound=BOUND)"]),
+    (21, [
+        "--evaluator",
+        "hcg=cg(transform=adapt_costs(plusone))",
+        "--search",
+        "lazy(alt([single(sum([g(),weight(hcg,10)])),single(sum([g(),weight(hcg,10)]),pref_only=true)],boost=0),preferred=[hcg],reopen_closed=false,cost_type=plusone,bound=BOUND)"]),
+    (21, [
+        "--evaluator",
+        "hcg=cg(transform=adapt_costs(one))",
+        "--search",
+        "eager(alt([single(sum([g(),weight(hcg,3)])),single(sum([g(),weight(hcg,3)]),pref_only=true)]),preferred=[hcg],cost_type=one,bound=BOUND)"]),
+    (24, [
+        "--landmarks",
+        "lmg=lm_rhw(reasonable_orders=true,only_causal_landmarks=true,disjunctive_landmarks=true,conjunctive_landmarks=true,no_orders=false)",
+        "--evaluator",
+        "hblind=blind()",
+        "--evaluator",
+        "hadd=add()",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=false,pref=true,transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hff=ff()",
+        "--search",
+        "lazy(alt([single(sum([weight(g(),2),weight(hblind,3)])),single(sum([weight(g(),2),weight(hblind,3)]),pref_only=true),single(sum([weight(g(),2),weight(hff,3)])),single(sum([weight(g(),2),weight(hff,3)]),pref_only=true),single(sum([weight(g(),2),weight(hlm,3)])),single(sum([weight(g(),2),weight(hlm,3)]),pref_only=true),single(sum([weight(g(),2),weight(hadd,3)])),single(sum([weight(g(),2),weight(hadd,3)]),pref_only=true)],boost=2474),preferred=[hadd],reopen_closed=false,cost_type=one,bound=BOUND)"]),
+    (28, [
+        "--evaluator",
+        "hblind=blind()",
+        "--evaluator",
+        "hadd=add()",
+        "--evaluator",
+        "hcg=cg(transform=adapt_costs(one))",
+        "--evaluator",
+        "hhmax=hmax()",
+        "--search",
+        "eager(alt([tiebreaking([sum([g(),weight(hblind,7)]),hblind]),tiebreaking([sum([g(),weight(hhmax,7)]),hhmax]),tiebreaking([sum([g(),weight(hadd,7)]),hadd]),tiebreaking([sum([g(),weight(hcg,7)]),hcg])],boost=2142),preferred=[],reopen_closed=true,bound=BOUND)"]),
+    (28, [
+        "--evaluator",
+        "hadd=add(transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hff=ff()",
+        "--search",
+        "lazy(alt([tiebreaking([sum([weight(g(),4),weight(hff,5)]),hff]),tiebreaking([sum([weight(g(),4),weight(hff,5)]),hff],pref_only=true),tiebreaking([sum([weight(g(),4),weight(hadd,5)]),hadd]),tiebreaking([sum([weight(g(),4),weight(hadd,5)]),hadd],pref_only=true)],boost=2537),preferred=[hff,hadd],reopen_closed=true,bound=BOUND)"]),
+    (53, [
+        "--landmarks",
+        "lmg=lm_hm(only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=false,no_orders=true,m=1)",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true,transform=transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(plusone))",
+        "--search",
+        "lazy(alt([type_based([g()]),single(hlm),single(hlm,pref_only=true),single(hff),single(hff,pref_only=true)],boost=5000),preferred=[hlm],reopen_closed=false,bound=BOUND)"]),
+    (29, [
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--search",
+        "lazy(alt([single(sum([weight(g(),2),weight(hff,3)])),single(sum([weight(g(),2),weight(hff,3)]),pref_only=true)],boost=5000),preferred=[hff],reopen_closed=true,cost_type=one,bound=BOUND)"]),
+    (27, [
+        "--evaluator",
+        "hblind=blind()",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(one))",
+        "--search",
+        "eager(alt([single(sum([g(),weight(hblind,2)])),single(sum([g(),weight(hff,2)]))],boost=4480),preferred=[],reopen_closed=true,bound=BOUND)"]),
+    (29, [
+        "--landmarks",
+        "lmg=lm_hm(only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=false,no_orders=true,m=1)",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true)",
+        "--evaluator",
+        "hff=ff()",
+        "--search",
+        "lazy(alt([type_based([g()]),single(hlm),single(hlm,pref_only=true),single(hff),single(hff,pref_only=true)],boost=1000),preferred=[hlm,hff],reopen_closed=false,cost_type=one,bound=BOUND)"]),
+    (54, [
+        "--landmarks",
+        "lmg=lm_hm(only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=true,no_orders=false,m=1)",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true)",
+        "--evaluator",
+        "hff=ff()",
+        "--search",
+        "lazy(alt([tiebreaking([sum([g(),weight(hlm,10)]),hlm]),tiebreaking([sum([g(),weight(hlm,10)]),hlm],pref_only=true),tiebreaking([sum([g(),weight(hff,10)]),hff]),tiebreaking([sum([g(),weight(hff,10)]),hff],pref_only=true)],boost=200),preferred=[hlm],reopen_closed=true,cost_type=plusone,bound=BOUND)"]),
+    (87, [
+        "--landmarks",
+        "lmg=lm_hm(only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=false,no_orders=true,m=1)",
+        "--evaluator",
+        "hcg=cg(transform=adapt_costs(one))",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true)",
+        "--search",
+        "lazy(alt([single(hlm),single(hlm,pref_only=true),single(hcg),single(hcg,pref_only=true)],boost=0),preferred=[hcg],reopen_closed=false,cost_type=one,bound=BOUND)"]),
+    (30, [
+        "--landmarks",
+        "lmg=lm_exhaust(reasonable_orders=false,only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=true,no_orders=false)",
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hhmax=hmax()",
+        "--evaluator",
+        "hblind=blind()",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true,pref=false,transform=adapt_costs(one))",
+        "--search",
+        "lazy(alt([type_based([g()]),single(sum([g(),weight(hblind,3)])),single(sum([g(),weight(hblind,3)]),pref_only=true),single(sum([g(),weight(hff,3)])),single(sum([g(),weight(hff,3)]),pref_only=true),single(sum([g(),weight(hlm,3)])),single(sum([g(),weight(hlm,3)]),pref_only=true),single(sum([g(),weight(hhmax,3)])),single(sum([g(),weight(hhmax,3)]),pref_only=true)],boost=3052),preferred=[hff],reopen_closed=true,bound=BOUND)"]),
+    (56, [
+        "--evaluator",
+        "hff=ff(transform=adapt_costs(plusone))",
+        "--search",
+        "lazy(alt([tiebreaking([sum([g(),hff]),hff]),tiebreaking([sum([g(),hff]),hff],pref_only=true)],boost=432),preferred=[hff],reopen_closed=true,cost_type=one,bound=BOUND)"]),
+    (19, [
+        "--landmarks",
+        "lmg=lm_merged([lm_rhw(),lm_hm(m=1)],only_causal_landmarks=false,disjunctive_landmarks=false,conjunctive_landmarks=true,no_orders=false)",
+        "--evaluator",
+        "hff=ff()",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true)",
+        "--search",
+        "lazy(alt([single(sum([g(),weight(hff,10)])),single(sum([g(),weight(hff,10)]),pref_only=true),single(sum([g(),weight(hlm,10)])),single(sum([g(),weight(hlm,10)]),pref_only=true)],boost=500),preferred=[hff],reopen_closed=false,cost_type=plusone,bound=BOUND)"]),
+    (56, [
+        "--landmarks",
+        "lmg=lm_exhaust(reasonable_orders=false,only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=true,no_orders=false)",
+        "--evaluator",
+        "hgoalcount=goalcount(transform=adapt_costs(plusone))",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=false)",
+        "--evaluator",
+        "hff=ff()",
+        "--evaluator",
+        "hblind=blind()",
+        "--search",
+        "eager(alt([tiebreaking([sum([weight(g(),8),weight(hblind,9)]),hblind]),tiebreaking([sum([weight(g(),8),weight(hlm,9)]),hlm]),tiebreaking([sum([weight(g(),8),weight(hff,9)]),hff]),tiebreaking([sum([weight(g(),8),weight(hgoalcount,9)]),hgoalcount])],boost=2005),preferred=[],reopen_closed=true,bound=BOUND)"]),
+    (24, [
+        "--landmarks",
+        "lmg=lm_zg(reasonable_orders=false,only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=true,no_orders=true)",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true,pref=false)",
+        "--search",
+        "eager(single(sum([g(),weight(hlm,3)])),preferred=[],reopen_closed=true,cost_type=one,bound=BOUND)"]),
+    (81, [
+        "--landmarks",
+        "lmg=lm_hm(only_causal_landmarks=false,disjunctive_landmarks=true,conjunctive_landmarks=true,no_orders=true,m=1)",
+        "--evaluator",
+        "hlm=lmcount(lmg,admissible=true)",
+        "--search",
+        "eager(single(sum([g(),weight(hlm,5)])),preferred=[],reopen_closed=true,cost_type=one,bound=BOUND)"]),
+]
+
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue744/base-opt-30min.py fast-downward/experiments/issue744/base-opt-30min.py
--- fast-downward-original/experiments/issue744/base-opt-30min.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue744/base-opt-30min.py	2020-06-17 03:29:39.049015500 -0300
@@ -0,0 +1,83 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import itertools
+import os
+import subprocess
+
+from lab.environments import LocalEnvironment, BaselSlurmEnvironment
+from lab.reports import Attribute 
+
+from downward.reports.compare import ComparativeReport
+
+import common_setup
+from common_setup import IssueConfig, IssueExperiment
+from relativescatter import RelativeScatterPlotReport
+
+EXPNAME = common_setup.get_experiment_name()
+DIR = os.path.dirname(os.path.abspath(__file__))
+BENCHMARKS_DIR = os.environ["DOWNWARD_BENCHMARKS"]
+REVISIONS = ["issue744-base"]
+SEARCHES = [
+    ("bjolp", [
+        "--evaluator", "lmc=lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]),admissible=true)",
+        "--search", "astar(lmc,lazy_evaluator=lmc)"]),
+    ("blind", ["--search", "astar(blind())"]),
+    ("cegar", ["--search", "astar(cegar())"]),
+    ("divpot", ["--search", "astar(diverse_potentials())"]),
+    ("ipdb", ["--search", "astar(ipdb())"]),
+    ("lmcut", ["--search", "astar(lmcut())"]),
+    ("mas", [
+        "--search", "astar(merge_and_shrink(shrink_strategy=shrink_bisimulation(greedy=false),"
+        " merge_strategy=merge_sccs(order_of_sccs=topological,"
+        " merge_selector=score_based_filtering(scoring_functions=[goal_relevance, dfp, total_order])),"
+        " label_reduction=exact(before_shrinking=true, before_merging=false),"
+        " max_states=50000, threshold_before_merge=1))"]),
+    ("seq+lmcut", ["--search", "astar(operatorcounting([state_equation_constraints(), lmcut_constraints()]))"]),
+    ("h2", ["--search", "astar(hm(m=2))"]),
+    ("hmax", ["--search", "astar(hmax())"]),
+]
+CONFIGS = [
+    IssueConfig(search_nick, search,
+        driver_options=["--overall-time-limit", "30m"])
+    for rev in REVISIONS
+    for search_nick, search in SEARCHES
+]
+SUITE = common_setup.DEFAULT_OPTIMAL_SUITE
+ENVIRONMENT = BaselSlurmEnvironment(
+    partition="infai_2",
+    email="manuel.heusner@unibas.ch",
+    export=["PATH", "DOWNWARD_BENCHMARKS"])
+
+if common_setup.is_test_run():
+    SUITE = IssueExperiment.DEFAULT_TEST_SUITE
+    ENVIRONMENT = LocalEnvironment(processes=1)
+
+exp = IssueExperiment(
+    revisions=REVISIONS,
+    configs=CONFIGS,
+    environment=ENVIRONMENT,
+)
+exp.add_suite(BENCHMARKS_DIR, SUITE)
+
+exp.add_parser(exp.EXITCODE_PARSER)
+exp.add_parser(exp.TRANSLATOR_PARSER)
+exp.add_parser(exp.SINGLE_SEARCH_PARSER)
+exp.add_parser(exp.PLANNER_PARSER)
+exp.add_parser('custom-parser.py')
+
+exp.add_step("build", exp.build)
+exp.add_step("start", exp.start_runs)
+exp.add_fetcher(name="fetch")
+
+log_size = Attribute('log_size')
+attributes = IssueExperiment.DEFAULT_TABLE_ATTRIBUTES + [log_size]
+
+exp.add_absolute_report_step(attributes=attributes)
+#exp.add_comparison_table_step()
+
+sort_spec = [('log_size', 'desc')]
+attributes = ['run_dir', 'log_size']
+exp.add_sorted_report_step(attributes=attributes, sort_spec=sort_spec)
+
+exp.run_steps()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue744/base-sat-30min.py fast-downward/experiments/issue744/base-sat-30min.py
--- fast-downward-original/experiments/issue744/base-sat-30min.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue744/base-sat-30min.py	2020-06-17 03:29:39.048018100 -0300
@@ -0,0 +1,100 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import itertools
+import os
+import subprocess
+
+from lab.environments import LocalEnvironment, BaselSlurmEnvironment
+from lab.reports import Attribute
+
+
+import common_setup
+from common_setup import IssueConfig, IssueExperiment
+from relativescatter import RelativeScatterPlotReport
+
+EXPNAME = common_setup.get_experiment_name()
+DIR = os.path.dirname(os.path.abspath(__file__))
+BENCHMARKS_DIR = os.environ["DOWNWARD_BENCHMARKS"]
+REVISIONS = ["issue744-base"]
+CONFIG_DICT = {
+    "eager_greedy_ff": [
+        "--evaluator",
+        "h=ff()",
+        "--search",
+        "eager_greedy([h], preferred=[h])"],
+    "eager_greedy_cea": [
+        "--evaluator",
+        "h=cea()",
+        "--search",
+        "eager_greedy([h], preferred=[h])"],
+    "lazy_greedy_add": [
+        "--evaluator",
+        "h=add()",
+        "--search",
+        "lazy_greedy([h], preferred=[h])"],
+    "lazy_greedy_cg": [
+        "--evaluator",
+        "h=cg()",
+        "--search",
+        "lazy_greedy([h], preferred=[h])"],
+    "lama-first": [
+        "--evaluator",
+        "hlm=lmcount(lm_factory=lm_rhw(reasonable_orders=true),transform=adapt_costs(one),pref=false)",
+        "--evaluator", "hff=ff(transform=adapt_costs(one))",
+        "--search", """lazy_greedy([hff,hlm],preferred=[hff,hlm],
+                                   cost_type=one,reopen_closed=false)"""],
+    "lama-first-typed": [
+        "--evaluator",
+        "hlm=lmcount(lm_factory=lm_rhw(reasonable_orders=true),transform=adapt_costs(one),pref=false)",
+        "--evaluator", "hff=ff(transform=adapt_costs(one))",
+        "--search",
+            "lazy(alt([single(hff), single(hff, pref_only=true),"
+            "single(hlm), single(hlm, pref_only=true), type_based([hff, g()])], boost=1000),"
+            "preferred=[hff,hlm], cost_type=one, reopen_closed=false, randomize_successors=true,"
+            "preferred_successors_first=false)"],
+}
+CONFIGS = [
+    IssueConfig(config_nick, config,
+        driver_options=["--overall-time-limit", "30m"])
+    for rev in REVISIONS
+    for config_nick, config in CONFIG_DICT.items()
+]
+SUITE = common_setup.DEFAULT_SATISFICING_SUITE
+ENVIRONMENT = BaselSlurmEnvironment(
+    partition="infai_2",
+    email="manuel.heusner@unibas.ch",
+    export=["PATH", "DOWNWARD_BENCHMARKS"])
+
+if common_setup.is_test_run():
+    SUITE = IssueExperiment.DEFAULT_TEST_SUITE
+    ENVIRONMENT = LocalEnvironment(processes=1)
+
+exp = IssueExperiment(
+    revisions=REVISIONS,
+    configs=CONFIGS,
+    environment=ENVIRONMENT,
+)
+exp.add_suite(BENCHMARKS_DIR, SUITE)
+
+exp.add_parser(exp.EXITCODE_PARSER)
+exp.add_parser(exp.TRANSLATOR_PARSER)
+exp.add_parser(exp.SINGLE_SEARCH_PARSER)
+exp.add_parser(exp.PLANNER_PARSER)
+exp.add_parser('custom-parser.py')
+
+exp.add_step("build", exp.build)
+exp.add_step("start", exp.start_runs)
+exp.add_fetcher(name="fetch")
+
+log_size = Attribute('log_size')
+attributes = IssueExperiment.DEFAULT_TABLE_ATTRIBUTES + [log_size]
+
+exp.add_absolute_report_step(attributes=attributes)
+#exp.add_comparison_table_step()
+
+sort_spec = [('log_size', 'desc')]
+attributes = ['run_dir', 'log_size']
+exp.add_sorted_report_step(attributes=attributes, sort_spec=sort_spec)
+
+exp.run_steps()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue744/common_setup.py fast-downward/experiments/issue744/common_setup.py
--- fast-downward-original/experiments/issue744/common_setup.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue744/common_setup.py	2020-06-17 03:29:39.510765700 -0300
@@ -0,0 +1,410 @@
+# -*- coding: utf-8 -*-
+
+import itertools
+import os
+import platform
+import subprocess
+import sys
+
+from lab.experiment import ARGPARSER
+from lab import tools
+
+from downward.experiment import FastDownwardExperiment
+from downward.reports.absolute import AbsoluteReport
+from downward.reports.compare import ComparativeReport
+from downward.reports.scatter import ScatterPlotReport
+
+from relativescatter import RelativeScatterPlotReport
+from sortedreport import SortedReport
+
+
+def parse_args():
+    ARGPARSER.add_argument(
+        "--test",
+        choices=["yes", "no", "auto"],
+        default="auto",
+        dest="test_run",
+        help="test experiment locally on a small suite if --test=yes or "
+             "--test=auto and we are not on a cluster")
+    return ARGPARSER.parse_args()
+
+ARGS = parse_args()
+
+
+DEFAULT_OPTIMAL_SUITE = [
+    'agricola-opt18-strips', 'airport', 'barman-opt11-strips',
+    'barman-opt14-strips', 'blocks', 'childsnack-opt14-strips',
+    'data-network-opt18-strips', 'depot', 'driverlog',
+    'elevators-opt08-strips', 'elevators-opt11-strips',
+    'floortile-opt11-strips', 'floortile-opt14-strips', 'freecell',
+    'ged-opt14-strips', 'grid', 'gripper', 'hiking-opt14-strips',
+    'logistics00', 'logistics98', 'miconic', 'movie', 'mprime',
+    'mystery', 'nomystery-opt11-strips', 'openstacks-opt08-strips',
+    'openstacks-opt11-strips', 'openstacks-opt14-strips',
+    'openstacks-strips', 'organic-synthesis-opt18-strips',
+    'organic-synthesis-split-opt18-strips', 'parcprinter-08-strips',
+    'parcprinter-opt11-strips', 'parking-opt11-strips',
+    'parking-opt14-strips', 'pathways-noneg', 'pegsol-08-strips',
+    'pegsol-opt11-strips', 'petri-net-alignment-opt18-strips',
+    'pipesworld-notankage', 'pipesworld-tankage', 'psr-small', 'rovers',
+    'satellite', 'scanalyzer-08-strips', 'scanalyzer-opt11-strips',
+    'snake-opt18-strips', 'sokoban-opt08-strips',
+    'sokoban-opt11-strips', 'spider-opt18-strips', 'storage',
+    'termes-opt18-strips', 'tetris-opt14-strips',
+    'tidybot-opt11-strips', 'tidybot-opt14-strips', 'tpp',
+    'transport-opt08-strips', 'transport-opt11-strips',
+    'transport-opt14-strips', 'trucks-strips', 'visitall-opt11-strips',
+    'visitall-opt14-strips', 'woodworking-opt08-strips',
+    'woodworking-opt11-strips', 'zenotravel']
+
+DEFAULT_SATISFICING_SUITE = [
+    'agricola-sat18-strips', 'airport', 'assembly',
+    'barman-sat11-strips', 'barman-sat14-strips', 'blocks',
+    'caldera-sat18-adl', 'caldera-split-sat18-adl', 'cavediving-14-adl',
+    'childsnack-sat14-strips', 'citycar-sat14-adl',
+    'data-network-sat18-strips', 'depot', 'driverlog',
+    'elevators-sat08-strips', 'elevators-sat11-strips',
+    'flashfill-sat18-adl', 'floortile-sat11-strips',
+    'floortile-sat14-strips', 'freecell', 'ged-sat14-strips', 'grid',
+    'gripper', 'hiking-sat14-strips', 'logistics00', 'logistics98',
+    'maintenance-sat14-adl', 'miconic', 'miconic-fulladl',
+    'miconic-simpleadl', 'movie', 'mprime', 'mystery',
+    'nomystery-sat11-strips', 'nurikabe-sat18-adl', 'openstacks',
+    'openstacks-sat08-adl', 'openstacks-sat08-strips',
+    'openstacks-sat11-strips', 'openstacks-sat14-strips',
+    'openstacks-strips', 'optical-telegraphs',
+    'organic-synthesis-sat18-strips',
+    'organic-synthesis-split-sat18-strips', 'parcprinter-08-strips',
+    'parcprinter-sat11-strips', 'parking-sat11-strips',
+    'parking-sat14-strips', 'pathways', 'pathways-noneg',
+    'pegsol-08-strips', 'pegsol-sat11-strips', 'philosophers',
+    'pipesworld-notankage', 'pipesworld-tankage', 'psr-large',
+    'psr-middle', 'psr-small', 'rovers', 'satellite',
+    'scanalyzer-08-strips', 'scanalyzer-sat11-strips', 'schedule',
+    'settlers-sat18-adl', 'snake-sat18-strips', 'sokoban-sat08-strips',
+    'sokoban-sat11-strips', 'spider-sat18-strips', 'storage',
+    'termes-sat18-strips', 'tetris-sat14-strips',
+    'thoughtful-sat14-strips', 'tidybot-sat11-strips', 'tpp',
+    'transport-sat08-strips', 'transport-sat11-strips',
+    'transport-sat14-strips', 'trucks', 'trucks-strips',
+    'visitall-sat11-strips', 'visitall-sat14-strips',
+    'woodworking-sat08-strips', 'woodworking-sat11-strips',
+    'zenotravel']
+
+
+def get_script():
+    """Get file name of main script."""
+    return tools.get_script_path()
+
+
+def get_script_dir():
+    """Get directory of main script.
+
+    Usually a relative directory (depends on how it was called by the user.)"""
+    return os.path.dirname(get_script())
+
+
+def get_experiment_name():
+    """Get name for experiment.
+
+    Derived from the absolute filename of the main script, e.g.
+    "/ham/spam/eggs.py" => "spam-eggs"."""
+    script = os.path.abspath(get_script())
+    script_dir = os.path.basename(os.path.dirname(script))
+    script_base = os.path.splitext(os.path.basename(script))[0]
+    return "%s-%s" % (script_dir, script_base)
+
+
+def get_data_dir():
+    """Get data dir for the experiment.
+
+    This is the subdirectory "data" of the directory containing
+    the main script."""
+    return os.path.join(get_script_dir(), "data", get_experiment_name())
+
+
+def get_repo_base():
+    """Get base directory of the repository, as an absolute path.
+
+    Search upwards in the directory tree from the main script until a
+    directory with a subdirectory named ".hg" is found.
+
+    Abort if the repo base cannot be found."""
+    path = os.path.abspath(get_script_dir())
+    while os.path.dirname(path) != path:
+        if os.path.exists(os.path.join(path, ".hg")):
+            return path
+        path = os.path.dirname(path)
+    sys.exit("repo base could not be found")
+
+
+def is_running_on_cluster():
+    node = platform.node()
+    return node.endswith(".scicore.unibas.ch") or node.endswith(".cluster.bc2.ch")
+
+
+def is_test_run():
+    return ARGS.test_run == "yes" or (
+        ARGS.test_run == "auto" and not is_running_on_cluster())
+
+
+def get_algo_nick(revision, config_nick):
+    return "{revision}-{config_nick}".format(**locals())
+
+
+class IssueConfig(object):
+    """Hold information about a planner configuration.
+
+    See FastDownwardExperiment.add_algorithm() for documentation of the
+    constructor's options.
+
+    """
+    def __init__(self, nick, component_options,
+                 build_options=None, driver_options=None):
+        self.nick = nick
+        self.component_options = component_options
+        self.build_options = build_options
+        self.driver_options = driver_options
+
+
+class IssueExperiment(FastDownwardExperiment):
+    """Subclass of FastDownwardExperiment with some convenience features."""
+
+    DEFAULT_TEST_SUITE = ["depot:p01.pddl", "gripper:prob01.pddl"]
+
+    DEFAULT_TABLE_ATTRIBUTES = [
+        "cost",
+        "coverage",
+        "error",
+        "evaluations",
+        "expansions",
+        "expansions_until_last_jump",
+        "generated",
+        "memory",
+        "planner_memory",
+        "planner_time",
+        "quality",
+        "run_dir",
+        "score_evaluations",
+        "score_expansions",
+        "score_generated",
+        "score_memory",
+        "score_search_time",
+        "score_total_time",
+        "search_time",
+        "total_time",
+        ]
+
+    DEFAULT_SCATTER_PLOT_ATTRIBUTES = [
+        "evaluations",
+        "expansions",
+        "expansions_until_last_jump",
+        "initial_h_value",
+        "memory",
+        "search_time",
+        "total_time",
+        ]
+
+    PORTFOLIO_ATTRIBUTES = [
+        "cost",
+        "coverage",
+        "error",
+        "quality",
+        "run_dir",
+        ]
+
+    def __init__(self, revisions=None, configs=None, path=None, **kwargs):
+        """
+
+        You can either specify both *revisions* and *configs* or none
+        of them. If they are omitted, you will need to call
+        exp.add_algorithm() manually.
+
+        If *revisions* is given, it must be a non-empty list of
+        revision identifiers, which specify which planner versions to
+        use in the experiment. The same versions are used for
+        translator, preprocessor and search. ::
+
+            IssueExperiment(revisions=["issue123", "4b3d581643"], ...)
+
+        If *configs* is given, it must be a non-empty list of
+        IssueConfig objects. ::
+
+            IssueExperiment(..., configs=[
+                IssueConfig("ff", ["--search", "eager_greedy(ff())"]),
+                IssueConfig(
+                    "lama", [],
+                    driver_options=["--alias", "seq-sat-lama-2011"]),
+            ])
+
+        If *path* is specified, it must be the path to where the
+        experiment should be built (e.g.
+        /home/john/experiments/issue123/exp01/). If omitted, the
+        experiment path is derived automatically from the main
+        script's filename. Example::
+
+            script = experiments/issue123/exp01.py -->
+            path = experiments/issue123/data/issue123-exp01/
+
+        """
+
+        path = path or get_data_dir()
+
+        FastDownwardExperiment.__init__(self, path=path, **kwargs)
+
+        if (revisions and not configs) or (not revisions and configs):
+            raise ValueError(
+                "please provide either both or none of revisions and configs")
+
+        for rev in revisions:
+            for config in configs:
+                self.add_algorithm(
+                    get_algo_nick(rev, config.nick),
+                    get_repo_base(),
+                    rev,
+                    config.component_options,
+                    build_options=config.build_options,
+                    driver_options=config.driver_options)
+
+        self._revisions = revisions
+        self._configs = configs
+
+    @classmethod
+    def _is_portfolio(cls, config_nick):
+        return "fdss" in config_nick
+
+    @classmethod
+    def get_supported_attributes(cls, config_nick, attributes):
+        if cls._is_portfolio(config_nick):
+            return [attr for attr in attributes
+                    if attr in cls.PORTFOLIO_ATTRIBUTES]
+        return attributes
+
+    def add_absolute_report_step(self, **kwargs):
+        """Add step that makes an absolute report.
+
+        Absolute reports are useful for experiments that don't compare
+        revisions.
+
+        The report is written to the experiment evaluation directory.
+
+        All *kwargs* will be passed to the AbsoluteReport class. If the
+        keyword argument *attributes* is not specified, a default list
+        of attributes is used. ::
+
+            exp.add_absolute_report_step(attributes=["coverage"])
+
+        """
+        kwargs.setdefault("attributes", self.DEFAULT_TABLE_ATTRIBUTES)
+        report = AbsoluteReport(**kwargs)
+        outfile = os.path.join(
+            self.eval_dir,
+            get_experiment_name() + "." + report.output_format)
+        self.add_report(report, outfile=outfile)
+        self.add_step(
+            'publish-absolute-report', subprocess.call, ['publish', outfile])
+
+    def add_sorted_report_step(self, sort_spec, name=None, **kwargs):
+        """Add step that makes a sorted report.
+
+        """
+        kwargs.setdefault("attributes", self.DEFAULT_TABLE_ATTRIBUTES)
+        report = SortedReport(sort_spec, **kwargs)
+        name = name or "sorted"
+        name = "-" + name
+        outfile = os.path.join(
+            self.eval_dir,
+            get_experiment_name() + name + "." + report.output_format)
+        self.add_report(report, outfile=outfile)
+        self.add_step(
+            'publish{}-report'.format(name), subprocess.call, ['publish', outfile])
+
+    def add_comparison_table_step(self, **kwargs):
+        """Add a step that makes pairwise revision comparisons.
+
+        Create comparative reports for all pairs of Fast Downward
+        revisions. Each report pairs up the runs of the same config and
+        lists the two absolute attribute values and their difference
+        for all attributes in kwargs["attributes"].
+
+        All *kwargs* will be passed to the CompareConfigsReport class.
+        If the keyword argument *attributes* is not specified, a
+        default list of attributes is used. ::
+
+            exp.add_comparison_table_step(attributes=["coverage"])
+
+        """
+        kwargs.setdefault("attributes", self.DEFAULT_TABLE_ATTRIBUTES)
+
+        def make_comparison_tables():
+            for rev1, rev2 in itertools.combinations(self._revisions, 2):
+                compared_configs = []
+                for config in self._configs:
+                    config_nick = config.nick
+                    compared_configs.append(
+                        ("%s-%s" % (rev1, config_nick),
+                         "%s-%s" % (rev2, config_nick),
+                         "Diff (%s)" % config_nick))
+                report = ComparativeReport(compared_configs, **kwargs)
+                outfile = os.path.join(
+                    self.eval_dir,
+                    "%s-%s-%s-compare.%s" % (
+                        self.name, rev1, rev2, report.output_format))
+                report(self.eval_dir, outfile)
+
+        def publish_comparison_tables():
+            for rev1, rev2 in itertools.combinations(self._revisions, 2):
+                outfile = os.path.join(
+                    self.eval_dir,
+                    "%s-%s-%s-compare.html" % (self.name, rev1, rev2))
+                subprocess.call(["publish", outfile])
+
+        self.add_step("make-comparison-tables", make_comparison_tables)
+        self.add_step(
+            "publish-comparison-tables", publish_comparison_tables)
+
+    def add_scatter_plot_step(self, relative=False, attributes=None):
+        """Add step creating (relative) scatter plots for all revision pairs.
+
+        Create a scatter plot for each combination of attribute,
+        configuration and revisions pair. If *attributes* is not
+        specified, a list of common scatter plot attributes is used.
+        For portfolios all attributes except "cost", "coverage" and
+        "plan_length" will be ignored. ::
+
+            exp.add_scatter_plot_step(attributes=["expansions"])
+
+        """
+        if relative:
+            report_class = RelativeScatterPlotReport
+            scatter_dir = os.path.join(self.eval_dir, "scatter-relative")
+            step_name = "make-relative-scatter-plots"
+        else:
+            report_class = ScatterPlotReport
+            scatter_dir = os.path.join(self.eval_dir, "scatter-absolute")
+            step_name = "make-absolute-scatter-plots"
+        if attributes is None:
+            attributes = self.DEFAULT_SCATTER_PLOT_ATTRIBUTES
+
+        def make_scatter_plot(config_nick, rev1, rev2, attribute):
+            name = "-".join([self.name, rev1, rev2, attribute, config_nick])
+            print("Make scatter plot for", name)
+            algo1 = "{}-{}".format(rev1, config_nick)
+            algo2 = "{}-{}".format(rev2, config_nick)
+            report = report_class(
+                filter_config=[algo1, algo2],
+                attributes=[attribute],
+                get_category=lambda run1, run2: run1["domain"],
+                legend_location=(1.3, 0.5))
+            report(
+                self.eval_dir,
+                os.path.join(scatter_dir, rev1 + "-" + rev2, name))
+
+        def make_scatter_plots():
+            for config in self._configs:
+                for rev1, rev2 in itertools.combinations(self._revisions, 2):
+                    for attribute in self.get_supported_attributes(
+                            config.nick, attributes):
+                        make_scatter_plot(config.nick, rev1, rev2, attribute)
+
+        self.add_step(step_name, make_scatter_plots)
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue744/custom-parser.py fast-downward/experiments/issue744/custom-parser.py
--- fast-downward-original/experiments/issue744/custom-parser.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue744/custom-parser.py	2020-06-17 03:29:39.510765700 -0300
@@ -0,0 +1,13 @@
+#! /usr/bin/env python
+
+from lab.parser import Parser
+
+def compute_log_size(content, props):
+    props["log_size"] = len(content)
+
+def main():
+    parser = Parser()
+    parser.add_function(compute_log_size)
+    parser.parse()
+
+main()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue744/relativescatter.py fast-downward/experiments/issue744/relativescatter.py
--- fast-downward-original/experiments/issue744/relativescatter.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue744/relativescatter.py	2020-06-17 03:29:39.073948400 -0300
@@ -0,0 +1,105 @@
+# -*- coding: utf-8 -*-
+
+from collections import defaultdict
+
+from matplotlib import ticker
+
+from downward.reports.scatter import ScatterPlotReport
+from downward.reports.plot import PlotReport, Matplotlib, MatplotlibPlot
+
+
+# TODO: handle outliers
+
+# TODO: this is mostly copied from ScatterMatplotlib (scatter.py)
+class RelativeScatterMatplotlib(Matplotlib):
+    @classmethod
+    def _plot(cls, report, axes, categories, styles):
+        # Display grid
+        axes.grid(b=True, linestyle='-', color='0.75')
+
+        has_points = False
+        # Generate the scatter plots
+        for category, coords in sorted(categories.items()):
+            X, Y = zip(*coords)
+            axes.scatter(X, Y, s=42, label=category, **styles[category])
+            if X and Y:
+                has_points = True
+
+        if report.xscale == 'linear' or report.yscale == 'linear':
+            plot_size = report.missing_val * 1.01
+        else:
+            plot_size = report.missing_val * 1.25
+
+        # make 5 ticks above and below 1
+        yticks = []
+        tick_step = report.ylim_top**(1/5.0)
+        for i in xrange(-5, 6):
+            yticks.append(tick_step**i)
+        axes.set_yticks(yticks)
+        axes.get_yaxis().set_major_formatter(ticker.ScalarFormatter())
+
+        axes.set_xlim(report.xlim_left or -1, report.xlim_right or plot_size)
+        axes.set_ylim(report.ylim_bottom or -1, report.ylim_top or plot_size)
+
+        for axis in [axes.xaxis, axes.yaxis]:
+            MatplotlibPlot.change_axis_formatter(
+                axis,
+                report.missing_val if report.show_missing else None)
+        return has_points
+
+
+class RelativeScatterPlotReport(ScatterPlotReport):
+    """
+    Generate a scatter plot that shows a relative comparison of two
+    algorithms with regard to the given attribute. The attribute value
+    of algorithm 1 is shown on the x-axis and the relation to the value
+    of algorithm 2 on the y-axis.
+    """
+
+    def __init__(self, show_missing=True, get_category=None, **kwargs):
+        ScatterPlotReport.__init__(self, show_missing, get_category, **kwargs)
+        if self.output_format == 'tex':
+            raise "not supported"
+        else:
+            self.writer = RelativeScatterMatplotlib
+
+    def _fill_categories(self, runs):
+        # We discard the *runs* parameter.
+        # Map category names to value tuples
+        categories = defaultdict(list)
+        self.ylim_bottom = 2
+        self.ylim_top = 0.5
+        self.xlim_left = float("inf")
+        for (domain, problem), runs in self.problem_runs.items():
+            if len(runs) != 2:
+                continue
+            run1, run2 = runs
+            assert (run1['algorithm'] == self.algorithms[0] and
+                    run2['algorithm'] == self.algorithms[1])
+            val1 = run1.get(self.attribute)
+            val2 = run2.get(self.attribute)
+            if val1 is None or val2 is None:
+                continue
+            category = self.get_category(run1, run2)
+            assert val1 > 0, (domain, problem, self.algorithms[0], val1)
+            assert val2 > 0, (domain, problem, self.algorithms[1], val2)
+            x = val1
+            y = val2 / float(val1)
+
+            categories[category].append((x, y))
+
+            self.ylim_top = max(self.ylim_top, y)
+            self.ylim_bottom = min(self.ylim_bottom, y)
+            self.xlim_left = min(self.xlim_left, x)
+
+        # center around 1
+        if self.ylim_bottom < 1:
+            self.ylim_top = max(self.ylim_top, 1 / float(self.ylim_bottom))
+        if self.ylim_top > 1:
+            self.ylim_bottom = min(self.ylim_bottom, 1 / float(self.ylim_top))
+        return categories
+
+    def _set_scales(self, xscale, yscale):
+        # ScatterPlot uses log-scaling on the x-axis by default.
+        PlotReport._set_scales(
+            self, xscale or self.attribute.scale or 'log', 'log')
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue744/sortedreport.py fast-downward/experiments/issue744/sortedreport.py
--- fast-downward-original/experiments/issue744/sortedreport.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue744/sortedreport.py	2020-06-17 03:29:39.510765700 -0300
@@ -0,0 +1,75 @@
+# -*- coding: utf-8 -*-
+#
+# Downward Lab uses the Lab package to conduct experiments with the
+# Fast Downward planning system.
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+from operator import itemgetter
+
+import logging
+
+from lab.reports import Table, DynamicDataModule
+
+from downward.reports import PlanningReport
+
+
+
+class SortedReport(PlanningReport):
+    def __init__(self, sort_spec, **kwargs):
+        PlanningReport.__init__(self, **kwargs)
+        self._sort_spec = sort_spec
+
+    def get_markup(self):
+        """
+        Return `txt2tags <http://txt2tags.org/>`_ markup for the report.
+
+        """
+        table = Table()
+        row_sort_module = RowSortModule(self._sort_spec)
+        table.dynamic_data_modules.append(row_sort_module)
+        for run_id, run in self.props.items():
+            row = {}
+            for key, value in run.items():
+                if key not in self.attributes:
+                    continue
+                if isinstance(value, (list, tuple)):
+                    key = '-'.join([str(item) for item in value])
+                row[key] = value
+            table.add_row(run_id, row)
+        return str(table)
+
+class RowSortModule(DynamicDataModule):
+    def __init__(self, sort_spec):
+        self._sort_spec = sort_spec
+
+    def modify_printable_row_order(self, table, row_order):
+        col_names = [None] + table.col_names
+
+        entries = []
+        for row_name in row_order:
+            if row_name == 'column names (never printed)':
+                continue
+            entry = [row_name] + table.get_row(row_name)
+            entries.append(tuple(entry))
+
+        for attribute, desc in reversed(self._sort_spec):
+            index = col_names.index(attribute)
+            reverse = desc == 'desc'
+
+            entries.sort(key=itemgetter(index), reverse=reverse)
+
+        new_row_order = ['column names (never printed)'] + [i[0] for i in entries]
+
+        return new_row_order
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue744/v1-opt-30min.py fast-downward/experiments/issue744/v1-opt-30min.py
--- fast-downward-original/experiments/issue744/v1-opt-30min.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue744/v1-opt-30min.py	2020-06-17 03:29:39.510765700 -0300
@@ -0,0 +1,121 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import itertools
+import os
+import subprocess
+
+from lab.environments import LocalEnvironment, BaselSlurmEnvironment
+from lab.reports import Attribute
+
+from downward.reports.compare import ComparativeReport
+
+import common_setup
+from common_setup import IssueConfig, IssueExperiment
+from relativescatter import RelativeScatterPlotReport
+
+EXPNAME = common_setup.get_experiment_name()
+DIR = os.path.dirname(os.path.abspath(__file__))
+BENCHMARKS_DIR = os.environ["DOWNWARD_BENCHMARKS"]
+REVISIONS = ["issue744-v1"]
+SEARCHES = [
+    ("bjolp-silent", [
+        "--evaluator", "lmc=lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]),admissible=true)",
+        "--search", "astar(lmc,lazy_evaluator=lmc, verbosity=silent)"]),
+    ("blind-silent", ["--search", "astar(blind(), verbosity=silent)"]),
+    ("cegar-silent", ["--search", "astar(cegar(), verbosity=silent)"]),
+    # ("divpot", ["--search", "astar(diverse_potentials(), verbosity=silent)"]),
+    ("ipdb-silent", ["--search", "astar(ipdb(), verbosity=silent)"]),
+    ("lmcut-silent", ["--search", "astar(lmcut(), verbosity=silent)"]),
+    ("mas-silent", [
+        "--search", "astar(merge_and_shrink(shrink_strategy=shrink_bisimulation(greedy=false),"
+        " merge_strategy=merge_sccs(order_of_sccs=topological,"
+        " merge_selector=score_based_filtering(scoring_functions=[goal_relevance, dfp, total_order])),"
+        " label_reduction=exact(before_shrinking=true, before_merging=false),"
+        " max_states=50000, threshold_before_merge=1, verbosity=normal), verbosity=silent)"]),
+    # ("seq+lmcut", ["--search", "astar(operatorcounting([state_equation_constraints(), lmcut_constraints()]), verbosity=silent)"]),
+    ("h2-silent", ["--search", "astar(hm(m=2), verbosity=silent)"]),
+    ("hmax-silent", ["--search", "astar(hmax(), verbosity=silent)"]),
+
+    ("bjolp-normal", [
+        "--evaluator", "lmc=lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]),admissible=true)",
+        "--search", "astar(lmc,lazy_evaluator=lmc, verbosity=normal)"]),
+    ("blind-normal", ["--search", "astar(blind(), verbosity=normal)"]),
+    ("cegar-normal", ["--search", "astar(cegar(), verbosity=normal)"]),
+    # ("divpot", ["--search", "astar(diverse_potentials(), verbosity=normal)"]),
+    ("ipdb-normal", ["--search", "astar(ipdb(), verbosity=normal)"]),
+    ("lmcut-normal", ["--search", "astar(lmcut(), verbosity=normal)"]),
+    ("mas-normal", [
+        "--search", "astar(merge_and_shrink(shrink_strategy=shrink_bisimulation(greedy=false),"
+        " merge_strategy=merge_sccs(order_of_sccs=topological,"
+        " merge_selector=score_based_filtering(scoring_functions=[goal_relevance, dfp, total_order])),"
+        " label_reduction=exact(before_shrinking=true, before_merging=false),"
+        " max_states=50000, threshold_before_merge=1, verbosity=normal), verbosity=normal)"]),
+    # ("seq+lmcut", ["--search", "astar(operatorcounting([state_equation_constraints(), lmcut_constraints()]), verbosity=normal)"]),
+    ("h2-normal", ["--search", "astar(hm(m=2), verbosity=normal)"]),
+    ("hmax-normal", ["--search", "astar(hmax(), verbosity=normal)"]),
+]
+CONFIGS = [
+    IssueConfig(search_nick, search,
+        driver_options=["--overall-time-limit", "30m"])
+    for rev in REVISIONS
+    for search_nick, search in SEARCHES
+]
+SUITE = common_setup.DEFAULT_OPTIMAL_SUITE
+ENVIRONMENT = BaselSlurmEnvironment(
+    partition="infai_2",
+    email="silvan.sievers@unibas.ch",
+    export=["PATH", "DOWNWARD_BENCHMARKS"])
+
+if common_setup.is_test_run():
+    SUITE = IssueExperiment.DEFAULT_TEST_SUITE
+    ENVIRONMENT = LocalEnvironment(processes=1)
+
+exp = IssueExperiment(
+    revisions=REVISIONS,
+    configs=CONFIGS,
+    environment=ENVIRONMENT,
+)
+exp.add_suite(BENCHMARKS_DIR, SUITE)
+
+exp.add_parser(exp.EXITCODE_PARSER)
+exp.add_parser(exp.TRANSLATOR_PARSER)
+exp.add_parser(exp.SINGLE_SEARCH_PARSER)
+exp.add_parser(exp.PLANNER_PARSER)
+exp.add_parser('custom-parser.py')
+
+exp.add_step("build", exp.build)
+exp.add_step("start", exp.start_runs)
+exp.add_fetcher(name="fetch")
+exp.add_parse_again_step()
+
+log_size = Attribute('log_size')
+attributes = IssueExperiment.DEFAULT_TABLE_ATTRIBUTES + [log_size]
+
+exp.add_absolute_report_step(attributes=attributes)
+#exp.add_comparison_table_step()
+
+sort_spec = [('log_size', 'desc')]
+attributes = ['run_dir', 'log_size']
+exp.add_sorted_report_step(attributes=attributes, sort_spec=sort_spec,filter_algorithm=[
+    "{}-bjolp-silent".format(REVISIONS[0]),
+    "{}-blind-silent".format(REVISIONS[0]),
+    "{}-cegar-silent".format(REVISIONS[0]),
+    "{}-ipdb-silent".format(REVISIONS[0]),
+    "{}-lmcut-silent".format(REVISIONS[0]),
+    "{}-mas-silent".format(REVISIONS[0]),
+    "{}-h2-silent".format(REVISIONS[0]),
+    "{}-hmax-silent".format(REVISIONS[0]),
+],name="silent")
+exp.add_sorted_report_step(attributes=attributes, sort_spec=sort_spec,filter_algorithm=[
+    "{}-bjolp-normal".format(REVISIONS[0]),
+    "{}-blind-normal".format(REVISIONS[0]),
+    "{}-cegar-normal".format(REVISIONS[0]),
+    "{}-ipdb-normal".format(REVISIONS[0]),
+    "{}-lmcut-normal".format(REVISIONS[0]),
+    "{}-mas-normal".format(REVISIONS[0]),
+    "{}-h2-normal".format(REVISIONS[0]),
+    "{}-hmax-normal".format(REVISIONS[0]),
+],name="normal")
+
+exp.run_steps()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue744/v1-sat-30min.py fast-downward/experiments/issue744/v1-sat-30min.py
--- fast-downward-original/experiments/issue744/v1-sat-30min.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue744/v1-sat-30min.py	2020-06-17 03:29:39.510765700 -0300
@@ -0,0 +1,152 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import itertools
+import os
+import subprocess
+
+from lab.environments import LocalEnvironment, BaselSlurmEnvironment
+from lab.reports import Attribute
+
+
+import common_setup
+from common_setup import IssueConfig, IssueExperiment
+from relativescatter import RelativeScatterPlotReport
+
+EXPNAME = common_setup.get_experiment_name()
+DIR = os.path.dirname(os.path.abspath(__file__))
+BENCHMARKS_DIR = os.environ["DOWNWARD_BENCHMARKS"]
+REVISIONS = ["issue744-v1"]
+CONFIG_DICT = {
+    "eager-greedy-ff-silent": [
+        "--evaluator",
+        "h=ff()",
+        "--search",
+        "eager_greedy([h], preferred=[h], verbosity=silent)"],
+    "eager-greedy-cea-silent": [
+        "--evaluator",
+        "h=cea()",
+        "--search",
+        "eager_greedy([h], preferred=[h], verbosity=silent)"],
+    "lazy-greedy-add-silent": [
+        "--evaluator",
+        "h=add()",
+        "--search",
+        "lazy_greedy([h], preferred=[h], verbosity=silent)"],
+    "lazy-greedy-cg-silent": [
+        "--evaluator",
+        "h=cg()",
+        "--search",
+        "lazy_greedy([h], preferred=[h], verbosity=silent)"],
+    "lama-first-silent": [
+        "--evaluator",
+        "hlm=lmcount(lm_factory=lm_rhw(reasonable_orders=true),transform=adapt_costs(one),pref=false)",
+        "--evaluator", "hff=ff(transform=adapt_costs(one))",
+        "--search", """lazy_greedy([hff,hlm],preferred=[hff,hlm],
+                                   cost_type=one,reopen_closed=false, verbosity=silent)"""],
+    "lama-first-typed-silent": [
+        "--evaluator",
+        "hlm=lmcount(lm_factory=lm_rhw(reasonable_orders=true),transform=adapt_costs(one),pref=false)",
+        "--evaluator", "hff=ff(transform=adapt_costs(one))",
+        "--search",
+            "lazy(alt([single(hff), single(hff, pref_only=true),"
+            "single(hlm), single(hlm, pref_only=true), type_based([hff, g()])], boost=1000),"
+            "preferred=[hff,hlm], cost_type=one, reopen_closed=false, randomize_successors=true,"
+            "preferred_successors_first=false, verbosity=silent)"],
+
+    "eager-greedy-ff-normal": [
+        "--evaluator",
+        "h=ff()",
+        "--search",
+        "eager_greedy([h], preferred=[h], verbosity=normal)"],
+    "eager-greedy-cea-normal": [
+        "--evaluator",
+        "h=cea()",
+        "--search",
+        "eager_greedy([h], preferred=[h], verbosity=normal)"],
+    "lazy-greedy-add-normal": [
+        "--evaluator",
+        "h=add()",
+        "--search",
+        "lazy_greedy([h], preferred=[h], verbosity=normal)"],
+    "lazy-greedy-cg-normal": [
+        "--evaluator",
+        "h=cg()",
+        "--search",
+        "lazy_greedy([h], preferred=[h], verbosity=normal)"],
+    "lama-first-normal": [
+        "--evaluator",
+        "hlm=lmcount(lm_factory=lm_rhw(reasonable_orders=true),transform=adapt_costs(one),pref=false)",
+        "--evaluator", "hff=ff(transform=adapt_costs(one))",
+        "--search", """lazy_greedy([hff,hlm],preferred=[hff,hlm],
+                                   cost_type=one,reopen_closed=false, verbosity=normal)"""],
+    "lama-first-typed-normal": [
+        "--evaluator",
+        "hlm=lmcount(lm_factory=lm_rhw(reasonable_orders=true),transform=adapt_costs(one),pref=false)",
+        "--evaluator", "hff=ff(transform=adapt_costs(one))",
+        "--search",
+            "lazy(alt([single(hff), single(hff, pref_only=true),"
+            "single(hlm), single(hlm, pref_only=true), type_based([hff, g()])], boost=1000),"
+            "preferred=[hff,hlm], cost_type=one, reopen_closed=false, randomize_successors=true,"
+            "preferred_successors_first=false, verbosity=normal)"],
+}
+CONFIGS = [
+    IssueConfig(config_nick, config,
+        driver_options=["--overall-time-limit", "30m"])
+    for rev in REVISIONS
+    for config_nick, config in CONFIG_DICT.items()
+]
+SUITE = common_setup.DEFAULT_SATISFICING_SUITE
+ENVIRONMENT = BaselSlurmEnvironment(
+    partition="infai_2",
+    email="silvan.sievers@unibas.ch",
+    export=["PATH", "DOWNWARD_BENCHMARKS"])
+
+if common_setup.is_test_run():
+    SUITE = IssueExperiment.DEFAULT_TEST_SUITE
+    ENVIRONMENT = LocalEnvironment(processes=1)
+
+exp = IssueExperiment(
+    revisions=REVISIONS,
+    configs=CONFIGS,
+    environment=ENVIRONMENT,
+)
+exp.add_suite(BENCHMARKS_DIR, SUITE)
+
+exp.add_parser(exp.EXITCODE_PARSER)
+exp.add_parser(exp.TRANSLATOR_PARSER)
+exp.add_parser(exp.SINGLE_SEARCH_PARSER)
+exp.add_parser(exp.PLANNER_PARSER)
+exp.add_parser('custom-parser.py')
+
+exp.add_step("build", exp.build)
+exp.add_step("start", exp.start_runs)
+exp.add_fetcher(name="fetch")
+exp.add_parse_again_step()
+
+log_size = Attribute('log_size')
+attributes = IssueExperiment.DEFAULT_TABLE_ATTRIBUTES + [log_size]
+
+exp.add_absolute_report_step(attributes=attributes)
+#exp.add_comparison_table_step()
+
+sort_spec = [('log_size', 'desc')]
+attributes = ['run_dir', 'log_size']
+exp.add_sorted_report_step(attributes=attributes, sort_spec=sort_spec,filter_algorithm=[
+    "{}-eager-greedy-ff-silent".format(REVISIONS[0]),
+    "{}-eager-greedy-cea-silent".format(REVISIONS[0]),
+    "{}-lazy-greedy-add-silent".format(REVISIONS[0]),
+    "{}-lazy-greedy-cg-silent".format(REVISIONS[0]),
+    "{}-lama-first-silent".format(REVISIONS[0]),
+    "{}-lama-first-typed-silent".format(REVISIONS[0]),
+],name="silent")
+exp.add_sorted_report_step(attributes=attributes, sort_spec=sort_spec,filter_algorithm=[
+    "{}-eager-greedy-ff-normal".format(REVISIONS[0]),
+    "{}-eager-greedy-cea-normal".format(REVISIONS[0]),
+    "{}-lazy-greedy-add-normal".format(REVISIONS[0]),
+    "{}-lazy-greedy-cg-normal".format(REVISIONS[0]),
+    "{}-lama-first-normal".format(REVISIONS[0]),
+    "{}-lama-first-typed-normal".format(REVISIONS[0]),
+],name="normal")
+
+exp.run_steps()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue752/common_setup.py fast-downward/experiments/issue752/common_setup.py
--- fast-downward-original/experiments/issue752/common_setup.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue752/common_setup.py	2020-06-17 03:29:39.510765700 -0300
@@ -0,0 +1,382 @@
+# -*- coding: utf-8 -*-
+
+import itertools
+import os
+import platform
+import subprocess
+import sys
+
+from lab.experiment import ARGPARSER
+from lab import tools
+
+from downward.experiment import FastDownwardExperiment
+from downward.reports.absolute import AbsoluteReport
+from downward.reports.compare import ComparativeReport
+from downward.reports.scatter import ScatterPlotReport
+
+from relativescatter import RelativeScatterPlotReport
+
+
+def parse_args():
+    ARGPARSER.add_argument(
+        "--test",
+        choices=["yes", "no", "auto"],
+        default="auto",
+        dest="test_run",
+        help="test experiment locally on a small suite if --test=yes or "
+             "--test=auto and we are not on a cluster")
+    return ARGPARSER.parse_args()
+
+ARGS = parse_args()
+
+
+DEFAULT_OPTIMAL_SUITE = [
+    'airport', 'barman-opt11-strips', 'barman-opt14-strips', 'blocks',
+    'childsnack-opt14-strips', 'depot', 'driverlog',
+    'elevators-opt08-strips', 'elevators-opt11-strips',
+    'floortile-opt11-strips', 'floortile-opt14-strips', 'freecell',
+    'ged-opt14-strips', 'grid', 'gripper', 'hiking-opt14-strips',
+    'logistics00', 'logistics98', 'miconic', 'movie', 'mprime',
+    'mystery', 'nomystery-opt11-strips', 'openstacks-opt08-strips',
+    'openstacks-opt11-strips', 'openstacks-opt14-strips',
+    'openstacks-strips', 'parcprinter-08-strips',
+    'parcprinter-opt11-strips', 'parking-opt11-strips',
+    'parking-opt14-strips', 'pathways-noneg', 'pegsol-08-strips',
+    'pegsol-opt11-strips', 'pipesworld-notankage',
+    'pipesworld-tankage', 'psr-small', 'rovers', 'satellite',
+    'scanalyzer-08-strips', 'scanalyzer-opt11-strips',
+    'sokoban-opt08-strips', 'sokoban-opt11-strips', 'storage',
+    'tetris-opt14-strips', 'tidybot-opt11-strips',
+    'tidybot-opt14-strips', 'tpp', 'transport-opt08-strips',
+    'transport-opt11-strips', 'transport-opt14-strips',
+    'trucks-strips', 'visitall-opt11-strips', 'visitall-opt14-strips',
+    'woodworking-opt08-strips', 'woodworking-opt11-strips',
+    'zenotravel']
+
+DEFAULT_SATISFICING_SUITE = [
+    'airport', 'assembly', 'barman-sat11-strips',
+    'barman-sat14-strips', 'blocks', 'cavediving-14-adl',
+    'childsnack-sat14-strips', 'citycar-sat14-adl', 'depot',
+    'driverlog', 'elevators-sat08-strips', 'elevators-sat11-strips',
+    'floortile-sat11-strips', 'floortile-sat14-strips', 'freecell',
+    'ged-sat14-strips', 'grid', 'gripper', 'hiking-sat14-strips',
+    'logistics00', 'logistics98', 'maintenance-sat14-adl', 'miconic',
+    'miconic-fulladl', 'miconic-simpleadl', 'movie', 'mprime',
+    'mystery', 'nomystery-sat11-strips', 'openstacks',
+    'openstacks-sat08-adl', 'openstacks-sat08-strips',
+    'openstacks-sat11-strips', 'openstacks-sat14-strips',
+    'openstacks-strips', 'optical-telegraphs', 'parcprinter-08-strips',
+    'parcprinter-sat11-strips', 'parking-sat11-strips',
+    'parking-sat14-strips', 'pathways', 'pathways-noneg',
+    'pegsol-08-strips', 'pegsol-sat11-strips', 'philosophers',
+    'pipesworld-notankage', 'pipesworld-tankage', 'psr-large',
+    'psr-middle', 'psr-small', 'rovers', 'satellite',
+    'scanalyzer-08-strips', 'scanalyzer-sat11-strips', 'schedule',
+    'sokoban-sat08-strips', 'sokoban-sat11-strips', 'storage',
+    'tetris-sat14-strips', 'thoughtful-sat14-strips',
+    'tidybot-sat11-strips', 'tpp', 'transport-sat08-strips',
+    'transport-sat11-strips', 'transport-sat14-strips', 'trucks',
+    'trucks-strips', 'visitall-sat11-strips', 'visitall-sat14-strips',
+    'woodworking-sat08-strips', 'woodworking-sat11-strips',
+    'zenotravel']
+
+
+def get_script():
+    """Get file name of main script."""
+    return tools.get_script_path()
+
+
+def get_script_dir():
+    """Get directory of main script.
+
+    Usually a relative directory (depends on how it was called by the user.)"""
+    return os.path.dirname(get_script())
+
+
+def get_experiment_name():
+    """Get name for experiment.
+
+    Derived from the absolute filename of the main script, e.g.
+    "/ham/spam/eggs.py" => "spam-eggs"."""
+    script = os.path.abspath(get_script())
+    script_dir = os.path.basename(os.path.dirname(script))
+    script_base = os.path.splitext(os.path.basename(script))[0]
+    return "%s-%s" % (script_dir, script_base)
+
+
+def get_data_dir():
+    """Get data dir for the experiment.
+
+    This is the subdirectory "data" of the directory containing
+    the main script."""
+    return os.path.join(get_script_dir(), "data", get_experiment_name())
+
+
+def get_repo_base():
+    """Get base directory of the repository, as an absolute path.
+
+    Search upwards in the directory tree from the main script until a
+    directory with a subdirectory named ".hg" is found.
+
+    Abort if the repo base cannot be found."""
+    path = os.path.abspath(get_script_dir())
+    while os.path.dirname(path) != path:
+        if os.path.exists(os.path.join(path, ".hg")):
+            return path
+        path = os.path.dirname(path)
+    sys.exit("repo base could not be found")
+
+
+def is_running_on_cluster():
+    node = platform.node()
+    return node.endswith(".scicore.unibas.ch") or node.endswith(".cluster.bc2.ch")
+
+
+def is_test_run():
+    return ARGS.test_run == "yes" or (
+        ARGS.test_run == "auto" and not is_running_on_cluster())
+
+
+def get_algo_nick(revision, config_nick):
+    return "{revision}-{config_nick}".format(**locals())
+
+
+class IssueConfig(object):
+    """Hold information about a planner configuration.
+
+    See FastDownwardExperiment.add_algorithm() for documentation of the
+    constructor's options.
+
+    """
+    def __init__(self, nick, component_options,
+                 build_options=None, driver_options=None):
+        self.nick = nick
+        self.component_options = component_options
+        self.build_options = build_options
+        self.driver_options = driver_options
+
+
+class IssueExperiment(FastDownwardExperiment):
+    """Subclass of FastDownwardExperiment with some convenience features."""
+
+    DEFAULT_TEST_SUITE = ["depot:p01.pddl", "gripper:prob01.pddl"]
+
+    DEFAULT_TABLE_ATTRIBUTES = [
+        "cost",
+        "coverage",
+        "error",
+        "evaluations",
+        "expansions",
+        "expansions_until_last_jump",
+        "generated",
+        "memory",
+        "quality",
+        "run_dir",
+        "score_evaluations",
+        "score_expansions",
+        "score_generated",
+        "score_memory",
+        "score_search_time",
+        "score_total_time",
+        "search_time",
+        "total_time",
+        ]
+
+    DEFAULT_SCATTER_PLOT_ATTRIBUTES = [
+        "evaluations",
+        "expansions",
+        "expansions_until_last_jump",
+        "initial_h_value",
+        "memory",
+        "search_time",
+        "total_time",
+        ]
+
+    PORTFOLIO_ATTRIBUTES = [
+        "cost",
+        "coverage",
+        "error",
+        "plan_length",
+        "run_dir",
+        ]
+
+    def __init__(self, revisions=None, configs=None, path=None, **kwargs):
+        """
+
+        You can either specify both *revisions* and *configs* or none
+        of them. If they are omitted, you will need to call
+        exp.add_algorithm() manually.
+
+        If *revisions* is given, it must be a non-empty list of
+        revision identifiers, which specify which planner versions to
+        use in the experiment. The same versions are used for
+        translator, preprocessor and search. ::
+
+            IssueExperiment(revisions=["issue123", "4b3d581643"], ...)
+
+        If *configs* is given, it must be a non-empty list of
+        IssueConfig objects. ::
+
+            IssueExperiment(..., configs=[
+                IssueConfig("ff", ["--search", "eager_greedy(ff())"]),
+                IssueConfig(
+                    "lama", [],
+                    driver_options=["--alias", "seq-sat-lama-2011"]),
+            ])
+
+        If *path* is specified, it must be the path to where the
+        experiment should be built (e.g.
+        /home/john/experiments/issue123/exp01/). If omitted, the
+        experiment path is derived automatically from the main
+        script's filename. Example::
+
+            script = experiments/issue123/exp01.py -->
+            path = experiments/issue123/data/issue123-exp01/
+
+        """
+
+        path = path or get_data_dir()
+
+        FastDownwardExperiment.__init__(self, path=path, **kwargs)
+
+        if (revisions and not configs) or (not revisions and configs):
+            raise ValueError(
+                "please provide either both or none of revisions and configs")
+
+        for rev in revisions:
+            for config in configs:
+                self.add_algorithm(
+                    get_algo_nick(rev, config.nick),
+                    get_repo_base(),
+                    rev,
+                    config.component_options,
+                    build_options=config.build_options,
+                    driver_options=config.driver_options)
+
+        self._revisions = revisions
+        self._configs = configs
+
+    @classmethod
+    def _is_portfolio(cls, config_nick):
+        return "fdss" in config_nick
+
+    @classmethod
+    def get_supported_attributes(cls, config_nick, attributes):
+        if cls._is_portfolio(config_nick):
+            return [attr for attr in attributes
+                    if attr in cls.PORTFOLIO_ATTRIBUTES]
+        return attributes
+
+    def add_absolute_report_step(self, **kwargs):
+        """Add step that makes an absolute report.
+
+        Absolute reports are useful for experiments that don't compare
+        revisions.
+
+        The report is written to the experiment evaluation directory.
+
+        All *kwargs* will be passed to the AbsoluteReport class. If the
+        keyword argument *attributes* is not specified, a default list
+        of attributes is used. ::
+
+            exp.add_absolute_report_step(attributes=["coverage"])
+
+        """
+        kwargs.setdefault("attributes", self.DEFAULT_TABLE_ATTRIBUTES)
+        report = AbsoluteReport(**kwargs)
+        outfile = os.path.join(
+            self.eval_dir,
+            get_experiment_name() + "." + report.output_format)
+        self.add_report(report, outfile=outfile)
+        self.add_step(
+            'publish-absolute-report', subprocess.call, ['publish', outfile])
+
+    def add_comparison_table_step(self, **kwargs):
+        """Add a step that makes pairwise revision comparisons.
+
+        Create comparative reports for all pairs of Fast Downward
+        revisions. Each report pairs up the runs of the same config and
+        lists the two absolute attribute values and their difference
+        for all attributes in kwargs["attributes"].
+
+        All *kwargs* will be passed to the CompareConfigsReport class.
+        If the keyword argument *attributes* is not specified, a
+        default list of attributes is used. ::
+
+            exp.add_comparison_table_step(attributes=["coverage"])
+
+        """
+        kwargs.setdefault("attributes", self.DEFAULT_TABLE_ATTRIBUTES)
+
+        def make_comparison_tables():
+            for rev1, rev2 in itertools.combinations(self._revisions, 2):
+                compared_configs = []
+                for config in self._configs:
+                    config_nick = config.nick
+                    compared_configs.append(
+                        ("%s-%s" % (rev1, config_nick),
+                         "%s-%s" % (rev2, config_nick),
+                         "Diff (%s)" % config_nick))
+                report = ComparativeReport(compared_configs, **kwargs)
+                outfile = os.path.join(
+                    self.eval_dir,
+                    "%s-%s-%s-compare.%s" % (
+                        self.name, rev1, rev2, report.output_format))
+                report(self.eval_dir, outfile)
+
+        def publish_comparison_tables():
+            for rev1, rev2 in itertools.combinations(self._revisions, 2):
+                outfile = os.path.join(
+                    self.eval_dir,
+                    "%s-%s-%s-compare.html" % (self.name, rev1, rev2))
+                subprocess.call(["publish", outfile])
+
+        self.add_step("make-comparison-tables", make_comparison_tables)
+        self.add_step(
+            "publish-comparison-tables", publish_comparison_tables)
+
+    def add_scatter_plot_step(self, relative=False, attributes=None):
+        """Add step creating (relative) scatter plots for all revision pairs.
+
+        Create a scatter plot for each combination of attribute,
+        configuration and revisions pair. If *attributes* is not
+        specified, a list of common scatter plot attributes is used.
+        For portfolios all attributes except "cost", "coverage" and
+        "plan_length" will be ignored. ::
+
+            exp.add_scatter_plot_step(attributes=["expansions"])
+
+        """
+        if relative:
+            report_class = RelativeScatterPlotReport
+            scatter_dir = os.path.join(self.eval_dir, "scatter-relative")
+            step_name = "make-relative-scatter-plots"
+        else:
+            report_class = ScatterPlotReport
+            scatter_dir = os.path.join(self.eval_dir, "scatter-absolute")
+            step_name = "make-absolute-scatter-plots"
+        if attributes is None:
+            attributes = self.DEFAULT_SCATTER_PLOT_ATTRIBUTES
+
+        def make_scatter_plot(config_nick, rev1, rev2, attribute):
+            name = "-".join([self.name, rev1, rev2, attribute, config_nick])
+            print "Make scatter plot for", name
+            algo1 = "{}-{}".format(rev1, config_nick)
+            algo2 = "{}-{}".format(rev2, config_nick)
+            report = report_class(
+                filter_config=[algo1, algo2],
+                attributes=[attribute],
+                get_category=lambda run1, run2: run1["domain"],
+                legend_location=(1.3, 0.5))
+            report(
+                self.eval_dir,
+                os.path.join(scatter_dir, rev1 + "-" + rev2, name))
+
+        def make_scatter_plots():
+            for config in self._configs:
+                for rev1, rev2 in itertools.combinations(self._revisions, 2):
+                    for attribute in self.get_supported_attributes(
+                            config.nick, attributes):
+                        make_scatter_plot(config.nick, rev1, rev2, attribute)
+
+        self.add_step(step_name, make_scatter_plots)
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue752/relativescatter.py fast-downward/experiments/issue752/relativescatter.py
--- fast-downward-original/experiments/issue752/relativescatter.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue752/relativescatter.py	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,105 @@
+# -*- coding: utf-8 -*-
+
+from collections import defaultdict
+
+from matplotlib import ticker
+
+from downward.reports.scatter import ScatterPlotReport
+from downward.reports.plot import PlotReport, Matplotlib, MatplotlibPlot
+
+
+# TODO: handle outliers
+
+# TODO: this is mostly copied from ScatterMatplotlib (scatter.py)
+class RelativeScatterMatplotlib(Matplotlib):
+    @classmethod
+    def _plot(cls, report, axes, categories, styles):
+        # Display grid
+        axes.grid(b=True, linestyle='-', color='0.75')
+
+        has_points = False
+        # Generate the scatter plots
+        for category, coords in sorted(categories.items()):
+            X, Y = zip(*coords)
+            axes.scatter(X, Y, s=42, label=category, **styles[category])
+            if X and Y:
+                has_points = True
+
+        if report.xscale == 'linear' or report.yscale == 'linear':
+            plot_size = report.missing_val * 1.01
+        else:
+            plot_size = report.missing_val * 1.25
+
+        # make 5 ticks above and below 1
+        yticks = []
+        tick_step = report.ylim_top**(1/5.0)
+        for i in xrange(-5, 6):
+            yticks.append(tick_step**i)
+        axes.set_yticks(yticks)
+        axes.get_yaxis().set_major_formatter(ticker.ScalarFormatter())
+
+        axes.set_xlim(report.xlim_left or -1, report.xlim_right or plot_size)
+        axes.set_ylim(report.ylim_bottom or -1, report.ylim_top or plot_size)
+
+        for axis in [axes.xaxis, axes.yaxis]:
+            MatplotlibPlot.change_axis_formatter(
+                axis,
+                report.missing_val if report.show_missing else None)
+        return has_points
+
+
+class RelativeScatterPlotReport(ScatterPlotReport):
+    """
+    Generate a scatter plot that shows a relative comparison of two
+    algorithms with regard to the given attribute. The attribute value
+    of algorithm 1 is shown on the x-axis and the relation to the value
+    of algorithm 2 on the y-axis.
+    """
+
+    def __init__(self, show_missing=True, get_category=None, **kwargs):
+        ScatterPlotReport.__init__(self, show_missing, get_category, **kwargs)
+        if self.output_format == 'tex':
+            raise "not supported"
+        else:
+            self.writer = RelativeScatterMatplotlib
+
+    def _fill_categories(self, runs):
+        # We discard the *runs* parameter.
+        # Map category names to value tuples
+        categories = defaultdict(list)
+        self.ylim_bottom = 2
+        self.ylim_top = 0.5
+        self.xlim_left = float("inf")
+        for (domain, problem), runs in self.problem_runs.items():
+            if len(runs) != 2:
+                continue
+            run1, run2 = runs
+            assert (run1['algorithm'] == self.algorithms[0] and
+                    run2['algorithm'] == self.algorithms[1])
+            val1 = run1.get(self.attribute)
+            val2 = run2.get(self.attribute)
+            if val1 is None or val2 is None:
+                continue
+            category = self.get_category(run1, run2)
+            assert val1 > 0, (domain, problem, self.algorithms[0], val1)
+            assert val2 > 0, (domain, problem, self.algorithms[1], val2)
+            x = val1
+            y = val2 / float(val1)
+
+            categories[category].append((x, y))
+
+            self.ylim_top = max(self.ylim_top, y)
+            self.ylim_bottom = min(self.ylim_bottom, y)
+            self.xlim_left = min(self.xlim_left, x)
+
+        # center around 1
+        if self.ylim_bottom < 1:
+            self.ylim_top = max(self.ylim_top, 1 / float(self.ylim_bottom))
+        if self.ylim_top > 1:
+            self.ylim_bottom = min(self.ylim_bottom, 1 / float(self.ylim_top))
+        return categories
+
+    def _set_scales(self, xscale, yscale):
+        # ScatterPlot uses log-scaling on the x-axis by default.
+        PlotReport._set_scales(
+            self, xscale or self.attribute.scale or 'log', 'log')
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue752/v1-new.py fast-downward/experiments/issue752/v1-new.py
--- fast-downward-original/experiments/issue752/v1-new.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue752/v1-new.py	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,36 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import os
+
+from lab.environments import LocalEnvironment, BaselSlurmEnvironment
+
+import common_setup
+from common_setup import IssueConfig, IssueExperiment
+from relativescatter import RelativeScatterPlotReport
+
+DIR = os.path.dirname(os.path.abspath(__file__))
+BENCHMARKS_DIR = os.environ["DOWNWARD_BENCHMARKS"]
+REVISIONS = ["issue752-v1"]
+CONFIGS = [
+    IssueConfig('astar-blind', ["--search", "astar(blind())"],
+        build_options=["release64"], driver_options=["--build", "release64"]),
+    IssueConfig('astar-seq-cplex1271', ["--search", "astar(operatorcounting([state_equation_constraints()], lpsolver=cplex))"],
+        build_options=["release64"], driver_options=["--build", "release64"]),
+]
+SUITE = common_setup.DEFAULT_OPTIMAL_SUITE
+ENVIRONMENT = BaselSlurmEnvironment(email="florian.pommerening@unibas.ch", export=["PATH", "DOWNWARD_BENCHMARKS"])
+
+if common_setup.is_test_run():
+    SUITE = IssueExperiment.DEFAULT_TEST_SUITE
+    ENVIRONMENT = LocalEnvironment(processes=1)
+
+exp = IssueExperiment(
+    revisions=REVISIONS,
+    configs=CONFIGS,
+    environment=ENVIRONMENT,
+)
+exp.add_suite(BENCHMARKS_DIR, SUITE)
+exp.add_absolute_report_step()
+
+exp.run_steps()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue752/v1-old.py fast-downward/experiments/issue752/v1-old.py
--- fast-downward-original/experiments/issue752/v1-old.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue752/v1-old.py	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,36 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import os
+
+from lab.environments import LocalEnvironment, BaselSlurmEnvironment
+
+import common_setup
+from common_setup import IssueConfig, IssueExperiment
+from relativescatter import RelativeScatterPlotReport
+
+DIR = os.path.dirname(os.path.abspath(__file__))
+BENCHMARKS_DIR = os.environ["DOWNWARD_BENCHMARKS"]
+REVISIONS = ["issue752-base"]
+CONFIGS = [
+    IssueConfig('astar-blind', ["--search", "astar(blind())"],
+        build_options=["release64"], driver_options=["--build", "release64"]),
+    IssueConfig('astar-seq-cplex1251', ["--search", "astar(operatorcounting([state_equation_constraints()], lpsolver=cplex))"],
+        build_options=["release64"], driver_options=["--build", "release64"]),
+]
+SUITE = common_setup.DEFAULT_OPTIMAL_SUITE
+ENVIRONMENT = BaselSlurmEnvironment(email="florian.pommerening@unibas.ch", export=["PATH", "DOWNWARD_BENCHMARKS"])
+
+if common_setup.is_test_run():
+    SUITE = IssueExperiment.DEFAULT_TEST_SUITE
+    ENVIRONMENT = LocalEnvironment(processes=1)
+
+exp = IssueExperiment(
+    revisions=REVISIONS,
+    configs=CONFIGS,
+    environment=ENVIRONMENT,
+)
+exp.add_suite(BENCHMARKS_DIR, SUITE)
+exp.add_absolute_report_step()
+
+exp.run_steps()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue752/v1-soplex.py fast-downward/experiments/issue752/v1-soplex.py
--- fast-downward-original/experiments/issue752/v1-soplex.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue752/v1-soplex.py	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,56 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import os
+
+from lab.environments import LocalEnvironment, BaselSlurmEnvironment
+
+import common_setup
+from common_setup import IssueConfig, IssueExperiment
+from relativescatter import RelativeScatterPlotReport
+
+DIR = os.path.dirname(os.path.abspath(__file__))
+BENCHMARKS_DIR = os.environ["DOWNWARD_BENCHMARKS"]
+REVISIONS = ["issue752-v1"]
+CONFIGS = [
+    IssueConfig('astar-seq-cplex', ["--search", "astar(operatorcounting([state_equation_constraints()], lpsolver=cplex))"],
+        build_options=["release64"], driver_options=["--build", "release64"]),
+    IssueConfig('astar-seq-soplex', ["--search", "astar(operatorcounting([state_equation_constraints()], lpsolver=soplex))"],
+        build_options=["release64"], driver_options=["--build", "release64"]),
+    IssueConfig('astar-seq-pho-cplex', ["--search", "astar(operatorcounting([state_equation_constraints(), lmcut_constraints()], lpsolver=cplex))"],
+        build_options=["release64"], driver_options=["--build", "release64"]),
+    IssueConfig('astar-seq-pho-soplex', ["--search", "astar(operatorcounting([state_equation_constraints(), lmcut_constraints()], lpsolver=soplex))"],
+        build_options=["release64"], driver_options=["--build", "release64"]),
+    IssueConfig('astar-seq-lmcut-cplex', ["--search", "astar(operatorcounting([state_equation_constraints(), pho_constraints(patterns=systematic(2))], lpsolver=cplex))"],
+        build_options=["release64"], driver_options=["--build", "release64"]),
+    IssueConfig('astar-seq-lmcut-soplex', ["--search", "astar(operatorcounting([state_equation_constraints(), pho_constraints(patterns=systematic(2))], lpsolver=soplex))"],
+        build_options=["release64"], driver_options=["--build", "release64"]),
+]
+SUITE = common_setup.DEFAULT_OPTIMAL_SUITE
+ENVIRONMENT = BaselSlurmEnvironment(email="florian.pommerening@unibas.ch", export=["PATH", "DOWNWARD_BENCHMARKS"])
+
+if common_setup.is_test_run():
+    SUITE = IssueExperiment.DEFAULT_TEST_SUITE
+    ENVIRONMENT = LocalEnvironment(processes=1)
+
+exp = IssueExperiment(
+    revisions=REVISIONS,
+    configs=CONFIGS,
+    environment=ENVIRONMENT,
+)
+exp.add_suite(BENCHMARKS_DIR, SUITE)
+exp.add_absolute_report_step()
+
+for attribute in ["total_time"]:
+    for config in ["astar-seq-pho", "astar-seq-lmcut"]:
+        for rev in REVISIONS:
+            exp.add_report(
+                RelativeScatterPlotReport(
+                    attributes=[attribute],
+                    filter_algorithm=["{}-{}-{}".format(rev, config, solver) for solver in ["cplex", "soplex"]],
+                    get_category=lambda run1, run2: run1.get("domain"),
+                ),
+                outfile="{}-{}-{}.png".format(exp.name, attribute, config)
+            )
+
+exp.run_steps()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue752/v2.py fast-downward/experiments/issue752/v2.py
--- fast-downward-original/experiments/issue752/v2.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue752/v2.py	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,55 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import os
+
+from lab.environments import LocalEnvironment, BaselSlurmEnvironment
+
+import common_setup
+from common_setup import IssueConfig, IssueExperiment
+from relativescatter import RelativeScatterPlotReport
+
+DIR = os.path.dirname(os.path.abspath(__file__))
+BENCHMARKS_DIR = os.environ["DOWNWARD_BENCHMARKS"]
+REVISIONS = ["issue752-v2"]
+CONFIGS = [
+    IssueConfig("opcount-seq-lmcut-soplex", ["--search", "astar(operatorcounting([state_equation_constraints(), lmcut_constraints()], lpsolver=soplex))"]),
+    IssueConfig("diverse-potentials-soplex", ["--search", "astar(diverse_potentials(lpsolver=soplex))"]),
+    IssueConfig("optimal-lmcount-soplex", ["--search", "astar(lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]), admissible=true, optimal=true, lpsolver=soplex))"]),
+    IssueConfig("opcount-seq-lmcut-cplex", ["--search", "astar(operatorcounting([state_equation_constraints(), lmcut_constraints()], lpsolver=cplex))"]),
+    IssueConfig("diverse-potentials-cplex", ["--search", "astar(diverse_potentials(lpsolver=cplex))"]),
+    IssueConfig("optimal-lmcount-cplex", ["--search", "astar(lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]), admissible=true, optimal=true, lpsolver=cplex))"]),
+]
+SUITE = common_setup.DEFAULT_OPTIMAL_SUITE
+ENVIRONMENT = BaselSlurmEnvironment(partition="infai_2", email="florian.pommerening@unibas.ch")
+
+if common_setup.is_test_run():
+    SUITE = IssueExperiment.DEFAULT_TEST_SUITE
+    ENVIRONMENT = LocalEnvironment(processes=4)
+
+exp = IssueExperiment(
+    revisions=REVISIONS,
+    configs=CONFIGS,
+    environment=ENVIRONMENT,
+)
+exp.add_suite(BENCHMARKS_DIR, SUITE)
+
+exp.add_parser(exp.EXITCODE_PARSER)
+exp.add_parser(exp.TRANSLATOR_PARSER)
+exp.add_parser(exp.SINGLE_SEARCH_PARSER)
+exp.add_parser(exp.PLANNER_PARSER)
+
+exp.add_step('build', exp.build)
+exp.add_step('start', exp.start_runs)
+exp.add_fetcher(name='fetch')
+
+exp.add_absolute_report_step()
+
+for nick in ["opcount-seq-lmcut", "diverse-potentials", "optimal-lmcount"]:
+    exp.add_report(RelativeScatterPlotReport(
+        attributes=["total_time"],
+        filter_algorithm=["issue752-v2-%s-%s" % (nick, solver) for solver in ["cplex", "soplex"]],
+        get_category=lambda r1, r2: r1["domain"]),
+        outfile="issue752-v2-scatter-total-time-%s.png" % nick)
+
+exp.run_steps()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue752/v3.py fast-downward/experiments/issue752/v3.py
--- fast-downward-original/experiments/issue752/v3.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue752/v3.py	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,55 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import os
+
+from lab.environments import LocalEnvironment, BaselSlurmEnvironment
+
+import common_setup
+from common_setup import IssueConfig, IssueExperiment
+from relativescatter import RelativeScatterPlotReport
+
+DIR = os.path.dirname(os.path.abspath(__file__))
+BENCHMARKS_DIR = os.environ["DOWNWARD_BENCHMARKS"]
+REVISIONS = ["issue752-v3"]
+CONFIGS = [
+    IssueConfig("opcount-seq-lmcut-soplex", ["--search", "astar(operatorcounting([state_equation_constraints(), lmcut_constraints()], lpsolver=soplex))"]),
+    IssueConfig("diverse-potentials-soplex", ["--search", "astar(diverse_potentials(lpsolver=soplex))"]),
+    IssueConfig("optimal-lmcount-soplex", ["--search", "astar(lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]), admissible=true, optimal=true, lpsolver=soplex))"]),
+    IssueConfig("opcount-seq-lmcut-cplex", ["--search", "astar(operatorcounting([state_equation_constraints(), lmcut_constraints()], lpsolver=cplex))"]),
+    IssueConfig("diverse-potentials-cplex", ["--search", "astar(diverse_potentials(lpsolver=cplex))"]),
+    IssueConfig("optimal-lmcount-cplex", ["--search", "astar(lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]), admissible=true, optimal=true, lpsolver=cplex))"]),
+]
+SUITE = common_setup.DEFAULT_OPTIMAL_SUITE
+ENVIRONMENT = BaselSlurmEnvironment(partition="infai_2", email="florian.pommerening@unibas.ch")
+
+if common_setup.is_test_run():
+    SUITE = IssueExperiment.DEFAULT_TEST_SUITE
+    ENVIRONMENT = LocalEnvironment(processes=4)
+
+exp = IssueExperiment(
+    revisions=REVISIONS,
+    configs=CONFIGS,
+    environment=ENVIRONMENT,
+)
+exp.add_suite(BENCHMARKS_DIR, SUITE)
+
+exp.add_parser(exp.EXITCODE_PARSER)
+exp.add_parser(exp.TRANSLATOR_PARSER)
+exp.add_parser(exp.SINGLE_SEARCH_PARSER)
+exp.add_parser(exp.PLANNER_PARSER)
+
+exp.add_step('build', exp.build)
+exp.add_step('start', exp.start_runs)
+exp.add_fetcher(name='fetch')
+
+exp.add_absolute_report_step()
+
+for nick in ["opcount-seq-lmcut", "diverse-potentials", "optimal-lmcount"]:
+    exp.add_report(RelativeScatterPlotReport(
+        attributes=["total_time"],
+        filter_algorithm=["issue752-v3-%s-%s" % (nick, solver) for solver in ["cplex", "soplex"]],
+        get_category=lambda r1, r2: r1["domain"]),
+        outfile="issue752-v3-scatter-total-time-%s.png" % nick)
+
+exp.run_steps()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue925/common_setup.py fast-downward/experiments/issue925/common_setup.py
--- fast-downward-original/experiments/issue925/common_setup.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue925/common_setup.py	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,382 @@
+# -*- coding: utf-8 -*-
+
+import itertools
+import os
+import platform
+import subprocess
+import sys
+
+from lab.experiment import ARGPARSER
+from lab import tools
+
+from downward.experiment import FastDownwardExperiment
+from downward.reports.absolute import AbsoluteReport
+from downward.reports.compare import ComparativeReport
+from downward.reports.scatter import ScatterPlotReport
+
+from relativescatter import RelativeScatterPlotReport
+
+
+def parse_args():
+    ARGPARSER.add_argument(
+        "--test",
+        choices=["yes", "no", "auto"],
+        default="auto",
+        dest="test_run",
+        help="test experiment locally on a small suite if --test=yes or "
+             "--test=auto and we are not on a cluster")
+    return ARGPARSER.parse_args()
+
+ARGS = parse_args()
+
+
+DEFAULT_OPTIMAL_SUITE = [
+    'airport', 'barman-opt11-strips', 'barman-opt14-strips', 'blocks',
+    'childsnack-opt14-strips', 'depot', 'driverlog',
+    'elevators-opt08-strips', 'elevators-opt11-strips',
+    'floortile-opt11-strips', 'floortile-opt14-strips', 'freecell',
+    'ged-opt14-strips', 'grid', 'gripper', 'hiking-opt14-strips',
+    'logistics00', 'logistics98', 'miconic', 'movie', 'mprime',
+    'mystery', 'nomystery-opt11-strips', 'openstacks-opt08-strips',
+    'openstacks-opt11-strips', 'openstacks-opt14-strips',
+    'openstacks-strips', 'parcprinter-08-strips',
+    'parcprinter-opt11-strips', 'parking-opt11-strips',
+    'parking-opt14-strips', 'pathways-noneg', 'pegsol-08-strips',
+    'pegsol-opt11-strips', 'pipesworld-notankage',
+    'pipesworld-tankage', 'psr-small', 'rovers', 'satellite',
+    'scanalyzer-08-strips', 'scanalyzer-opt11-strips',
+    'sokoban-opt08-strips', 'sokoban-opt11-strips', 'storage',
+    'tetris-opt14-strips', 'tidybot-opt11-strips',
+    'tidybot-opt14-strips', 'tpp', 'transport-opt08-strips',
+    'transport-opt11-strips', 'transport-opt14-strips',
+    'trucks-strips', 'visitall-opt11-strips', 'visitall-opt14-strips',
+    'woodworking-opt08-strips', 'woodworking-opt11-strips',
+    'zenotravel']
+
+DEFAULT_SATISFICING_SUITE = [
+    'airport', 'assembly', 'barman-sat11-strips',
+    'barman-sat14-strips', 'blocks', 'cavediving-14-adl',
+    'childsnack-sat14-strips', 'citycar-sat14-adl', 'depot',
+    'driverlog', 'elevators-sat08-strips', 'elevators-sat11-strips',
+    'floortile-sat11-strips', 'floortile-sat14-strips', 'freecell',
+    'ged-sat14-strips', 'grid', 'gripper', 'hiking-sat14-strips',
+    'logistics00', 'logistics98', 'maintenance-sat14-adl', 'miconic',
+    'miconic-fulladl', 'miconic-simpleadl', 'movie', 'mprime',
+    'mystery', 'nomystery-sat11-strips', 'openstacks',
+    'openstacks-sat08-adl', 'openstacks-sat08-strips',
+    'openstacks-sat11-strips', 'openstacks-sat14-strips',
+    'openstacks-strips', 'optical-telegraphs', 'parcprinter-08-strips',
+    'parcprinter-sat11-strips', 'parking-sat11-strips',
+    'parking-sat14-strips', 'pathways', 'pathways-noneg',
+    'pegsol-08-strips', 'pegsol-sat11-strips', 'philosophers',
+    'pipesworld-notankage', 'pipesworld-tankage', 'psr-large',
+    'psr-middle', 'psr-small', 'rovers', 'satellite',
+    'scanalyzer-08-strips', 'scanalyzer-sat11-strips', 'schedule',
+    'sokoban-sat08-strips', 'sokoban-sat11-strips', 'storage',
+    'tetris-sat14-strips', 'thoughtful-sat14-strips',
+    'tidybot-sat11-strips', 'tpp', 'transport-sat08-strips',
+    'transport-sat11-strips', 'transport-sat14-strips', 'trucks',
+    'trucks-strips', 'visitall-sat11-strips', 'visitall-sat14-strips',
+    'woodworking-sat08-strips', 'woodworking-sat11-strips',
+    'zenotravel']
+
+
+def get_script():
+    """Get file name of main script."""
+    return tools.get_script_path()
+
+
+def get_script_dir():
+    """Get directory of main script.
+
+    Usually a relative directory (depends on how it was called by the user.)"""
+    return os.path.dirname(get_script())
+
+
+def get_experiment_name():
+    """Get name for experiment.
+
+    Derived from the absolute filename of the main script, e.g.
+    "/ham/spam/eggs.py" => "spam-eggs"."""
+    script = os.path.abspath(get_script())
+    script_dir = os.path.basename(os.path.dirname(script))
+    script_base = os.path.splitext(os.path.basename(script))[0]
+    return "%s-%s" % (script_dir, script_base)
+
+
+def get_data_dir():
+    """Get data dir for the experiment.
+
+    This is the subdirectory "data" of the directory containing
+    the main script."""
+    return os.path.join(get_script_dir(), "data", get_experiment_name())
+
+
+def get_repo_base():
+    """Get base directory of the repository, as an absolute path.
+
+    Search upwards in the directory tree from the main script until a
+    directory with a subdirectory named ".hg" is found.
+
+    Abort if the repo base cannot be found."""
+    path = os.path.abspath(get_script_dir())
+    while os.path.dirname(path) != path:
+        if os.path.exists(os.path.join(path, ".hg")):
+            return path
+        path = os.path.dirname(path)
+    sys.exit("repo base could not be found")
+
+
+def is_running_on_cluster():
+    node = platform.node()
+    return node.endswith(".scicore.unibas.ch") or node.endswith(".cluster.bc2.ch")
+
+
+def is_test_run():
+    return ARGS.test_run == "yes" or (
+        ARGS.test_run == "auto" and not is_running_on_cluster())
+
+
+def get_algo_nick(revision, config_nick):
+    return "{revision}-{config_nick}".format(**locals())
+
+
+class IssueConfig(object):
+    """Hold information about a planner configuration.
+
+    See FastDownwardExperiment.add_algorithm() for documentation of the
+    constructor's options.
+
+    """
+    def __init__(self, nick, component_options,
+                 build_options=None, driver_options=None):
+        self.nick = nick
+        self.component_options = component_options
+        self.build_options = build_options
+        self.driver_options = driver_options
+
+
+class IssueExperiment(FastDownwardExperiment):
+    """Subclass of FastDownwardExperiment with some convenience features."""
+
+    DEFAULT_TEST_SUITE = ["depot:p01.pddl", "gripper:prob01.pddl"]
+
+    DEFAULT_TABLE_ATTRIBUTES = [
+        "cost",
+        "coverage",
+        "error",
+        "evaluations",
+        "expansions",
+        "expansions_until_last_jump",
+        "generated",
+        "memory",
+        "quality",
+        "run_dir",
+        "score_evaluations",
+        "score_expansions",
+        "score_generated",
+        "score_memory",
+        "score_search_time",
+        "score_total_time",
+        "search_time",
+        "total_time",
+        ]
+
+    DEFAULT_SCATTER_PLOT_ATTRIBUTES = [
+        "evaluations",
+        "expansions",
+        "expansions_until_last_jump",
+        "initial_h_value",
+        "memory",
+        "search_time",
+        "total_time",
+        ]
+
+    PORTFOLIO_ATTRIBUTES = [
+        "cost",
+        "coverage",
+        "error",
+        "plan_length",
+        "run_dir",
+        ]
+
+    def __init__(self, revisions=None, configs=None, path=None, **kwargs):
+        """
+
+        You can either specify both *revisions* and *configs* or none
+        of them. If they are omitted, you will need to call
+        exp.add_algorithm() manually.
+
+        If *revisions* is given, it must be a non-empty list of
+        revision identifiers, which specify which planner versions to
+        use in the experiment. The same versions are used for
+        translator, preprocessor and search. ::
+
+            IssueExperiment(revisions=["issue123", "4b3d581643"], ...)
+
+        If *configs* is given, it must be a non-empty list of
+        IssueConfig objects. ::
+
+            IssueExperiment(..., configs=[
+                IssueConfig("ff", ["--search", "eager_greedy(ff())"]),
+                IssueConfig(
+                    "lama", [],
+                    driver_options=["--alias", "seq-sat-lama-2011"]),
+            ])
+
+        If *path* is specified, it must be the path to where the
+        experiment should be built (e.g.
+        /home/john/experiments/issue123/exp01/). If omitted, the
+        experiment path is derived automatically from the main
+        script's filename. Example::
+
+            script = experiments/issue123/exp01.py -->
+            path = experiments/issue123/data/issue123-exp01/
+
+        """
+
+        path = path or get_data_dir()
+
+        FastDownwardExperiment.__init__(self, path=path, **kwargs)
+
+        if (revisions and not configs) or (not revisions and configs):
+            raise ValueError(
+                "please provide either both or none of revisions and configs")
+
+        for rev in revisions:
+            for config in configs:
+                self.add_algorithm(
+                    get_algo_nick(rev, config.nick),
+                    get_repo_base(),
+                    rev,
+                    config.component_options,
+                    build_options=config.build_options,
+                    driver_options=config.driver_options)
+
+        self._revisions = revisions
+        self._configs = configs
+
+    @classmethod
+    def _is_portfolio(cls, config_nick):
+        return "fdss" in config_nick
+
+    @classmethod
+    def get_supported_attributes(cls, config_nick, attributes):
+        if cls._is_portfolio(config_nick):
+            return [attr for attr in attributes
+                    if attr in cls.PORTFOLIO_ATTRIBUTES]
+        return attributes
+
+    def add_absolute_report_step(self, **kwargs):
+        """Add step that makes an absolute report.
+
+        Absolute reports are useful for experiments that don't compare
+        revisions.
+
+        The report is written to the experiment evaluation directory.
+
+        All *kwargs* will be passed to the AbsoluteReport class. If the
+        keyword argument *attributes* is not specified, a default list
+        of attributes is used. ::
+
+            exp.add_absolute_report_step(attributes=["coverage"])
+
+        """
+        kwargs.setdefault("attributes", self.DEFAULT_TABLE_ATTRIBUTES)
+        report = AbsoluteReport(**kwargs)
+        outfile = os.path.join(
+            self.eval_dir,
+            get_experiment_name() + "." + report.output_format)
+        self.add_report(report, outfile=outfile)
+        self.add_step(
+            'publish-absolute-report', subprocess.call, ['publish', outfile])
+
+    def add_comparison_table_step(self, **kwargs):
+        """Add a step that makes pairwise revision comparisons.
+
+        Create comparative reports for all pairs of Fast Downward
+        revisions. Each report pairs up the runs of the same config and
+        lists the two absolute attribute values and their difference
+        for all attributes in kwargs["attributes"].
+
+        All *kwargs* will be passed to the CompareConfigsReport class.
+        If the keyword argument *attributes* is not specified, a
+        default list of attributes is used. ::
+
+            exp.add_comparison_table_step(attributes=["coverage"])
+
+        """
+        kwargs.setdefault("attributes", self.DEFAULT_TABLE_ATTRIBUTES)
+
+        def make_comparison_tables():
+            for rev1, rev2 in itertools.combinations(self._revisions, 2):
+                compared_configs = []
+                for config in self._configs:
+                    config_nick = config.nick
+                    compared_configs.append(
+                        ("%s-%s" % (rev1, config_nick),
+                         "%s-%s" % (rev2, config_nick),
+                         "Diff (%s)" % config_nick))
+                report = ComparativeReport(compared_configs, **kwargs)
+                outfile = os.path.join(
+                    self.eval_dir,
+                    "%s-%s-%s-compare.%s" % (
+                        self.name, rev1, rev2, report.output_format))
+                report(self.eval_dir, outfile)
+
+        def publish_comparison_tables():
+            for rev1, rev2 in itertools.combinations(self._revisions, 2):
+                outfile = os.path.join(
+                    self.eval_dir,
+                    "%s-%s-%s-compare.html" % (self.name, rev1, rev2))
+                subprocess.call(["publish", outfile])
+
+        self.add_step("make-comparison-tables", make_comparison_tables)
+        self.add_step(
+            "publish-comparison-tables", publish_comparison_tables)
+
+    def add_scatter_plot_step(self, relative=False, attributes=None):
+        """Add step creating (relative) scatter plots for all revision pairs.
+
+        Create a scatter plot for each combination of attribute,
+        configuration and revisions pair. If *attributes* is not
+        specified, a list of common scatter plot attributes is used.
+        For portfolios all attributes except "cost", "coverage" and
+        "plan_length" will be ignored. ::
+
+            exp.add_scatter_plot_step(attributes=["expansions"])
+
+        """
+        if relative:
+            report_class = RelativeScatterPlotReport
+            scatter_dir = os.path.join(self.eval_dir, "scatter-relative")
+            step_name = "make-relative-scatter-plots"
+        else:
+            report_class = ScatterPlotReport
+            scatter_dir = os.path.join(self.eval_dir, "scatter-absolute")
+            step_name = "make-absolute-scatter-plots"
+        if attributes is None:
+            attributes = self.DEFAULT_SCATTER_PLOT_ATTRIBUTES
+
+        def make_scatter_plot(config_nick, rev1, rev2, attribute):
+            name = "-".join([self.name, rev1, rev2, attribute, config_nick])
+            print "Make scatter plot for", name
+            algo1 = "{}-{}".format(rev1, config_nick)
+            algo2 = "{}-{}".format(rev2, config_nick)
+            report = report_class(
+                filter_config=[algo1, algo2],
+                attributes=[attribute],
+                get_category=lambda run1, run2: run1["domain"],
+                legend_location=(1.3, 0.5))
+            report(
+                self.eval_dir,
+                os.path.join(scatter_dir, rev1 + "-" + rev2, name))
+
+        def make_scatter_plots():
+            for config in self._configs:
+                for rev1, rev2 in itertools.combinations(self._revisions, 2):
+                    for attribute in self.get_supported_attributes(
+                            config.nick, attributes):
+                        make_scatter_plot(config.nick, rev1, rev2, attribute)
+
+        self.add_step(step_name, make_scatter_plots)
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue925/relativescatter.py fast-downward/experiments/issue925/relativescatter.py
--- fast-downward-original/experiments/issue925/relativescatter.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue925/relativescatter.py	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,105 @@
+# -*- coding: utf-8 -*-
+
+from collections import defaultdict
+
+from matplotlib import ticker
+
+from downward.reports.scatter import ScatterPlotReport
+from downward.reports.plot import PlotReport, Matplotlib, MatplotlibPlot
+
+
+# TODO: handle outliers
+
+# TODO: this is mostly copied from ScatterMatplotlib (scatter.py)
+class RelativeScatterMatplotlib(Matplotlib):
+    @classmethod
+    def _plot(cls, report, axes, categories, styles):
+        # Display grid
+        axes.grid(b=True, linestyle='-', color='0.75')
+
+        has_points = False
+        # Generate the scatter plots
+        for category, coords in sorted(categories.items()):
+            X, Y = zip(*coords)
+            axes.scatter(X, Y, s=42, label=category, **styles[category])
+            if X and Y:
+                has_points = True
+
+        if report.xscale == 'linear' or report.yscale == 'linear':
+            plot_size = report.missing_val * 1.01
+        else:
+            plot_size = report.missing_val * 1.25
+
+        # make 5 ticks above and below 1
+        yticks = []
+        tick_step = report.ylim_top**(1/5.0)
+        for i in xrange(-5, 6):
+            yticks.append(tick_step**i)
+        axes.set_yticks(yticks)
+        axes.get_yaxis().set_major_formatter(ticker.ScalarFormatter())
+
+        axes.set_xlim(report.xlim_left or -1, report.xlim_right or plot_size)
+        axes.set_ylim(report.ylim_bottom or -1, report.ylim_top or plot_size)
+
+        for axis in [axes.xaxis, axes.yaxis]:
+            MatplotlibPlot.change_axis_formatter(
+                axis,
+                report.missing_val if report.show_missing else None)
+        return has_points
+
+
+class RelativeScatterPlotReport(ScatterPlotReport):
+    """
+    Generate a scatter plot that shows a relative comparison of two
+    algorithms with regard to the given attribute. The attribute value
+    of algorithm 1 is shown on the x-axis and the relation to the value
+    of algorithm 2 on the y-axis.
+    """
+
+    def __init__(self, show_missing=True, get_category=None, **kwargs):
+        ScatterPlotReport.__init__(self, show_missing, get_category, **kwargs)
+        if self.output_format == 'tex':
+            raise "not supported"
+        else:
+            self.writer = RelativeScatterMatplotlib
+
+    def _fill_categories(self, runs):
+        # We discard the *runs* parameter.
+        # Map category names to value tuples
+        categories = defaultdict(list)
+        self.ylim_bottom = 2
+        self.ylim_top = 0.5
+        self.xlim_left = float("inf")
+        for (domain, problem), runs in self.problem_runs.items():
+            if len(runs) != 2:
+                continue
+            run1, run2 = runs
+            assert (run1['algorithm'] == self.algorithms[0] and
+                    run2['algorithm'] == self.algorithms[1])
+            val1 = run1.get(self.attribute)
+            val2 = run2.get(self.attribute)
+            if val1 is None or val2 is None:
+                continue
+            category = self.get_category(run1, run2)
+            assert val1 > 0, (domain, problem, self.algorithms[0], val1)
+            assert val2 > 0, (domain, problem, self.algorithms[1], val2)
+            x = val1
+            y = val2 / float(val1)
+
+            categories[category].append((x, y))
+
+            self.ylim_top = max(self.ylim_top, y)
+            self.ylim_bottom = min(self.ylim_bottom, y)
+            self.xlim_left = min(self.xlim_left, x)
+
+        # center around 1
+        if self.ylim_bottom < 1:
+            self.ylim_top = max(self.ylim_top, 1 / float(self.ylim_bottom))
+        if self.ylim_top > 1:
+            self.ylim_bottom = min(self.ylim_bottom, 1 / float(self.ylim_top))
+        return categories
+
+    def _set_scales(self, xscale, yscale):
+        # ScatterPlot uses log-scaling on the x-axis by default.
+        PlotReport._set_scales(
+            self, xscale or self.attribute.scale or 'log', 'log')
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/experiments/issue925/v1.py fast-downward/experiments/issue925/v1.py
--- fast-downward-original/experiments/issue925/v1.py	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/experiments/issue925/v1.py	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,57 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import os
+
+from lab.environments import LocalEnvironment, BaselSlurmEnvironment
+
+import common_setup
+from common_setup import IssueConfig, IssueExperiment
+from relativescatter import RelativeScatterPlotReport
+from itertools import combinations
+
+DIR = os.path.dirname(os.path.abspath(__file__))
+BENCHMARKS_DIR = os.environ["DOWNWARD_BENCHMARKS"]
+# These revisions are all tag experimental branches off the same revision.
+# we only need different tags so lab creates separate build directories in the build cache.
+# We then manually recompile the code in the build cache with the correct settings.
+REVISIONS = ["issue925-cplex12.8-static", "issue925-cplex12.8-dynamic", "issue925-cplex12.9-static", "issue925-cplex12.9-dynamic"]
+CONFIGS = [
+    IssueConfig("opcount-seq-lmcut", ["--search", "astar(operatorcounting([state_equation_constraints(), lmcut_constraints()]))"]),
+    IssueConfig("diverse-potentials", ["--search", "astar(diverse_potentials())"]),
+    IssueConfig("optimal-lmcount", ["--search", "astar(lmcount(lm_merged([lm_rhw(),lm_hm(m=1)]), admissible=true, optimal=true))"]),
+]
+SUITE = common_setup.DEFAULT_OPTIMAL_SUITE
+ENVIRONMENT = BaselSlurmEnvironment(email="florian.pommerening@unibas.ch")
+
+if common_setup.is_test_run():
+    SUITE = IssueExperiment.DEFAULT_TEST_SUITE
+    ENVIRONMENT = LocalEnvironment(processes=4)
+
+exp = IssueExperiment(
+    revisions=REVISIONS,
+    configs=CONFIGS,
+    environment=ENVIRONMENT,
+)
+exp.add_suite(BENCHMARKS_DIR, SUITE)
+
+exp.add_parser(exp.EXITCODE_PARSER)
+exp.add_parser(exp.TRANSLATOR_PARSER)
+exp.add_parser(exp.SINGLE_SEARCH_PARSER)
+exp.add_parser(exp.PLANNER_PARSER)
+
+exp.add_step('build', exp.build)
+exp.add_step('start', exp.start_runs)
+exp.add_fetcher(name='fetch')
+
+exp.add_comparison_table_step()
+
+for r1, r2 in combinations(REVISIONS, 2):
+    for nick in ["opcount-seq-lmcut", "diverse-potentials", "optimal-lmcount"]:
+        exp.add_report(RelativeScatterPlotReport(
+            attributes=["total_time"],
+            filter_algorithm=["%s-%s" % (r, nick) for r in [r1, r2]],
+            get_category=lambda run1, run2: run1["domain"]),
+            outfile="issue925-v1-total-time-%s-%s-%s.png" % (r1, r2, nick))
+
+exp.run_steps()
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/fast-downward fast-downward/fast-downward
--- fast-downward-original/fast-downward	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/fast-downward	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,13 @@
+#!/usr/bin/env bash
+DIR=`dirname $0`
+DOMAIN=$1
+shift
+PROBLEM=$1
+shift
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(lmcut())" "$@"
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(seq())" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints()], lpsolver=CPLEX, transform=no_transform(), cache_estimates=true))" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints(), pho_constraints(), state_equation_constraints()]))" "$@"
+${DIR}/fast-downward.py --build=release $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints(), pho_constraints(), state_equation_constraints()]))" "$@"
+
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --alias seq-opt-lmcut "$@"
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/fd-constraints fast-downward/fd-constraints
--- fast-downward-original/fd-constraints	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/fd-constraints	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,14 @@
+#!/usr/bin/env bash
+DIR=`dirname $0`
+DOMAIN=$1
+shift
+PROBLEM=$1
+shift
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(lmcut())" "$@"
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(seq())" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints()], lpsolver=CPLEX, transform=no_transform(), cache_estimates=true))" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints(), pho_constraints(), state_equation_constraints()]))" "$@"
+
+# ${DIR}/builds/debug64/bin/downward --search "astar(ocsingleshot([lmcut_constraints()], lpsolver=CPLEX, transform=no_transform(), cache_estimates=true))" --internal-plan-file ${DIR}/sas_plan < output.sas
+
+${DIR}/fast-downward.py --build=release $DOMAIN $PROBLEM --search "astar(ocsingleshot([lmcut_constraints(), pho_constraints(), state_equation_constraints()],enforce_observations=false))" "$@"
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/install-osi-linux.sh fast-downward/install-osi-linux.sh
--- fast-downward-original/install-osi-linux.sh	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/install-osi-linux.sh	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,22 @@
+#!/usr/bin/env bash
+export DOWNWARD_CPLEX_ROOT=/opt/ibm/ILOG/CPLEX_Studio1210/cplex
+# You should probably change the line below to match where you want COIN64
+export DOWNWARD_COIN_ROOT=/opt/coin/Osi-0.107.9
+mkdir $DOWNWARD_COIN_ROOT
+pushd ..
+wget -c http://www.coin-or.org/download/source/Osi/Osi-0.107.9.tgz
+tar xvzf Osi-0.107.9.tgz
+cd Osi-0.107.9
+./configure CC="gcc"  CFLAGS="-m64 -pthread -Wno-long-long" \
+            CXX="g++" CXXFLAGS="-m64 -pthread -Wno-long-long" \
+            LDFLAGS="-L$DOWNWARD_CPLEX_ROOT/lib/x86-64_linux/static_pic" \
+            --without-lapack --enable-static=yes \
+            --prefix="$DOWNWARD_COIN_ROOT" \
+            --disable-zlib --disable-bzlib \
+            --with-cplex-incdir=$DOWNWARD_CPLEX_ROOT/include/ilcplex --with-cplex-lib="-lcplex -lm"
+make
+make install
+cd ..
+# rm -rf Osi-0.107.9
+# rm Osi-0.107.9.tgz
+popd
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/install-osi-mac.sh fast-downward/install-osi-mac.sh
--- fast-downward-original/install-osi-mac.sh	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/install-osi-mac.sh	2020-06-17 03:29:39.526384400 -0300
@@ -0,0 +1,26 @@
+#!/usr/bin/env bash
+# Ensure we are using the system's gcc/g++ rather than brew's
+export PATH=/usr/bin:$PATH
+pushd ..
+export DOWNWARD_CPLEX_ROOT=/Applications/CPLEX_Studio129/cplex/
+# You should probably change the line below to match where you want COIN64
+export DOWNWARD_COIN_ROOT=`pwd`/coin64
+mkdir $DOWNWARD_COIN_ROOT
+wget -c http://www.coin-or.org/download/source/Osi/Osi-0.107.9.tgz
+tar xvzf Osi-0.107.9.tgz
+cd Osi-0.107.9
+
+./configure CC="gcc"  CFLAGS="-m64 -arch x86_64 -pthread -Wno-long-long" \
+            CXX="g++" CXXFLAGS="-m64 -arch x86_64 -pthread -Wno-long-long" \
+            LDFLAGS="-L$DOWNWARD_CPLEX_ROOT/lib/x86-64_osx/static_pic -arch x86_64 -v" \
+            --without-lapack --disable-shared --enable-static=yes \
+            --prefix="$DOWNWARD_COIN_ROOT" \
+            --disable-zlib --disable-bzlib \
+            --with-cplex-incdir=$DOWNWARD_CPLEX_ROOT/include/ilcplex --with-cplex-lib="-lcplex -lm -ldl"
+
+make -j8
+make install
+cd ..
+# rm -rf Osi-0.107.9
+# rm Osi-0.107.9.tgz
+popd
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/misc/buildbot/buildbot-exp.py fast-downward/misc/buildbot/buildbot-exp.py
--- fast-downward-original/misc/buildbot/buildbot-exp.py	2020-07-09 18:54:18.641382900 -0300
+++ fast-downward/misc/buildbot/buildbot-exp.py	2020-06-17 03:29:39.526384400 -0300
@@ -60,7 +60,7 @@
 REVISION_CACHE = os.path.join(BASE_DIR, 'revision-cache')
 REGRESSIONS_DIR = os.path.join(BASE_DIR, 'regressions')
 
-BASELINE = cached_revision.get_global_rev(REPO, rev='9e8be78bb8e5')
+BASELINE = cached_revision.get_global_rev(REPO, rev='0b4344f8f5a8')
 CONFIGS = {}
 CONFIGS['nightly'] = [
     ('lmcut', ['--search', 'astar(lmcut())']),
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/misc/release/prepare-release.sh fast-downward/misc/release/prepare-release.sh
--- fast-downward-original/misc/release/prepare-release.sh	2020-07-09 18:54:18.644376000 -0300
+++ fast-downward/misc/release/prepare-release.sh	2020-06-17 03:29:39.526384400 -0300
@@ -20,9 +20,16 @@
 YEAR=${VERSION:0:2}
 MONTH=${VERSION:3:2}
 MAJOR="$YEAR.$MONTH"
+MINOR=${VERSION##$MAJOR.}
 BRANCH="release-$MAJOR"
 TAG="release-$VERSION"
 
+if [[ $MINOR = 0 ]]; then
+    PRETTY_VERSION="$MAJOR"
+else
+    PRETTY_VERSION="$VERSION"
+fi
+
 # Set directories
 SCRIPTDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
 REPODIR="$(dirname $(dirname $SCRIPTDIR))"
@@ -50,7 +57,7 @@
 function set_and_commit_version {
     LOCALVERSION=$1
     fill_template _version.tpl VERSION "$LOCALVERSION" > $REPODIR/driver/version.py
-    hg commit -m "Update version number to $LOCALVERSION"
+    hg commit -m "Update version number to $LOCALVERSION."
 }
 
 function create_recipe_and_link_latest {
@@ -65,30 +72,40 @@
 
 # Create the branch if it doesn't exist already.
 if [[ $(hg branches | grep "^$BRANCH ") ]]; then
+    if [[ $MINOR = 0 ]]; then
+        echo "The version number '$VERSION' implies that this is the first release in branch '$BRANCH' but the branch already exists."
+        exit 1
+    fi
     if [[ "$(hg branch)" != "$BRANCH" ]]; then
-      echo "The branch '$BRANCH' already exists and we are not creating an additional release on it. I don't know how to proceed."
-      exit 1
+        echo "It looks like we want to do a bugfix release, but we are not on the branch '$BRANCH'. Update to the branch head first."
+        exit 1
     fi
 else
+    if [[ $MINOR != 0 ]]; then
+        echo "The version number '$VERSION' implies a bugfix release but there is no branch '$BRANCH' yet."
+        exit 1
+    fi
     hg branch "$BRANCH"
     hg commit -m "Create branch $BRANCH."
 fi
 
 # Update version number.
-set_and_commit_version "$VERSION"
+set_and_commit_version "$PRETTY_VERSION"
 
 # Tag release.
-hg tag $TAG -m "Create release $TAG."
+hg tag $TAG -m "Create tag $TAG."
 
 # Back on the default branch, update version number.
-hg update default
-set_and_commit_version "${VERSION}+"
+if [[ $MINOR = 0 ]]; then
+    hg update default
+    set_and_commit_version "${MAJOR}+"
+fi
 
 # Create tarball.
 hg archive -r $TAG -X .hg_archival.txt -X .hgignore \
     -X .hgtags -X .uncrustify.cfg -X bitbucket-pipelines.yml \
     -X experiments/ -X misc/ --type tgz \
-    fast-downward-$VERSION.tar.gz
+    fast-downward-$PRETTY_VERSION.tar.gz
 
 # Generate the different recipe files for Docker, Singularity and Vagrant.
 pushd $DOWNWARD_CONTAINER_REPO
@@ -113,7 +130,7 @@
 cat << EOF
 Successfully prepared tag $TAG.
 Please take the following steps to verify the release:
-  * Check that fast-downward-$VERSION.tar.gz contains the correct files
+  * Check that fast-downward-$PRETTY_VERSION.tar.gz contains the correct files
   * Check that the branches and tags were created as intended
   * Check that $DOWNWARD_CONTAINER_REPO has a commit with the correct
     container recipe files.
@@ -124,6 +141,5 @@
 cd $REPODIR
 hg push
 misc/release/push-docker.sh $MAJOR
-cd $DOWNWARD_CONTAINER_REPO
-git push
+git -C $DOWNWARD_CONTAINER_REPO push
 EOF
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/misc/release/push-docker.sh fast-downward/misc/release/push-docker.sh
--- fast-downward-original/misc/release/push-docker.sh	2020-07-09 18:54:18.645373100 -0300
+++ fast-downward/misc/release/push-docker.sh	2020-06-17 03:29:39.095204200 -0300
@@ -9,7 +9,7 @@
 
 MAJOR=$1
 if [[ ! "$MAJOR" =~ ^[1-9][0-9]\.[0-9][0-9]$ ]]; then
-    echo "Unrecognized version number '$VERSION'. Expected the format YY.MM (e.g. 19.06)."
+    echo "Unrecognized version number '$MAJOR'. Expected the format YY.MM (e.g. 19.06)."
     exit 1
 fi
 
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/misc/release/templates/_Dockerfile.tpl fast-downward/misc/release/templates/_Dockerfile.tpl
--- fast-downward-original/misc/release/templates/_Dockerfile.tpl	2020-07-09 18:54:18.647365900 -0300
+++ fast-downward/misc/release/templates/_Dockerfile.tpl	2020-06-17 03:29:39.095204200 -0300
@@ -7,7 +7,6 @@
 # A first image to build the planner
 ###############################################################################
 FROM ubuntu:18.04 AS builder
-MAINTAINER Guillem FrancÃ¨s <guillem.frances at unibas>
 
 RUN apt-get update && apt-get install --no-install-recommends -y \
     cmake     \
@@ -18,13 +17,13 @@
 
 WORKDIR /workspace/downward/
 
-# Set up some environment variables
+# Set up some environment variables.
 ENV CXX g++
 
-# Download the tarball and extract everything into the workdir
+# Clone the desired tag into the current directory.
 RUN hg clone http://hg.fast-downward.org . -r TAG
 
-# Invoke the build script with default options
+# Invoke the build script with default options.
 RUN ./build.py
 RUN strip --strip-all builds/release/bin/downward
 
@@ -40,7 +39,7 @@
 
 WORKDIR /workspace/downward/
 
-# Copy the relevant files from the previous docker build into this build
+# Copy the relevant files from the previous docker build into this build.
 COPY --from=builder /workspace/downward/fast-downward.py .
 COPY --from=builder /workspace/downward/builds/release/bin/ ./builds/release/bin/
 COPY --from=builder /workspace/downward/driver ./driver
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/misc/release/templates/_Vagrantfile.tpl fast-downward/misc/release/templates/_Vagrantfile.tpl
--- fast-downward-original/misc/release/templates/_Vagrantfile.tpl	2020-07-09 18:54:18.650359700 -0300
+++ fast-downward/misc/release/templates/_Vagrantfile.tpl	2020-06-17 03:29:39.542001600 -0300
@@ -7,13 +7,8 @@
 
   config.vm.box = "ubuntu/bionic64"
 
-  # Provider-specific configuration
-  config.vm.provider "virtualbox" do |vb|
-    vb.memory = "2048"
-  end
-
   config.vm.provision "shell", inline: <<-SHELL
-    apt-get update && apt-get install --no-install-recommends -y \
+    apt update && apt install --no-install-recommends -y \
         cmake     \
         g++       \
         make      \
@@ -24,11 +19,9 @@
 
     if ! [ -e downward ] ; then
         hg clone http://hg.fast-downward.org -r TAG downward
+        ./downward/build.py
+        chown -R vagrant.vagrant downward
     fi
 
-    ./downward/build.py
-
   SHELL
-
-  config.ssh.forward_x11 = true
 end
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/misc/tests/test-memory-leaks.py fast-downward/misc/tests/test-memory-leaks.py
--- fast-downward-original/misc/tests/test-memory-leaks.py	2020-07-09 18:54:18.675291500 -0300
+++ fast-downward/misc/tests/test-memory-leaks.py	2020-06-17 03:29:39.542001600 -0300
@@ -21,6 +21,10 @@
 PLAN_FILE = os.path.join(REPO, "test.plan")
 VALGRIND_GCC5_SUPPRESSION_FILE = os.path.join(
     REPO, "misc", "tests", "valgrind", "gcc5.supp")
+DLOPEN_SUPPRESSION_FILE = os.path.join(
+    REPO, "misc", "tests", "valgrind", "dlopen.supp")
+DL_CATCH_ERROR_SUPPRESSION_FILE = os.path.join(
+    REPO, "misc", "tests", "valgrind", "dl_catch_error.supp")
 VALGRIND_ERROR_EXITCODE = 99
 
 TASKS = [os.path.join(BENCHMARKS_DIR, path) for path in [
@@ -91,7 +95,10 @@
     subprocess.check_call(["./build.py"], cwd=REPO)
     compiler, compiler_version = get_compiler_and_version()
     print("Compiler:", compiler, compiler_version)
-    suppression_files = []
+    suppression_files = [
+        DLOPEN_SUPPRESSION_FILE,
+        DL_CATCH_ERROR_SUPPRESSION_FILE,
+    ]
     if compiler == "GNU" and compiler_version.split(".")[0] == "5":
         print("Using leak suppression file for GCC 5 "
               "(see http://issues.fast-downward.org/issue703).")
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/misc/tests/valgrind/dl_catch_error.supp fast-downward/misc/tests/valgrind/dl_catch_error.supp
--- fast-downward-original/misc/tests/valgrind/dl_catch_error.supp	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/misc/tests/valgrind/dl_catch_error.supp	2020-06-17 03:29:39.542001600 -0300
@@ -0,0 +1,9 @@
+{
+   libdl bug related to _dl_catch_error
+   Memcheck:Leak
+   match-leak-kinds: reachable
+   fun:malloc
+   ...
+   fun:_dl_catch_error
+   ...
+}
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/misc/tests/valgrind/dlopen.supp fast-downward/misc/tests/valgrind/dlopen.supp
--- fast-downward-original/misc/tests/valgrind/dlopen.supp	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/misc/tests/valgrind/dlopen.supp	2020-06-17 03:29:39.542001600 -0300
@@ -0,0 +1,9 @@
+{
+   Debian libpthread dlopen bug (see https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=700899)
+   Memcheck:Leak
+   match-leak-kinds: reachable
+   fun:calloc
+   fun:_dlerror_run
+   fun:dlopen@@GLIBC_2.2.5
+   ...
+}
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/pr-domain.pddl fast-downward/pr-domain.pddl
--- fast-downward-original/pr-domain.pddl	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/pr-domain.pddl	2020-07-09 16:16:14.807886300 -0300
@@ -0,0 +1,3671 @@
+(define
+	(domain grounded-BLOCKS)
+	(:requirements :strips :action-costs)
+	(:predicates
+		( HOLDING_W )
+		( HOLDING_O )
+		( HOLDING_E )
+		( ON_W_D )
+		( ON_W_R )
+		( ON_W_O )
+		( ON_W_E )
+		( ON_O_D )
+		( ON_O_R )
+		( ON_O_W )
+		( ON_O_E )
+		( ON_E_D )
+		( ON_E_R )
+		( ON_E_W )
+		( ON_E_O )
+		( HOLDING_D )
+		( CLEAR_A )
+		( HOLDING_R )
+		( CLEAR_P )
+		( HOLDING_A )
+		( CLEAR_C )
+		( HOLDING_P )
+		( HOLDING_C )
+		( ONTABLE_D )
+		( ONTABLE_R )
+		( ONTABLE_A )
+		( ON_D_R )
+		( ON_D_W )
+		( ON_D_O )
+		( ON_D_E )
+		( ON_D_P )
+		( ON_D_C )
+		( ON_R_D )
+		( ON_R_A )
+		( ON_R_W )
+		( ON_R_O )
+		( ON_R_E )
+		( ON_R_C )
+		( ON_A_D )
+		( ON_A_R )
+		( ON_A_W )
+		( ON_A_O )
+		( ON_A_E )
+		( ON_A_P )
+		( ON_W_A )
+		( ON_W_P )
+		( ON_W_C )
+		( ON_O_A )
+		( ON_O_P )
+		( ON_O_C )
+		( ON_E_A )
+		( ON_E_P )
+		( ON_E_C )
+		( ON_P_D )
+		( ON_P_R )
+		( ON_P_A )
+		( ON_P_W )
+		( ON_P_O )
+		( ON_P_E )
+		( ON_P_C )
+		( ON_C_D )
+		( ON_C_R )
+		( ON_C_A )
+		( ON_C_W )
+		( ON_C_O )
+		( ON_C_E )
+		( ON_C_P )
+		( HANDEMPTY )
+		( CLEAR_R )
+		( CLEAR_D )
+		( CLEAR_E )
+		( CLEAR_O )
+		( CLEAR_W )
+		( ONTABLE_C )
+		( ONTABLE_P )
+		( ON_A_C )
+		( ON_R_P )
+		( ON_D_A )
+		( ONTABLE_E )
+		( ONTABLE_O )
+		( ONTABLE_W )
+		( EXPLAINED_UNSTACK_D_A_1 )
+		( EXPLAINED_STACK_D_A_1 )
+		( EXPLAINED_UNSTACK_D_A_2 )
+		( EXPLAINED_PUT-DOWN_D_1 )
+		( EXPLAINED_UNSTACK_A_C_1 )
+		( EXPLAINED_STACK_A_W_1 )
+		( EXPLAINED_UNSTACK_A_W_1 )
+		( EXPLAINED_STACK_A_W_2 )
+		( EXPLAINED_UNSTACK_R_P_1 )
+		( EXPLAINED_STACK_R_A_1 )
+		( EXPLAINED_PICK-UP_D_1 )
+		( EXPLAINED_STACK_D_R_1 )
+		( NOT_EXPLAINED_UNSTACK_D_A_1 )
+		( NOT_EXPLAINED_STACK_D_A_1 )
+		( NOT_EXPLAINED_UNSTACK_D_A_2 )
+		( NOT_EXPLAINED_PUT-DOWN_D_1 )
+		( NOT_EXPLAINED_UNSTACK_A_C_1 )
+		( NOT_EXPLAINED_STACK_A_W_1 )
+		( NOT_EXPLAINED_UNSTACK_A_W_1 )
+		( NOT_EXPLAINED_STACK_A_W_2 )
+		( NOT_EXPLAINED_UNSTACK_R_P_1 )
+		( NOT_EXPLAINED_STACK_R_A_1 )
+		( NOT_EXPLAINED_PICK-UP_D_1 )
+		( NOT_EXPLAINED_STACK_D_R_1 )
+		( EXPLAINED_FULL_OBS_SEQUENCE )
+		( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+	) 
+	(:functions (total-cost))
+	(:action EXPLAIN_OBS_UNSTACK_D_A_1
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_D )
+			( ON_D_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			( CLEAR_A )
+			 ( EXPLAINED_UNSTACK_D_A_1 )
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			(not ( ON_D_A ))
+			 (not ( NOT_EXPLAINED_UNSTACK_D_A_1 ))
+		)
+	)
+	(:action EXPLAIN_OBS_STACK_D_A_1
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_D )
+			( EXPLAINED_UNSTACK_D_A_1 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_A )
+			 ( EXPLAINED_STACK_D_A_1 )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_A ))
+			 (not ( NOT_EXPLAINED_STACK_D_A_1 ))
+		)
+	)
+	(:action STACK_D_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_D )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_A )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action EXPLAIN_OBS_UNSTACK_D_A_2
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_D )
+			( ON_D_A )
+			( EXPLAINED_STACK_D_A_1 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			( CLEAR_A )
+			 ( EXPLAINED_UNSTACK_D_A_2 )
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			(not ( ON_D_A ))
+			 (not ( NOT_EXPLAINED_UNSTACK_D_A_2 ))
+		)
+	)
+	(:action UNSTACK_D_A
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_D )
+			( ON_D_A )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			( CLEAR_A )
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			(not ( ON_D_A ))
+		)
+	)
+	(:action UNSTACK_D_A
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_D )
+			( ON_D_A )
+			( NOT_EXPLAINED_STACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			( CLEAR_A )
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			(not ( ON_D_A ))
+		)
+	)
+	(:action EXPLAIN_OBS_PUT-DOWN_D_1
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_D )
+			( EXPLAINED_UNSTACK_D_A_2 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ONTABLE_D )
+			 ( EXPLAINED_PUT-DOWN_D_1 )
+			(not ( HOLDING_D ))
+			 (not ( NOT_EXPLAINED_PUT-DOWN_D_1 ))
+		)
+	)
+	(:action PUT-DOWN_D
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_D )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ONTABLE_D )
+			(not ( HOLDING_D ))
+		)
+	)
+	(:action PUT-DOWN_D
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_D )
+			( NOT_EXPLAINED_STACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ONTABLE_D )
+			(not ( HOLDING_D ))
+		)
+	)
+	(:action PUT-DOWN_D
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_D )
+			( NOT_EXPLAINED_UNSTACK_D_A_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ONTABLE_D )
+			(not ( HOLDING_D ))
+		)
+	)
+	(:action EXPLAIN_OBS_UNSTACK_A_C_1
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_C )
+			( EXPLAINED_PUT-DOWN_D_1 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_C )
+			 ( EXPLAINED_UNSTACK_A_C_1 )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_C ))
+			 (not ( NOT_EXPLAINED_UNSTACK_A_C_1 ))
+		)
+	)
+	(:action UNSTACK_A_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_C )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_C )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_C ))
+		)
+	)
+	(:action UNSTACK_A_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_C )
+			( NOT_EXPLAINED_STACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_C )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_C ))
+		)
+	)
+	(:action UNSTACK_A_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_C )
+			( NOT_EXPLAINED_UNSTACK_D_A_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_C )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_C ))
+		)
+	)
+	(:action UNSTACK_A_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_C )
+			( NOT_EXPLAINED_PUT-DOWN_D_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_C )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_C ))
+		)
+	)
+	(:action EXPLAIN_OBS_STACK_A_W_1
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( EXPLAINED_UNSTACK_A_C_1 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			 ( EXPLAINED_STACK_A_W_1 )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+			 (not ( NOT_EXPLAINED_STACK_A_W_1 ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_STACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_UNSTACK_D_A_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_PUT-DOWN_D_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_UNSTACK_A_C_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action EXPLAIN_OBS_UNSTACK_A_W_1
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_W )
+			( EXPLAINED_STACK_A_W_1 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_W )
+			 ( EXPLAINED_UNSTACK_A_W_1 )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_W ))
+			 (not ( NOT_EXPLAINED_UNSTACK_A_W_1 ))
+		)
+	)
+	(:action UNSTACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_W )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_W )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_W ))
+		)
+	)
+	(:action UNSTACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_W )
+			( NOT_EXPLAINED_STACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_W )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_W ))
+		)
+	)
+	(:action UNSTACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_W )
+			( NOT_EXPLAINED_UNSTACK_D_A_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_W )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_W ))
+		)
+	)
+	(:action UNSTACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_W )
+			( NOT_EXPLAINED_PUT-DOWN_D_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_W )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_W ))
+		)
+	)
+	(:action UNSTACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_W )
+			( NOT_EXPLAINED_UNSTACK_A_C_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_W )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_W ))
+		)
+	)
+	(:action UNSTACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_W )
+			( NOT_EXPLAINED_STACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_W )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_W ))
+		)
+	)
+	(:action EXPLAIN_OBS_STACK_A_W_2
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( EXPLAINED_UNSTACK_A_W_1 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			 ( EXPLAINED_STACK_A_W_2 )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+			 (not ( NOT_EXPLAINED_STACK_A_W_2 ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_STACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_UNSTACK_D_A_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_PUT-DOWN_D_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_UNSTACK_A_C_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_STACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_A_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_A )
+			( NOT_EXPLAINED_UNSTACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_W )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action EXPLAIN_OBS_UNSTACK_R_P_1
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_P )
+			( EXPLAINED_STACK_A_W_2 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_P )
+			 ( EXPLAINED_UNSTACK_R_P_1 )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_P ))
+			 (not ( NOT_EXPLAINED_UNSTACK_R_P_1 ))
+		)
+	)
+	(:action UNSTACK_R_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_P )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_P )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_P ))
+		)
+	)
+	(:action UNSTACK_R_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_P )
+			( NOT_EXPLAINED_STACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_P )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_P ))
+		)
+	)
+	(:action UNSTACK_R_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_P )
+			( NOT_EXPLAINED_UNSTACK_D_A_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_P )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_P ))
+		)
+	)
+	(:action UNSTACK_R_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_P )
+			( NOT_EXPLAINED_PUT-DOWN_D_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_P )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_P ))
+		)
+	)
+	(:action UNSTACK_R_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_P )
+			( NOT_EXPLAINED_UNSTACK_A_C_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_P )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_P ))
+		)
+	)
+	(:action UNSTACK_R_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_P )
+			( NOT_EXPLAINED_STACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_P )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_P ))
+		)
+	)
+	(:action UNSTACK_R_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_P )
+			( NOT_EXPLAINED_UNSTACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_P )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_P ))
+		)
+	)
+	(:action UNSTACK_R_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_P )
+			( NOT_EXPLAINED_STACK_A_W_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_P )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_P ))
+		)
+	)
+	(:action EXPLAIN_OBS_STACK_R_A_1
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_R )
+			( EXPLAINED_UNSTACK_R_P_1 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_A )
+			 ( EXPLAINED_STACK_R_A_1 )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_A ))
+			 (not ( NOT_EXPLAINED_STACK_R_A_1 ))
+		)
+	)
+	(:action STACK_R_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_R )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_A )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_R_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_R )
+			( NOT_EXPLAINED_STACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_A )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_R_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_R )
+			( NOT_EXPLAINED_UNSTACK_D_A_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_A )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_R_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_R )
+			( NOT_EXPLAINED_PUT-DOWN_D_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_A )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_R_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_R )
+			( NOT_EXPLAINED_UNSTACK_A_C_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_A )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_R_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_R )
+			( NOT_EXPLAINED_STACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_A )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_R_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_R )
+			( NOT_EXPLAINED_UNSTACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_A )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_R_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_R )
+			( NOT_EXPLAINED_STACK_A_W_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_A )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_R_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_R )
+			( NOT_EXPLAINED_UNSTACK_R_P_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_A )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action EXPLAIN_OBS_PICK-UP_D_1
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( EXPLAINED_STACK_R_A_1 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			 ( EXPLAINED_PICK-UP_D_1 )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			 (not ( NOT_EXPLAINED_PICK-UP_D_1 ))
+		)
+	)
+	(:action PICK-UP_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( NOT_EXPLAINED_STACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( NOT_EXPLAINED_UNSTACK_D_A_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( NOT_EXPLAINED_PUT-DOWN_D_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( NOT_EXPLAINED_UNSTACK_A_C_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( NOT_EXPLAINED_STACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( NOT_EXPLAINED_UNSTACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( NOT_EXPLAINED_STACK_A_W_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( NOT_EXPLAINED_UNSTACK_R_P_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_D )
+			( CLEAR_D )
+			( NOT_EXPLAINED_STACK_R_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			(not ( ONTABLE_D ))
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action EXPLAIN_OBS_STACK_D_R_1
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( EXPLAINED_PICK-UP_D_1 )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			 ( EXPLAINED_STACK_D_R_1 )
+			 ( EXPLAINED_FULL_OBS_SEQUENCE )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+			 (not ( NOT_EXPLAINED_STACK_D_R_1 ))
+			 (not ( NOT_EXPLAINED_FULL_OBS_SEQUENCE ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_UNSTACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_STACK_D_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_UNSTACK_D_A_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_PUT-DOWN_D_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_UNSTACK_A_C_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_STACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_UNSTACK_A_W_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_STACK_A_W_2 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_UNSTACK_R_P_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_STACK_R_A_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_D )
+			( NOT_EXPLAINED_PICK-UP_D_1 )
+			( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_R )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action PICK-UP_A
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_A )
+			( CLEAR_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			(not ( ONTABLE_A ))
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_R
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_R )
+			( CLEAR_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			(not ( ONTABLE_R ))
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action UNSTACK_C_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_C )
+			( ON_C_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_C )
+			( CLEAR_P )
+			(not ( CLEAR_C ))
+			(not ( HANDEMPTY ))
+			(not ( ON_C_P ))
+		)
+	)
+	(:action UNSTACK_C_E
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_C )
+			( ON_C_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_C )
+			( CLEAR_E )
+			(not ( CLEAR_C ))
+			(not ( HANDEMPTY ))
+			(not ( ON_C_E ))
+		)
+	)
+	(:action UNSTACK_C_O
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_C )
+			( ON_C_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_C )
+			( CLEAR_O )
+			(not ( CLEAR_C ))
+			(not ( HANDEMPTY ))
+			(not ( ON_C_O ))
+		)
+	)
+	(:action UNSTACK_C_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_C )
+			( ON_C_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_C )
+			( CLEAR_W )
+			(not ( CLEAR_C ))
+			(not ( HANDEMPTY ))
+			(not ( ON_C_W ))
+		)
+	)
+	(:action UNSTACK_C_A
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_C )
+			( ON_C_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_C )
+			( CLEAR_A )
+			(not ( CLEAR_C ))
+			(not ( HANDEMPTY ))
+			(not ( ON_C_A ))
+		)
+	)
+	(:action UNSTACK_C_R
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_C )
+			( ON_C_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_C )
+			( CLEAR_R )
+			(not ( CLEAR_C ))
+			(not ( HANDEMPTY ))
+			(not ( ON_C_R ))
+		)
+	)
+	(:action UNSTACK_C_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_C )
+			( ON_C_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_C )
+			( CLEAR_D )
+			(not ( CLEAR_C ))
+			(not ( HANDEMPTY ))
+			(not ( ON_C_D ))
+		)
+	)
+	(:action UNSTACK_P_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_P )
+			( ON_P_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_P )
+			( CLEAR_C )
+			(not ( CLEAR_P ))
+			(not ( HANDEMPTY ))
+			(not ( ON_P_C ))
+		)
+	)
+	(:action UNSTACK_P_E
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_P )
+			( ON_P_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_P )
+			( CLEAR_E )
+			(not ( CLEAR_P ))
+			(not ( HANDEMPTY ))
+			(not ( ON_P_E ))
+		)
+	)
+	(:action UNSTACK_P_O
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_P )
+			( ON_P_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_P )
+			( CLEAR_O )
+			(not ( CLEAR_P ))
+			(not ( HANDEMPTY ))
+			(not ( ON_P_O ))
+		)
+	)
+	(:action UNSTACK_P_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_P )
+			( ON_P_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_P )
+			( CLEAR_W )
+			(not ( CLEAR_P ))
+			(not ( HANDEMPTY ))
+			(not ( ON_P_W ))
+		)
+	)
+	(:action UNSTACK_P_A
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_P )
+			( ON_P_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_P )
+			( CLEAR_A )
+			(not ( CLEAR_P ))
+			(not ( HANDEMPTY ))
+			(not ( ON_P_A ))
+		)
+	)
+	(:action UNSTACK_P_R
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_P )
+			( ON_P_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_P )
+			( CLEAR_R )
+			(not ( CLEAR_P ))
+			(not ( HANDEMPTY ))
+			(not ( ON_P_R ))
+		)
+	)
+	(:action UNSTACK_P_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_P )
+			( ON_P_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_P )
+			( CLEAR_D )
+			(not ( CLEAR_P ))
+			(not ( HANDEMPTY ))
+			(not ( ON_P_D ))
+		)
+	)
+	(:action UNSTACK_E_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_E )
+			( ON_E_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_E )
+			( CLEAR_C )
+			(not ( CLEAR_E ))
+			(not ( HANDEMPTY ))
+			(not ( ON_E_C ))
+		)
+	)
+	(:action UNSTACK_E_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_E )
+			( ON_E_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_E )
+			( CLEAR_P )
+			(not ( CLEAR_E ))
+			(not ( HANDEMPTY ))
+			(not ( ON_E_P ))
+		)
+	)
+	(:action UNSTACK_E_A
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_E )
+			( ON_E_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_E )
+			( CLEAR_A )
+			(not ( CLEAR_E ))
+			(not ( HANDEMPTY ))
+			(not ( ON_E_A ))
+		)
+	)
+	(:action UNSTACK_O_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_O )
+			( ON_O_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_O )
+			( CLEAR_C )
+			(not ( CLEAR_O ))
+			(not ( HANDEMPTY ))
+			(not ( ON_O_C ))
+		)
+	)
+	(:action UNSTACK_O_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_O )
+			( ON_O_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_O )
+			( CLEAR_P )
+			(not ( CLEAR_O ))
+			(not ( HANDEMPTY ))
+			(not ( ON_O_P ))
+		)
+	)
+	(:action UNSTACK_O_A
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_O )
+			( ON_O_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_O )
+			( CLEAR_A )
+			(not ( CLEAR_O ))
+			(not ( HANDEMPTY ))
+			(not ( ON_O_A ))
+		)
+	)
+	(:action UNSTACK_W_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_W )
+			( ON_W_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_W )
+			( CLEAR_C )
+			(not ( CLEAR_W ))
+			(not ( HANDEMPTY ))
+			(not ( ON_W_C ))
+		)
+	)
+	(:action UNSTACK_W_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_W )
+			( ON_W_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_W )
+			( CLEAR_P )
+			(not ( CLEAR_W ))
+			(not ( HANDEMPTY ))
+			(not ( ON_W_P ))
+		)
+	)
+	(:action UNSTACK_W_A
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_W )
+			( ON_W_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_W )
+			( CLEAR_A )
+			(not ( CLEAR_W ))
+			(not ( HANDEMPTY ))
+			(not ( ON_W_A ))
+		)
+	)
+	(:action UNSTACK_A_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_P )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_P ))
+		)
+	)
+	(:action UNSTACK_A_E
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_E )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_E ))
+		)
+	)
+	(:action UNSTACK_A_O
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_O )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_O ))
+		)
+	)
+	(:action UNSTACK_A_R
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_R )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_R ))
+		)
+	)
+	(:action UNSTACK_A_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_A )
+			( ON_A_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_A )
+			( CLEAR_D )
+			(not ( CLEAR_A ))
+			(not ( HANDEMPTY ))
+			(not ( ON_A_D ))
+		)
+	)
+	(:action UNSTACK_R_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_C )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_C ))
+		)
+	)
+	(:action UNSTACK_R_E
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_E )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_E ))
+		)
+	)
+	(:action UNSTACK_R_O
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_O )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_O ))
+		)
+	)
+	(:action UNSTACK_R_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_W )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_W ))
+		)
+	)
+	(:action UNSTACK_R_A
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_A )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_A ))
+		)
+	)
+	(:action UNSTACK_R_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_R )
+			( ON_R_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_R )
+			( CLEAR_D )
+			(not ( CLEAR_R ))
+			(not ( HANDEMPTY ))
+			(not ( ON_R_D ))
+		)
+	)
+	(:action UNSTACK_D_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_D )
+			( ON_D_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			( CLEAR_C )
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			(not ( ON_D_C ))
+		)
+	)
+	(:action UNSTACK_D_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_D )
+			( ON_D_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			( CLEAR_P )
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			(not ( ON_D_P ))
+		)
+	)
+	(:action UNSTACK_D_E
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_D )
+			( ON_D_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			( CLEAR_E )
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			(not ( ON_D_E ))
+		)
+	)
+	(:action UNSTACK_D_O
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_D )
+			( ON_D_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			( CLEAR_O )
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			(not ( ON_D_O ))
+		)
+	)
+	(:action UNSTACK_D_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_D )
+			( ON_D_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			( CLEAR_W )
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			(not ( ON_D_W ))
+		)
+	)
+	(:action UNSTACK_D_R
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_D )
+			( ON_D_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_D )
+			( CLEAR_R )
+			(not ( CLEAR_D ))
+			(not ( HANDEMPTY ))
+			(not ( ON_D_R ))
+		)
+	)
+	(:action STACK_C_P
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_P )
+			( HOLDING_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_C )
+			( HANDEMPTY )
+			( ON_C_P )
+			(not ( HOLDING_C ))
+			(not ( CLEAR_P ))
+		)
+	)
+	(:action STACK_C_E
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_E )
+			( HOLDING_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_C )
+			( HANDEMPTY )
+			( ON_C_E )
+			(not ( HOLDING_C ))
+			(not ( CLEAR_E ))
+		)
+	)
+	(:action STACK_C_O
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_O )
+			( HOLDING_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_C )
+			( HANDEMPTY )
+			( ON_C_O )
+			(not ( HOLDING_C ))
+			(not ( CLEAR_O ))
+		)
+	)
+	(:action STACK_C_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_C )
+			( HANDEMPTY )
+			( ON_C_W )
+			(not ( HOLDING_C ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_C_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_C )
+			( HANDEMPTY )
+			( ON_C_A )
+			(not ( HOLDING_C ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_C_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_C )
+			( HANDEMPTY )
+			( ON_C_R )
+			(not ( HOLDING_C ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_C_D
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_D )
+			( HOLDING_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_C )
+			( HANDEMPTY )
+			( ON_C_D )
+			(not ( HOLDING_C ))
+			(not ( CLEAR_D ))
+		)
+	)
+	(:action STACK_P_C
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_C )
+			( HOLDING_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_P )
+			( HANDEMPTY )
+			( ON_P_C )
+			(not ( HOLDING_P ))
+			(not ( CLEAR_C ))
+		)
+	)
+	(:action STACK_P_E
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_E )
+			( HOLDING_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_P )
+			( HANDEMPTY )
+			( ON_P_E )
+			(not ( HOLDING_P ))
+			(not ( CLEAR_E ))
+		)
+	)
+	(:action STACK_P_O
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_O )
+			( HOLDING_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_P )
+			( HANDEMPTY )
+			( ON_P_O )
+			(not ( HOLDING_P ))
+			(not ( CLEAR_O ))
+		)
+	)
+	(:action STACK_P_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_P )
+			( HANDEMPTY )
+			( ON_P_W )
+			(not ( HOLDING_P ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_P_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_P )
+			( HANDEMPTY )
+			( ON_P_A )
+			(not ( HOLDING_P ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_P_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_P )
+			( HANDEMPTY )
+			( ON_P_R )
+			(not ( HOLDING_P ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_P_D
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_D )
+			( HOLDING_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_P )
+			( HANDEMPTY )
+			( ON_P_D )
+			(not ( HOLDING_P ))
+			(not ( CLEAR_D ))
+		)
+	)
+	(:action STACK_E_C
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_C )
+			( HOLDING_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_E )
+			( HANDEMPTY )
+			( ON_E_C )
+			(not ( HOLDING_E ))
+			(not ( CLEAR_C ))
+		)
+	)
+	(:action STACK_E_P
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_P )
+			( HOLDING_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_E )
+			( HANDEMPTY )
+			( ON_E_P )
+			(not ( HOLDING_E ))
+			(not ( CLEAR_P ))
+		)
+	)
+	(:action STACK_E_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_E )
+			( HANDEMPTY )
+			( ON_E_A )
+			(not ( HOLDING_E ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_O_C
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_C )
+			( HOLDING_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_O )
+			( HANDEMPTY )
+			( ON_O_C )
+			(not ( HOLDING_O ))
+			(not ( CLEAR_C ))
+		)
+	)
+	(:action STACK_O_P
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_P )
+			( HOLDING_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_O )
+			( HANDEMPTY )
+			( ON_O_P )
+			(not ( HOLDING_O ))
+			(not ( CLEAR_P ))
+		)
+	)
+	(:action STACK_O_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_O )
+			( HANDEMPTY )
+			( ON_O_A )
+			(not ( HOLDING_O ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_W_C
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_C )
+			( HOLDING_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_W )
+			( HANDEMPTY )
+			( ON_W_C )
+			(not ( HOLDING_W ))
+			(not ( CLEAR_C ))
+		)
+	)
+	(:action STACK_W_P
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_P )
+			( HOLDING_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_W )
+			( HANDEMPTY )
+			( ON_W_P )
+			(not ( HOLDING_W ))
+			(not ( CLEAR_P ))
+		)
+	)
+	(:action STACK_W_A
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_A )
+			( HOLDING_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_W )
+			( HANDEMPTY )
+			( ON_W_A )
+			(not ( HOLDING_W ))
+			(not ( CLEAR_A ))
+		)
+	)
+	(:action STACK_A_C
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_C )
+			( HOLDING_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_C )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_C ))
+		)
+	)
+	(:action STACK_A_P
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_P )
+			( HOLDING_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_P )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_P ))
+		)
+	)
+	(:action STACK_A_E
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_E )
+			( HOLDING_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_E )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_E ))
+		)
+	)
+	(:action STACK_A_O
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_O )
+			( HOLDING_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_O )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_O ))
+		)
+	)
+	(:action STACK_A_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_R )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_A_D
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_D )
+			( HOLDING_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ON_A_D )
+			(not ( HOLDING_A ))
+			(not ( CLEAR_D ))
+		)
+	)
+	(:action STACK_R_C
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_C )
+			( HOLDING_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_C )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_C ))
+		)
+	)
+	(:action STACK_R_P
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_P )
+			( HOLDING_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_P )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_P ))
+		)
+	)
+	(:action STACK_R_E
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_E )
+			( HOLDING_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_E )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_E ))
+		)
+	)
+	(:action STACK_R_O
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_O )
+			( HOLDING_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_O )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_O ))
+		)
+	)
+	(:action STACK_R_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_W )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_R_D
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_D )
+			( HOLDING_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ON_R_D )
+			(not ( HOLDING_R ))
+			(not ( CLEAR_D ))
+		)
+	)
+	(:action STACK_D_C
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_C )
+			( HOLDING_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_C )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_C ))
+		)
+	)
+	(:action STACK_D_P
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_P )
+			( HOLDING_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_P )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_P ))
+		)
+	)
+	(:action STACK_D_E
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_E )
+			( HOLDING_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_E )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_E ))
+		)
+	)
+	(:action STACK_D_O
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_O )
+			( HOLDING_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_O )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_O ))
+		)
+	)
+	(:action STACK_D_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_D )
+			( HANDEMPTY )
+			( ON_D_W )
+			(not ( HOLDING_D ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action PUT-DOWN_C
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_C )
+			( HANDEMPTY )
+			( ONTABLE_C )
+			(not ( HOLDING_C ))
+		)
+	)
+	(:action PUT-DOWN_P
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_P )
+			( HANDEMPTY )
+			( ONTABLE_P )
+			(not ( HOLDING_P ))
+		)
+	)
+	(:action PUT-DOWN_A
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_A )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_A )
+			( HANDEMPTY )
+			( ONTABLE_A )
+			(not ( HOLDING_A ))
+		)
+	)
+	(:action PUT-DOWN_R
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_R )
+			( HANDEMPTY )
+			( ONTABLE_R )
+			(not ( HOLDING_R ))
+		)
+	)
+	(:action PICK-UP_C
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_C )
+			( CLEAR_C )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_C )
+			(not ( ONTABLE_C ))
+			(not ( CLEAR_C ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_P
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_P )
+			( CLEAR_P )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_P )
+			(not ( ONTABLE_P ))
+			(not ( CLEAR_P ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action UNSTACK_E_O
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_E )
+			( ON_E_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_E )
+			( CLEAR_O )
+			(not ( CLEAR_E ))
+			(not ( HANDEMPTY ))
+			(not ( ON_E_O ))
+		)
+	)
+	(:action UNSTACK_E_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_E )
+			( ON_E_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_E )
+			( CLEAR_W )
+			(not ( CLEAR_E ))
+			(not ( HANDEMPTY ))
+			(not ( ON_E_W ))
+		)
+	)
+	(:action UNSTACK_E_R
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_E )
+			( ON_E_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_E )
+			( CLEAR_R )
+			(not ( CLEAR_E ))
+			(not ( HANDEMPTY ))
+			(not ( ON_E_R ))
+		)
+	)
+	(:action UNSTACK_E_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_E )
+			( ON_E_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_E )
+			( CLEAR_D )
+			(not ( CLEAR_E ))
+			(not ( HANDEMPTY ))
+			(not ( ON_E_D ))
+		)
+	)
+	(:action UNSTACK_O_E
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_O )
+			( ON_O_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_O )
+			( CLEAR_E )
+			(not ( CLEAR_O ))
+			(not ( HANDEMPTY ))
+			(not ( ON_O_E ))
+		)
+	)
+	(:action UNSTACK_O_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_O )
+			( ON_O_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_O )
+			( CLEAR_W )
+			(not ( CLEAR_O ))
+			(not ( HANDEMPTY ))
+			(not ( ON_O_W ))
+		)
+	)
+	(:action UNSTACK_O_R
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_O )
+			( ON_O_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_O )
+			( CLEAR_R )
+			(not ( CLEAR_O ))
+			(not ( HANDEMPTY ))
+			(not ( ON_O_R ))
+		)
+	)
+	(:action UNSTACK_O_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_O )
+			( ON_O_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_O )
+			( CLEAR_D )
+			(not ( CLEAR_O ))
+			(not ( HANDEMPTY ))
+			(not ( ON_O_D ))
+		)
+	)
+	(:action UNSTACK_W_E
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_W )
+			( ON_W_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_W )
+			( CLEAR_E )
+			(not ( CLEAR_W ))
+			(not ( HANDEMPTY ))
+			(not ( ON_W_E ))
+		)
+	)
+	(:action UNSTACK_W_O
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_W )
+			( ON_W_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_W )
+			( CLEAR_O )
+			(not ( CLEAR_W ))
+			(not ( HANDEMPTY ))
+			(not ( ON_W_O ))
+		)
+	)
+	(:action UNSTACK_W_R
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_W )
+			( ON_W_R )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_W )
+			( CLEAR_R )
+			(not ( CLEAR_W ))
+			(not ( HANDEMPTY ))
+			(not ( ON_W_R ))
+		)
+	)
+	(:action UNSTACK_W_D
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( CLEAR_W )
+			( ON_W_D )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_W )
+			( CLEAR_D )
+			(not ( CLEAR_W ))
+			(not ( HANDEMPTY ))
+			(not ( ON_W_D ))
+		)
+	)
+	(:action STACK_E_O
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_O )
+			( HOLDING_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_E )
+			( HANDEMPTY )
+			( ON_E_O )
+			(not ( HOLDING_E ))
+			(not ( CLEAR_O ))
+		)
+	)
+	(:action STACK_E_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_E )
+			( HANDEMPTY )
+			( ON_E_W )
+			(not ( HOLDING_E ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_E_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_E )
+			( HANDEMPTY )
+			( ON_E_R )
+			(not ( HOLDING_E ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_E_D
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_D )
+			( HOLDING_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_E )
+			( HANDEMPTY )
+			( ON_E_D )
+			(not ( HOLDING_E ))
+			(not ( CLEAR_D ))
+		)
+	)
+	(:action STACK_O_E
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_E )
+			( HOLDING_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_O )
+			( HANDEMPTY )
+			( ON_O_E )
+			(not ( HOLDING_O ))
+			(not ( CLEAR_E ))
+		)
+	)
+	(:action STACK_O_W
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_W )
+			( HOLDING_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_O )
+			( HANDEMPTY )
+			( ON_O_W )
+			(not ( HOLDING_O ))
+			(not ( CLEAR_W ))
+		)
+	)
+	(:action STACK_O_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_O )
+			( HANDEMPTY )
+			( ON_O_R )
+			(not ( HOLDING_O ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_O_D
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_D )
+			( HOLDING_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_O )
+			( HANDEMPTY )
+			( ON_O_D )
+			(not ( HOLDING_O ))
+			(not ( CLEAR_D ))
+		)
+	)
+	(:action STACK_W_E
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_E )
+			( HOLDING_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_W )
+			( HANDEMPTY )
+			( ON_W_E )
+			(not ( HOLDING_W ))
+			(not ( CLEAR_E ))
+		)
+	)
+	(:action STACK_W_O
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_O )
+			( HOLDING_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_W )
+			( HANDEMPTY )
+			( ON_W_O )
+			(not ( HOLDING_W ))
+			(not ( CLEAR_O ))
+		)
+	)
+	(:action STACK_W_R
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_R )
+			( HOLDING_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_W )
+			( HANDEMPTY )
+			( ON_W_R )
+			(not ( HOLDING_W ))
+			(not ( CLEAR_R ))
+		)
+	)
+	(:action STACK_W_D
+		:parameters ()
+		:precondition
+		(and
+			( CLEAR_D )
+			( HOLDING_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_W )
+			( HANDEMPTY )
+			( ON_W_D )
+			(not ( HOLDING_W ))
+			(not ( CLEAR_D ))
+		)
+	)
+	(:action PUT-DOWN_E
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_E )
+			( HANDEMPTY )
+			( ONTABLE_E )
+			(not ( HOLDING_E ))
+		)
+	)
+	(:action PUT-DOWN_O
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_O )
+			( HANDEMPTY )
+			( ONTABLE_O )
+			(not ( HOLDING_O ))
+		)
+	)
+	(:action PUT-DOWN_W
+		:parameters ()
+		:precondition
+		(and
+			( HOLDING_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( CLEAR_W )
+			( HANDEMPTY )
+			( ONTABLE_W )
+			(not ( HOLDING_W ))
+		)
+	)
+	(:action PICK-UP_E
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_E )
+			( CLEAR_E )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_E )
+			(not ( ONTABLE_E ))
+			(not ( CLEAR_E ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_O
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_O )
+			( CLEAR_O )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_O )
+			(not ( ONTABLE_O ))
+			(not ( CLEAR_O ))
+			(not ( HANDEMPTY ))
+		)
+	)
+	(:action PICK-UP_W
+		:parameters ()
+		:precondition
+		(and
+			( HANDEMPTY )
+			( ONTABLE_W )
+			( CLEAR_W )
+		)
+		:effect
+		(and
+			(increase (total-cost) 1)
+			( HOLDING_W )
+			(not ( ONTABLE_W ))
+			(not ( CLEAR_W ))
+			(not ( HANDEMPTY ))
+		)
+	)
+
+)
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/pr-problem.pddl fast-downward/pr-problem.pddl
--- fast-downward-original/pr-problem.pddl	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/pr-problem.pddl	2020-07-09 16:16:14.809848200 -0300
@@ -0,0 +1,46 @@
+(define
+	(problem grounded-BLOCKS_WORDS)
+	(:domain grounded-BLOCKS)
+	(:init
+		(= (total-cost) 0)
+		( ONTABLE_W )
+		( CLEAR_W )
+		( ONTABLE_C )
+		( ON_A_C )
+		( ON_D_A )
+		( CLEAR_D )
+		( ONTABLE_E )
+		( CLEAR_E )
+		( ONTABLE_P )
+		( ON_R_P )
+		( CLEAR_R )
+		( ONTABLE_O )
+		( CLEAR_O )
+		( HANDEMPTY )
+		( NOT_EXPLAINED_UNSTACK_D_A_1 )
+		( NOT_EXPLAINED_STACK_D_A_1 )
+		( NOT_EXPLAINED_UNSTACK_D_A_2 )
+		( NOT_EXPLAINED_PUT-DOWN_D_1 )
+		( NOT_EXPLAINED_UNSTACK_A_C_1 )
+		( NOT_EXPLAINED_STACK_A_W_1 )
+		( NOT_EXPLAINED_UNSTACK_A_W_1 )
+		( NOT_EXPLAINED_STACK_A_W_2 )
+		( NOT_EXPLAINED_UNSTACK_R_P_1 )
+		( NOT_EXPLAINED_STACK_R_A_1 )
+		( NOT_EXPLAINED_PICK-UP_D_1 )
+		( NOT_EXPLAINED_STACK_D_R_1 )
+		( NOT_EXPLAINED_FULL_OBS_SEQUENCE )
+	)
+	(:goal
+		(and 
+		( ON_A_W )
+		( ON_R_A )
+		( ON_D_R )
+		( ONTABLE_W )
+		( CLEAR_D )
+		( EXPLAINED_FULL_OBS_SEQUENCE )
+		)
+	)
+	(:metric minimize (total-cost))
+
+)
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/cmake_modules/FindCplex.cmake fast-downward/src/cmake_modules/FindCplex.cmake
--- fast-downward-original/src/cmake_modules/FindCplex.cmake	2020-07-09 18:54:18.683271500 -0300
+++ fast-downward/src/cmake_modules/FindCplex.cmake	2020-06-17 03:29:39.542001600 -0300
@@ -106,24 +106,30 @@
     )
 endif()
 
+# CMake uses the first discovered library, searching in the order they
+# are mentioned here. We prefer dynamic libraries over static ones
+# (see issue925) and otherwise prefer the latest available version.
 find_library(CPLEX_LIBRARY_RELEASE
     NAMES
-    cplex
-    cplex1262
-    cplex1271
+    cplex1290
     cplex1280
+    cplex1271
+    cplex1262
+    cplex
     HINTS
     ${CPLEX_HINT_PATHS_RELEASE}
     PATH_SUFFIXES
     ${CPLEX_LIBRARY_PATH_SUFFIX_RELEASE}
 )
 
+# See above.
 find_library(CPLEX_LIBRARY_DEBUG
     NAMES
-    cplex
-    cplex1262
-    cplex1271
+    cplex1290
     cplex1280
+    cplex1271
+    cplex1262
+    cplex
     HINTS
     ${CPLEX_HINT_PATHS_DEBUG}
     PATH_SUFFIXES
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/cmake_modules/FindOSI.cmake fast-downward/src/cmake_modules/FindOSI.cmake
--- fast-downward-original/src/cmake_modules/FindOSI.cmake	2020-07-09 18:54:18.684268400 -0300
+++ fast-downward/src/cmake_modules/FindOSI.cmake	2020-06-17 03:29:39.542001600 -0300
@@ -6,6 +6,7 @@
 #  Clp (internal solver of COIN)
 #  Cpx (CPLEX)
 #  Grb (Gurobi)
+#  Spx (SoPlex)
 #
 # This code defines the following variables:
 #
@@ -124,6 +125,16 @@
     set(OSI_Grb_FOUND FALSE)
 endif()
 
+# Spx component
+if(OSI_Spx_LIBRARIES)
+    find_package(Soplex)
+    if (SOPLEX_FOUND)
+        list(APPEND OSI_Spx_LIBRARIES ${SOPLEX_LIBRARIES})
+        list(APPEND OSI_Spx_INCLUDE_DIRS ${SOPLEX_INCLUDE_DIRS})
+        set(OSI_Spx_FOUND TRUE)
+    endif()
+endif()
+
 
 # Check for consistency and handle arguments like QUIET, REQUIRED, etc.
 include(FindPackageHandleStandardArgs)
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/cmake_modules/FindSoplex.cmake fast-downward/src/cmake_modules/FindSoplex.cmake
--- fast-downward-original/src/cmake_modules/FindSoplex.cmake	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/cmake_modules/FindSoplex.cmake	2020-06-17 03:29:39.542001600 -0300
@@ -0,0 +1,78 @@
+# - Find the SoPlex LP solver.
+# This code defines the following variables:
+#
+#  SOPLEX_FOUND                 - TRUE if SOPLEX was found.
+#  SOPLEX_INCLUDE_DIRS          - Full paths to all include dirs.
+#  SOPLEX_LIBRARIES             - Full paths to all libraries.
+#
+# Usage:
+#  find_package(soplex)
+#
+# The location of SoPlex can be specified using the environment variable
+# or cmake parameter DOWNWARD_SOPLEX_ROOT. If different installations
+# for release/debug versions of SOPLEX are available, they can be
+# specified with
+#   DOWNWARD_SOPLEX_ROOT
+#   DOWNWARD_SOPLEX_ROOT_RELEASE
+#   DOWNWARD_SOPLEX_ROOT_DEBUG
+# More specific paths are preferred over less specific ones when searching
+# for libraries.
+#
+# Note that the standard FIND_PACKAGE features are supported
+# (QUIET, REQUIRED, etc.).
+
+foreach(BUILDMODE "RELEASE" "DEBUG")
+    set(SOPLEX_HINT_PATHS_${BUILDMODE}
+        ${DOWNWARD_SOPLEX_ROOT_${BUILDMODE}}
+        $ENV{DOWNWARD_SOPLEX_ROOT_${BUILDMODE}}
+        ${DOWNWARD_SOPLEX_ROOT}
+        $ENV{DOWNWARD_SOPLEX_ROOT}
+    )
+endforeach()
+
+find_path(SOPLEX_INCLUDE_DIRS
+    NAMES
+    soplex.h
+    HINTS
+    ${SOPLEX_HINT_PATHS_RELEASE}
+    ${SOPLEX_HINT_PATHS_DEBUG}
+    PATH_SUFFIXES
+    include
+)
+
+find_library(SOPLEX_LIBRARY_RELEASE
+    NAMES
+    soplex
+    HINTS
+    ${SOPLEX_HINT_PATHS_RELEASE}
+    PATH_SUFFIXES
+    lib
+)
+
+find_library(SOPLEX_LIBRARY_DEBUG
+    NAMES
+    soplex
+    HINTS
+    ${SOPLEX_HINT_PATHS_DEBUG}
+    PATH_SUFFIXES
+    lib
+)
+
+if(SOPLEX_LIBRARY_RELEASE OR SOPLEX_LIBRARY_DEBUG)
+    set(SOPLEX_LIBRARIES
+        optimized ${SOPLEX_LIBRARY_RELEASE}
+        debug ${SOPLEX_LIBRARY_DEBUG}
+    )
+endif()
+
+# Check if everything was found and set SOPLEX_FOUND.
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(
+    soplex
+    REQUIRED_VARS SOPLEX_INCLUDE_DIRS SOPLEX_LIBRARIES
+)
+
+mark_as_advanced(
+    SOPLEX_INCLUDE_DIRS SOPLEX_LIBRARIES
+    SOPLEX_LIBRARY_RELEASE SOPLEX_LIBRARY_DEBUG
+)
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/CMakeLists.txt fast-downward/src/search/CMakeLists.txt
--- fast-downward-original/src/search/CMakeLists.txt	2020-07-09 18:54:18.686263700 -0300
+++ fast-downward/src/search/CMakeLists.txt	2020-06-17 03:29:39.542001600 -0300
@@ -46,9 +46,9 @@
   TRUE)
 
 if(PLUGIN_LP_SOLVER_ENABLED AND USE_LP)
-    find_package(OSI OPTIONAL_COMPONENTS Cpx Clp Grb)
-    if(OSI_FOUND AND (OSI_Cpx_FOUND OR OSI_Clp_FOUND OR OSI_Grb_FOUND))
-        foreach(SOLVER Cpx Clp Grb)
+    find_package(OSI OPTIONAL_COMPONENTS Cpx Clp Grb Spx)
+    if(OSI_FOUND AND (OSI_Cpx_FOUND OR OSI_Clp_FOUND OR OSI_Grb_FOUND OR OSI_Spx_FOUND))
+        foreach(SOLVER Cpx Clp Grb Spx)
             if(OSI_${SOLVER}_FOUND)
                 string(TOUPPER ${SOLVER} TMP_SOLVER_UPPER_CASE)
                 mark_as_advanced(TMP_SOLVER_UPPER_CASE)
@@ -62,6 +62,12 @@
         add_definitions("-D USE_LP")
         include_directories(${OSI_INCLUDE_DIRS})
         target_link_libraries(downward ${OSI_LIBRARIES})
+
+        find_package(ZLIB REQUIRED)
+        if(ZLIB_FOUND)
+            include_directories(${ZLIB_INCLUDE_DIRS})
+            target_link_libraries(downward ${ZLIB_LIBRARIES})
+        endif()
     endif()
 
     if(OSI_Cpx_FOUND AND CPLEX_RUNTIME_LIBRARY)
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/DownwardFiles.cmake fast-downward/src/search/DownwardFiles.cmake
--- fast-downward-original/src/search/DownwardFiles.cmake	2020-07-09 18:54:18.688258200 -0300
+++ fast-downward/src/search/DownwardFiles.cmake	2020-06-17 03:29:39.542001600 -0300
@@ -699,6 +699,18 @@
 )
 
 fast_downward_plugin(
+    NAME OC_SINGLESHOT
+    HELP "Plugin containing the code for operator counting single shot"
+    SOURCES
+        operator_counting/constraint_generator
+        operator_counting/lm_cut_constraints
+        operator_counting/oc_single_shot_heuristic
+        operator_counting/pho_constraints
+        operator_counting/state_equation_constraints
+    DEPENDS LP_SOLVER LANDMARK_CUT_HEURISTIC PDBS TASK_PROPERTIES
+)
+
+fast_downward_plugin(
     NAME PDBS
     HELP "Plugin containing the code for PDBs"
     SOURCES
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/ext/tree.hh fast-downward/src/search/ext/tree.hh
--- fast-downward-original/src/search/ext/tree.hh	2020-07-09 18:54:18.719176300 -0300
+++ fast-downward/src/search/ext/tree.hh	2020-06-17 03:29:39.163024100 -0300
@@ -212,6 +212,7 @@
 				sibling_iterator(const sibling_iterator&);
 				sibling_iterator(const iterator_base&);
 
+				sibling_iterator& operator=(const sibling_iterator&) = default;
 				bool    operator==(const sibling_iterator&) const;
 				bool    operator!=(const sibling_iterator&) const;
 				sibling_iterator&  operator++();
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/heuristics/goal_count_heuristic.cc fast-downward/src/search/heuristics/goal_count_heuristic.cc
--- fast-downward-original/src/search/heuristics/goal_count_heuristic.cc	2020-07-09 18:54:18.733138400 -0300
+++ fast-downward/src/search/heuristics/goal_count_heuristic.cc	2020-06-17 03:29:39.542001600 -0300
@@ -12,9 +12,6 @@
     cout << "Initializing goal count heuristic..." << endl;
 }
 
-GoalCountHeuristic::~GoalCountHeuristic() {
-}
-
 int GoalCountHeuristic::compute_heuristic(const GlobalState &global_state) {
     const State state = convert_global_state(global_state);
     int unsatisfied_goal_count = 0;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/heuristics/goal_count_heuristic.h fast-downward/src/search/heuristics/goal_count_heuristic.h
--- fast-downward-original/src/search/heuristics/goal_count_heuristic.h	2020-07-09 18:54:18.735133300 -0300
+++ fast-downward/src/search/heuristics/goal_count_heuristic.h	2020-06-17 03:29:39.542001600 -0300
@@ -6,10 +6,9 @@
 namespace goal_count_heuristic {
 class GoalCountHeuristic : public Heuristic {
 protected:
-    virtual int compute_heuristic(const GlobalState &global_state);
+    virtual int compute_heuristic(const GlobalState &global_state) override;
 public:
-    GoalCountHeuristic(const options::Options &opts);
-    ~GoalCountHeuristic();
+    explicit GoalCountHeuristic(const options::Options &opts);
 };
 }
 
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/lp/lp_internals.cc fast-downward/src/search/lp/lp_internals.cc
--- fast-downward-original/src/search/lp/lp_internals.cc	2020-07-09 18:54:18.768045400 -0300
+++ fast-downward/src/search/lp/lp_internals.cc	2020-06-17 03:29:39.542001600 -0300
@@ -33,6 +33,11 @@
 #include <OsiGrbSolverInterface.hpp>
 #endif
 
+#ifdef COIN_HAS_SPX
+#include <OsiSpxSolverInterface.hpp>
+#include <spxout.h>
+#endif
+
 #ifdef __GNUG__
 #pragma GCC diagnostic pop
 #endif
@@ -116,6 +121,17 @@
         missing_symbol = "COIN_HAS_GRB";
 #endif
         break;
+    case LPSolverType::SOPLEX:
+#ifdef COIN_HAS_SPX
+        {
+            OsiSpxSolverInterface *spx_solver = new OsiSpxSolverInterface;
+            spx_solver->getSPxOut()->setVerbosity(soplex::SPxOut::ERROR);
+            lp_solver = spx_solver;
+        }
+#else
+        missing_symbol = "COIN_HAS_SPX";
+#endif
+        break;
     default:
         ABORT("Unknown LP solver type.");
     }
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/lp/lp_solver.cc fast-downward/src/search/lp/lp_solver.cc
--- fast-downward-original/src/search/lp/lp_solver.cc	2020-07-09 18:54:18.770040000 -0300
+++ fast-downward/src/search/lp/lp_solver.cc	2020-06-17 03:29:39.542001600 -0300
@@ -39,6 +39,8 @@
     lp_solvers_doc.push_back("commercial solver by IBM");
     lp_solvers.push_back("GUROBI");
     lp_solvers_doc.push_back("commercial solver");
+    lp_solvers.push_back("SOPLEX");
+    lp_solvers_doc.push_back("open source solver by ZIB");
     parser.add_enum_option(
         "lpsolver",
         lp_solvers,
@@ -115,12 +117,6 @@
         row_ub.push_back(constraint.get_upper_bound());
     }
 
-    if (sense == LPObjectiveSense::MINIMIZE) {
-        lp_solver->setObjSense(1);
-    } else {
-        lp_solver->setObjSense(-1);
-    }
-
     for (const LPConstraint &constraint : constraints) {
         const vector<int> &vars = constraint.get_variables();
         const vector<double> &coeffs = constraint.get_coefficients();
@@ -156,6 +152,16 @@
                                objective.data(),
                                row_lb.data(),
                                row_ub.data());
+        /*
+          We set the objective sense after loading because the SoPlex
+          interfaces of all OSI versions <= 0.108.4 ignore it when it is
+          set earlier. See issue752 for details.
+        */
+        if (sense == LPObjectiveSense::MINIMIZE) {
+            lp_solver->setObjSense(1);
+        } else {
+            lp_solver->setObjSense(-1);
+        }
     } catch (CoinError &error) {
         handle_coin_error(error);
     }
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/lp/lp_solver.h fast-downward/src/search/lp/lp_solver.h
--- fast-downward-original/src/search/lp/lp_solver.h	2020-07-09 18:54:18.772034100 -0300
+++ fast-downward/src/search/lp/lp_solver.h	2020-06-17 03:29:39.557635300 -0300
@@ -32,7 +32,7 @@
 
 namespace lp {
 enum class LPSolverType {
-    CLP, CPLEX, GUROBI
+    CLP, CPLEX, GUROBI, SOPLEX
 };
 
 enum class LPObjectiveSense {
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/distances.cc fast-downward/src/search/merge_and_shrink/distances.cc
--- fast-downward-original/src/search/merge_and_shrink/distances.cc	2020-07-09 18:54:18.774027500 -0300
+++ fast-downward/src/search/merge_and_shrink/distances.cc	2020-06-17 03:29:39.169008500 -0300
@@ -4,6 +4,7 @@
 #include "transition_system.h"
 
 #include "../algorithms/priority_queues.h"
+#include "../utils/logging.h"
 
 #include <cassert>
 #include <deque>
@@ -168,7 +169,7 @@
 void Distances::compute_distances(
     bool compute_init_distances,
     bool compute_goal_distances,
-    Verbosity verbosity) {
+    utils::Verbosity verbosity) {
     assert(compute_init_distances || compute_goal_distances);
     /*
       This method does the following:
@@ -197,13 +198,13 @@
         assert(init_distances.empty() && goal_distances.empty());
     }
 
-    if (verbosity >= Verbosity::VERBOSE) {
+    if (verbosity >= utils::Verbosity::VERBOSE) {
         cout << transition_system.tag();
     }
 
     int num_states = get_num_states();
     if (num_states == 0) {
-        if (verbosity >= Verbosity::VERBOSE) {
+        if (verbosity >= utils::Verbosity::VERBOSE) {
             cout << "empty transition system, no distances to compute" << endl;
         }
         init_distances_computed = true;
@@ -217,7 +218,7 @@
     if (compute_goal_distances) {
         goal_distances.resize(num_states, INF);
     }
-    if (verbosity >= Verbosity::VERBOSE) {
+    if (verbosity >= utils::Verbosity::VERBOSE) {
         cout << "computing ";
         if (compute_init_distances && compute_goal_distances) {
             cout << "init and goal";
@@ -229,7 +230,7 @@
         cout << " distances using ";
     }
     if (is_unit_cost()) {
-        if (verbosity >= Verbosity::VERBOSE) {
+        if (verbosity >= utils::Verbosity::VERBOSE) {
             cout << "unit-cost";
         }
         if (compute_init_distances) {
@@ -239,7 +240,7 @@
             compute_goal_distances_unit_cost();
         }
     } else {
-        if (verbosity >= Verbosity::VERBOSE) {
+        if (verbosity >= utils::Verbosity::VERBOSE) {
             cout << "general-cost";
         }
         if (compute_init_distances) {
@@ -249,7 +250,7 @@
             compute_goal_distances_general_cost();
         }
     }
-    if (verbosity >= Verbosity::VERBOSE) {
+    if (verbosity >= utils::Verbosity::VERBOSE) {
         cout << " algorithm" << endl;
     }
 
@@ -265,7 +266,7 @@
     const StateEquivalenceRelation &state_equivalence_relation,
     bool compute_init_distances,
     bool compute_goal_distances,
-    Verbosity verbosity) {
+    utils::Verbosity verbosity) {
     if (compute_init_distances) {
         assert(are_init_distances_computed());
         assert(state_equivalence_relation.size() < init_distances.size());
@@ -325,7 +326,7 @@
     }
 
     if (must_recompute) {
-        if (verbosity >= Verbosity::VERBOSE) {
+        if (verbosity >= utils::Verbosity::VERBOSE) {
             cout << transition_system.tag()
                  << "simplification was not f-preserving!" << endl;
         }
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/distances.h fast-downward/src/search/merge_and_shrink/distances.h
--- fast-downward-original/src/search/merge_and_shrink/distances.h	2020-07-09 18:54:18.828948400 -0300
+++ fast-downward/src/search/merge_and_shrink/distances.h	2020-06-17 03:29:39.159035100 -0300
@@ -14,6 +14,10 @@
   can be one of the bottlenecks in our code.)
 */
 
+namespace utils {
+enum class Verbosity;
+}
+
 namespace merge_and_shrink {
 class TransitionSystem;
 
@@ -48,7 +52,7 @@
     void compute_distances(
         bool compute_init_distances,
         bool compute_goal_distances,
-        Verbosity verbosity);
+        utils::Verbosity verbosity);
 
     /*
       Update distances according to the given abstraction. If the abstraction
@@ -63,7 +67,7 @@
         const StateEquivalenceRelation &state_equivalence_relation,
         bool compute_init_distances,
         bool compute_goal_distances,
-        Verbosity verbosity);
+        utils::Verbosity verbosity);
 
     int get_init_distance(int state) const {
         assert(are_init_distances_computed());
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/factored_transition_system.cc fast-downward/src/search/merge_and_shrink/factored_transition_system.cc
--- fast-downward-original/src/search/merge_and_shrink/factored_transition_system.cc	2020-07-09 18:54:18.831815200 -0300
+++ fast-downward/src/search/merge_and_shrink/factored_transition_system.cc	2020-06-17 03:29:39.173014300 -0300
@@ -7,6 +7,7 @@
 #include "utils.h"
 
 #include "../utils/collections.h"
+#include "../utils/logging.h"
 #include "../utils/memory.h"
 #include "../utils/system.h"
 
@@ -42,7 +43,7 @@
     vector<unique_ptr<Distances>> &&distances,
     const bool compute_init_distances,
     const bool compute_goal_distances,
-    Verbosity verbosity)
+    utils::Verbosity verbosity)
     : labels(move(labels)),
       transition_systems(move(transition_systems)),
       mas_representations(move(mas_representations)),
@@ -128,7 +129,7 @@
 bool FactoredTransitionSystem::apply_abstraction(
     int index,
     const StateEquivalenceRelation &state_equivalence_relation,
-    Verbosity verbosity) {
+    utils::Verbosity verbosity) {
     assert(is_component_valid(index));
 
     int new_num_states = state_equivalence_relation.size();
@@ -160,7 +161,7 @@
 int FactoredTransitionSystem::merge(
     int index1,
     int index2,
-    Verbosity verbosity) {
+    utils::Verbosity verbosity) {
     assert(is_component_valid(index1));
     assert(is_component_valid(index2));
     transition_systems.push_back(
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/factored_transition_system.h fast-downward/src/search/merge_and_shrink/factored_transition_system.h
--- fast-downward-original/src/search/merge_and_shrink/factored_transition_system.h	2020-07-09 18:54:18.833840300 -0300
+++ fast-downward/src/search/merge_and_shrink/factored_transition_system.h	2020-06-17 03:29:39.180992700 -0300
@@ -6,6 +6,10 @@
 #include <memory>
 #include <vector>
 
+namespace utils {
+enum class Verbosity;
+}
+
 namespace merge_and_shrink {
 class Distances;
 class FactoredTransitionSystem;
@@ -85,7 +89,7 @@
         std::vector<std::unique_ptr<Distances>> &&distances,
         bool compute_init_distances,
         bool compute_goal_distances,
-        Verbosity verbosity);
+        utils::Verbosity verbosity);
     FactoredTransitionSystem(FactoredTransitionSystem &&other);
     ~FactoredTransitionSystem();
 
@@ -119,7 +123,7 @@
     bool apply_abstraction(
         int index,
         const StateEquivalenceRelation &state_equivalence_relation,
-        Verbosity verbosity);
+        utils::Verbosity verbosity);
 
     /*
       Merge the two factors at index1 and index2.
@@ -127,7 +131,7 @@
     int merge(
         int index1,
         int index2,
-        Verbosity verbosity);
+        utils::Verbosity verbosity);
 
     /*
       Extract the factor at the given index, rendering the FTS invalid.
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/fts_factory.cc fast-downward/src/search/merge_and_shrink/fts_factory.cc
--- fast-downward-original/src/search/merge_and_shrink/fts_factory.cc	2020-07-09 18:54:18.835839700 -0300
+++ fast-downward/src/search/merge_and_shrink/fts_factory.cc	2020-06-17 03:29:39.186977100 -0300
@@ -11,6 +11,7 @@
 #include "../task_proxy.h"
 
 #include "../utils/collections.h"
+#include "../utils/logging.h"
 #include "../utils/memory.h"
 
 #include <algorithm>
@@ -90,7 +91,7 @@
     FactoredTransitionSystem create(
         bool compute_init_distances,
         bool compute_goal_distances,
-        Verbosity verbosity);
+        utils::Verbosity verbosity);
 };
 
 
@@ -429,8 +430,8 @@
 FactoredTransitionSystem FTSFactory::create(
     const bool compute_init_distances,
     const bool compute_goal_distances,
-    Verbosity verbosity) {
-    if (verbosity >= Verbosity::NORMAL) {
+    utils::Verbosity verbosity) {
+    if (verbosity >= utils::Verbosity::NORMAL) {
         cout << "Building atomic transition systems... " << endl;
     }
 
@@ -459,7 +460,7 @@
     const TaskProxy &task_proxy,
     const bool compute_init_distances,
     const bool compute_goal_distances,
-    Verbosity verbosity) {
+    utils::Verbosity verbosity) {
     return FTSFactory(task_proxy).create(
         compute_init_distances,
         compute_goal_distances,
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/fts_factory.h fast-downward/src/search/merge_and_shrink/fts_factory.h
--- fast-downward-original/src/search/merge_and_shrink/fts_factory.h	2020-07-09 18:54:18.837830800 -0300
+++ fast-downward/src/search/merge_and_shrink/fts_factory.h	2020-06-17 03:29:39.106176200 -0300
@@ -13,15 +13,18 @@
 
 class TaskProxy;
 
+namespace utils {
+enum class Verbosity;
+}
+
 namespace merge_and_shrink {
 class FactoredTransitionSystem;
-enum class Verbosity;
 
 extern FactoredTransitionSystem create_factored_transition_system(
     const TaskProxy &task_proxy,
     bool compute_init_distances,
     bool compute_goal_distances,
-    Verbosity verbosity);
+    utils::Verbosity verbosity);
 }
 
 #endif
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/label_reduction.cc fast-downward/src/search/merge_and_shrink/label_reduction.cc
--- fast-downward-original/src/search/merge_and_shrink/label_reduction.cc	2020-07-09 18:54:18.839793800 -0300
+++ fast-downward/src/search/merge_and_shrink/label_reduction.cc	2020-06-17 03:29:39.172016600 -0300
@@ -12,6 +12,7 @@
 
 #include "../algorithms/equivalence_relation.h"
 #include "../utils/collections.h"
+#include "../utils/logging.h"
 #include "../utils/markup.h"
 #include "../utils/rng.h"
 #include "../utils/rng_options.h"
@@ -62,7 +63,7 @@
     const equivalence_relation::EquivalenceRelation *relation,
     const FactoredTransitionSystem &fts,
     vector<pair<int, vector<int>>> &label_mapping,
-    Verbosity verbosity) const {
+    utils::Verbosity verbosity) const {
     const Labels &labels = fts.get_labels();
     int next_new_label_no = labels.get_size();
     int num_labels = 0;
@@ -95,7 +96,7 @@
         }
     }
     int number_reduced_labels = num_labels - num_labels_after_reduction;
-    if (verbosity >= Verbosity::VERBOSE && number_reduced_labels > 0) {
+    if (verbosity >= utils::Verbosity::VERBOSE && number_reduced_labels > 0) {
         cout << "Label reduction: "
              << num_labels << " labels, "
              << num_labels_after_reduction << " after reduction"
@@ -142,7 +143,7 @@
 bool LabelReduction::reduce(
     const pair<int, int> &next_merge,
     FactoredTransitionSystem &fts,
-    Verbosity verbosity) const {
+    utils::Verbosity verbosity) const {
     assert(initialized());
     assert(reduce_before_shrinking() || reduce_before_merging());
     int num_transition_systems = fts.get_size();
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/label_reduction.h fast-downward/src/search/merge_and_shrink/label_reduction.h
--- fast-downward-original/src/search/merge_and_shrink/label_reduction.h	2020-07-09 18:54:18.841788500 -0300
+++ fast-downward/src/search/merge_and_shrink/label_reduction.h	2020-06-17 03:29:39.162026800 -0300
@@ -16,11 +16,11 @@
 
 namespace utils {
 class RandomNumberGenerator;
+enum class Verbosity;
 }
 
 namespace merge_and_shrink {
 class FactoredTransitionSystem;
-enum class Verbosity;
 
 class LabelReduction {
     // Options for label reduction
@@ -68,7 +68,7 @@
         const equivalence_relation::EquivalenceRelation *relation,
         const FactoredTransitionSystem &fts,
         std::vector<std::pair<int, std::vector<int>>> &label_mapping,
-        Verbosity verbosity) const;
+        utils::Verbosity verbosity) const;
     equivalence_relation::EquivalenceRelation
     *compute_combinable_equivalence_relation(
         int ts_index,
@@ -79,7 +79,7 @@
     bool reduce(
         const std::pair<int, int> &next_merge,
         FactoredTransitionSystem &fts,
-        Verbosity verbosity) const;
+        utils::Verbosity verbosity) const;
     void dump_options() const;
     bool reduce_before_shrinking() const {
         return lr_before_shrinking;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/merge_and_shrink_algorithm.cc fast-downward/src/search/merge_and_shrink/merge_and_shrink_algorithm.cc
--- fast-downward-original/src/search/merge_and_shrink/merge_and_shrink_algorithm.cc	2020-07-09 18:54:18.844808600 -0300
+++ fast-downward/src/search/merge_and_shrink/merge_and_shrink_algorithm.cc	2020-06-17 03:29:39.188972000 -0300
@@ -19,6 +19,7 @@
 #include "../task_utils/task_properties.h"
 
 #include "../utils/countdown_timer.h"
+#include "../utils/logging.h"
 #include "../utils/markup.h"
 #include "../utils/math.h"
 #include "../utils/system.h"
@@ -50,7 +51,7 @@
     shrink_threshold_before_merge(opts.get<int>("threshold_before_merge")),
     prune_unreachable_states(opts.get<bool>("prune_unreachable_states")),
     prune_irrelevant_states(opts.get<bool>("prune_irrelevant_states")),
-    verbosity(static_cast<Verbosity>(opts.get_enum("verbosity"))),
+    verbosity(static_cast<utils::Verbosity>(opts.get_enum("verbosity"))),
     main_loop_max_time(opts.get<double>("main_loop_max_time")),
     starting_peak_memory(0) {
     assert(max_states_before_merge > 0);
@@ -69,42 +70,30 @@
 }
 
 void MergeAndShrinkAlgorithm::dump_options() const {
-    if (merge_strategy_factory) { // deleted after merge strategy extraction
-        merge_strategy_factory->dump_options();
-        cout << endl;
-    }
-
-    cout << "Options related to size limits and shrinking: " << endl;
-    cout << "Transition system size limit: " << max_states << endl
-         << "Transition system size limit right before merge: "
-         << max_states_before_merge << endl;
-    cout << "Threshold to trigger shrinking right before merge: "
-         << shrink_threshold_before_merge << endl;
-    cout << endl;
+    if (verbosity >= utils::Verbosity::VERBOSE) {
+        if (merge_strategy_factory) { // deleted after merge strategy extraction
+            merge_strategy_factory->dump_options();
+            cout << endl;
+        }
 
-    shrink_strategy->dump_options();
-    cout << endl;
+        cout << "Options related to size limits and shrinking: " << endl;
+        cout << "Transition system size limit: " << max_states << endl
+             << "Transition system size limit right before merge: "
+             << max_states_before_merge << endl;
+        cout << "Threshold to trigger shrinking right before merge: "
+             << shrink_threshold_before_merge << endl;
+        cout << endl;
 
-    if (label_reduction) {
-        label_reduction->dump_options();
-    } else {
-        cout << "Label reduction disabled" << endl;
-    }
-    cout << endl;
+        shrink_strategy->dump_options();
+        cout << endl;
 
-    cout << "Verbosity: ";
-    switch (verbosity) {
-    case Verbosity::SILENT:
-        cout << "silent";
-        break;
-    case Verbosity::NORMAL:
-        cout << "normal";
-        break;
-    case Verbosity::VERBOSE:
-        cout << "verbose";
-        break;
+        if (label_reduction) {
+            label_reduction->dump_options();
+        } else {
+            cout << "Label reduction disabled" << endl;
+        }
+        cout << endl;
     }
-    cout << endl;
 }
 
 void MergeAndShrinkAlgorithm::warn_on_unusual_options() const {
@@ -149,7 +138,7 @@
 bool MergeAndShrinkAlgorithm::ran_out_of_time(
     const utils::CountdownTimer &timer) const {
     if (timer.is_expired()) {
-        if (verbosity >= Verbosity::NORMAL) {
+        if (verbosity >= utils::Verbosity::NORMAL) {
             cout << "Ran out of time, stopping computation." << endl;
             cout << endl;
         }
@@ -162,7 +151,7 @@
     FactoredTransitionSystem &fts,
     const TaskProxy &task_proxy) {
     utils::CountdownTimer timer(main_loop_max_time);
-    if (verbosity >= Verbosity::NORMAL) {
+    if (verbosity >= utils::Verbosity::NORMAL) {
         cout << "Starting main loop ";
         if (main_loop_max_time == numeric_limits<double>::infinity()) {
             cout << "without a time limit." << endl;
@@ -201,10 +190,10 @@
         int merge_index1 = merge_indices.first;
         int merge_index2 = merge_indices.second;
         assert(merge_index1 != merge_index2);
-        if (verbosity >= Verbosity::NORMAL) {
+        if (verbosity >= utils::Verbosity::NORMAL) {
             cout << "Next pair of indices: ("
                  << merge_index1 << ", " << merge_index2 << ")" << endl;
-            if (verbosity >= Verbosity::VERBOSE) {
+            if (verbosity >= utils::Verbosity::VERBOSE) {
                 fts.statistics(merge_index1);
                 fts.statistics(merge_index2);
             }
@@ -214,7 +203,7 @@
         // Label reduction (before shrinking)
         if (label_reduction && label_reduction->reduce_before_shrinking()) {
             bool reduced = label_reduction->reduce(merge_indices, fts, verbosity);
-            if (verbosity >= Verbosity::NORMAL && reduced) {
+            if (verbosity >= utils::Verbosity::NORMAL && reduced) {
                 log_main_loop_progress("after label reduction");
             }
         }
@@ -233,7 +222,7 @@
             shrink_threshold_before_merge,
             *shrink_strategy,
             verbosity);
-        if (verbosity >= Verbosity::NORMAL && shrunk) {
+        if (verbosity >= utils::Verbosity::NORMAL && shrunk) {
             log_main_loop_progress("after shrinking");
         }
 
@@ -244,7 +233,7 @@
         // Label reduction (before merging)
         if (label_reduction && label_reduction->reduce_before_merging()) {
             bool reduced = label_reduction->reduce(merge_indices, fts, verbosity);
-            if (verbosity >= Verbosity::NORMAL && reduced) {
+            if (verbosity >= utils::Verbosity::NORMAL && reduced) {
                 log_main_loop_progress("after label reduction");
             }
         }
@@ -260,8 +249,8 @@
             maximum_intermediate_size = abs_size;
         }
 
-        if (verbosity >= Verbosity::NORMAL) {
-            if (verbosity >= Verbosity::VERBOSE) {
+        if (verbosity >= utils::Verbosity::NORMAL) {
+            if (verbosity >= utils::Verbosity::VERBOSE) {
                 fts.statistics(merged_index);
             }
             log_main_loop_progress("after merging");
@@ -281,8 +270,8 @@
                 prune_unreachable_states,
                 prune_irrelevant_states,
                 verbosity);
-            if (verbosity >= Verbosity::NORMAL && pruned) {
-                if (verbosity >= Verbosity::VERBOSE) {
+            if (verbosity >= utils::Verbosity::NORMAL && pruned) {
+                if (verbosity >= utils::Verbosity::VERBOSE) {
                     fts.statistics(merged_index);
                 }
                 log_main_loop_progress("after pruning");
@@ -296,7 +285,7 @@
           not to be pruned/not to be evaluated as infinity.
         */
         if (!fts.is_factor_solvable(merged_index)) {
-            if (verbosity >= Verbosity::NORMAL) {
+            if (verbosity >= utils::Verbosity::NORMAL) {
                 cout << "Abstract problem is unsolvable, stopping "
                     "computation. " << endl << endl;
             }
@@ -308,10 +297,10 @@
         }
 
         // End-of-iteration output.
-        if (verbosity >= Verbosity::VERBOSE) {
+        if (verbosity >= utils::Verbosity::VERBOSE) {
             report_peak_memory_delta();
         }
-        if (verbosity >= Verbosity::NORMAL) {
+        if (verbosity >= utils::Verbosity::NORMAL) {
             cout << endl;
         }
 
@@ -356,7 +345,7 @@
             compute_init_distances,
             compute_goal_distances,
             verbosity);
-    if (verbosity >= Verbosity::NORMAL) {
+    if (verbosity >= utils::Verbosity::NORMAL) {
         log_progress(timer, "after computation of atomic factors");
     }
 
@@ -385,7 +374,7 @@
             break;
         }
     }
-    if (verbosity >= Verbosity::NORMAL) {
+    if (verbosity >= utils::Verbosity::NORMAL) {
         if (pruned) {
             log_progress(timer, "after pruning atomic factors");
         }
@@ -440,26 +429,12 @@
 
     add_transition_system_size_limit_options_to_parser(parser);
 
-    vector<string> verbosity_levels;
-    vector<string> verbosity_level_docs;
-    verbosity_levels.push_back("silent");
-    verbosity_level_docs.push_back(
-        "silent: no output during construction, only starting and final "
-        "statistics");
-    verbosity_levels.push_back("normal");
-    verbosity_level_docs.push_back(
-        "normal: basic output during construction, starting and final "
-        "statistics");
-    verbosity_levels.push_back("verbose");
-    verbosity_level_docs.push_back(
-        "verbose: full output during construction, starting and final "
-        "statistics");
-    parser.add_enum_option(
-        "verbosity",
-        verbosity_levels,
-        "Option to specify the level of verbosity.",
-        "verbose",
-        verbosity_level_docs);
+    /*
+      silent: no output during construction, only starting and final statistics
+      normal: basic output during construction, starting and final statistics
+      verbose: full output during construction, starting and final statistics
+    */
+    utils::add_verbosity_option_to_parser(parser);
 
     parser.add_option<double>(
         "main_loop_max_time",
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/merge_and_shrink_algorithm.h fast-downward/src/search/merge_and_shrink/merge_and_shrink_algorithm.h
--- fast-downward-original/src/search/merge_and_shrink/merge_and_shrink_algorithm.h	2020-07-09 18:54:18.846803600 -0300
+++ fast-downward/src/search/merge_and_shrink/merge_and_shrink_algorithm.h	2020-06-17 03:29:39.108171700 -0300
@@ -12,6 +12,7 @@
 
 namespace utils {
 class CountdownTimer;
+enum class Verbosity;
 }
 
 namespace merge_and_shrink {
@@ -19,7 +20,6 @@
 class LabelReduction;
 class MergeStrategyFactory;
 class ShrinkStrategy;
-enum class Verbosity;
 
 class MergeAndShrinkAlgorithm {
     // TODO: when the option parser supports it, the following should become
@@ -41,7 +41,7 @@
     const bool prune_unreachable_states;
     const bool prune_irrelevant_states;
 
-    const Verbosity verbosity;
+    const utils::Verbosity verbosity;
     const double main_loop_max_time;
 
     long starting_peak_memory;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/merge_and_shrink_heuristic.cc fast-downward/src/search/merge_and_shrink/merge_and_shrink_heuristic.cc
--- fast-downward-original/src/search/merge_and_shrink/merge_and_shrink_heuristic.cc	2020-07-09 18:54:18.848769800 -0300
+++ fast-downward/src/search/merge_and_shrink/merge_and_shrink_heuristic.cc	2020-06-17 03:29:39.143077600 -0300
@@ -12,6 +12,7 @@
 
 #include "../task_utils/task_properties.h"
 
+#include "../utils/logging.h"
 #include "../utils/markup.h"
 #include "../utils/system.h"
 
@@ -25,7 +26,7 @@
 namespace merge_and_shrink {
 MergeAndShrinkHeuristic::MergeAndShrinkHeuristic(const options::Options &opts)
     : Heuristic(opts),
-      verbosity(static_cast<Verbosity>(opts.get_enum("verbosity"))) {
+      verbosity(static_cast<utils::Verbosity>(opts.get_enum("verbosity"))) {
     cout << "Initializing merge-and-shrink heuristic..." << endl;
     MergeAndShrinkAlgorithm algorithm(opts);
     FactoredTransitionSystem fts = algorithm.build_factored_transition_system(task_proxy);
@@ -59,7 +60,7 @@
     */
 
     int active_factors_count = fts.get_num_active_entries();
-    if (verbosity >= Verbosity::NORMAL) {
+    if (verbosity >= utils::Verbosity::NORMAL) {
         cout << "Number of remaining factors: " << active_factors_count << endl;
     }
 
@@ -68,7 +69,7 @@
         if (!fts.is_factor_solvable(index)) {
             mas_representations.reserve(1);
             finalize_factor(fts, index);
-            if (verbosity >= Verbosity::NORMAL) {
+            if (verbosity >= utils::Verbosity::NORMAL) {
                 cout << fts.get_transition_system(index).tag()
                      << "use this unsolvable factor as heuristic."
                      << endl;
@@ -82,7 +83,7 @@
     for (int index : fts) {
         finalize_factor(fts, index);
     }
-    if (verbosity >= Verbosity::NORMAL) {
+    if (verbosity >= utils::Verbosity::NORMAL) {
         cout << "Use all factors in a maximum heuristic." << endl;
     }
 
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/merge_and_shrink_heuristic.h fast-downward/src/search/merge_and_shrink/merge_and_shrink_heuristic.h
--- fast-downward-original/src/search/merge_and_shrink/merge_and_shrink_heuristic.h	2020-07-09 18:54:18.850765400 -0300
+++ fast-downward/src/search/merge_and_shrink/merge_and_shrink_heuristic.h	2020-06-17 03:29:39.153050600 -0300
@@ -5,13 +5,16 @@
 
 #include <memory>
 
+namespace utils {
+enum class Verbosity;
+}
+
 namespace merge_and_shrink {
 class FactoredTransitionSystem;
 class MergeAndShrinkRepresentation;
-enum class Verbosity;
 
 class MergeAndShrinkHeuristic : public Heuristic {
-    Verbosity verbosity;
+    const utils::Verbosity verbosity;
 
     // The final merge-and-shrink representations, storing goal distances.
     std::vector<std::unique_ptr<MergeAndShrinkRepresentation>> mas_representations;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/merge_scoring_function_miasm.cc fast-downward/src/search/merge_and_shrink/merge_scoring_function_miasm.cc
--- fast-downward-original/src/search/merge_and_shrink/merge_scoring_function_miasm.cc	2020-07-09 18:54:18.858742900 -0300
+++ fast-downward/src/search/merge_and_shrink/merge_scoring_function_miasm.cc	2020-06-17 03:29:39.176005900 -0300
@@ -11,6 +11,7 @@
 #include "../options/options.h"
 #include "../options/plugin.h"
 
+#include "../utils/logging.h"
 #include "../utils/markup.h"
 
 using namespace std;
@@ -45,7 +46,7 @@
         unique_ptr<Distances> distances = utils::make_unique_ptr<Distances>(*product);
         const bool compute_init_distances = true;
         const bool compute_goal_distances = true;
-        const Verbosity verbosity = Verbosity::SILENT;
+        const utils::Verbosity verbosity = utils::Verbosity::SILENT;
         distances->compute_distances(compute_init_distances, compute_goal_distances, verbosity);
         int num_states = product->get_size();
         int alive_states_count = 0;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/merge_scoring_function_miasm_utils.cc fast-downward/src/search/merge_and_shrink/merge_scoring_function_miasm_utils.cc
--- fast-downward-original/src/search/merge_and_shrink/merge_scoring_function_miasm_utils.cc	2020-07-09 18:54:18.860737400 -0300
+++ fast-downward/src/search/merge_and_shrink/merge_scoring_function_miasm_utils.cc	2020-06-17 03:29:39.178997700 -0300
@@ -6,6 +6,7 @@
 #include "transition_system.h"
 #include "utils.h"
 
+#include "../utils/logging.h"
 #include "../utils/memory.h"
 
 #include <algorithm>
@@ -25,7 +26,7 @@
     const Distances &distances,
     const ShrinkStrategy &shrink_strategy,
     int new_size,
-    Verbosity verbosity) {
+    utils::Verbosity verbosity) {
     /*
       TODO: think about factoring out common logic of this function and the
       function shrink_factor in utils.cc
@@ -82,7 +83,7 @@
       only triggered due to the threshold being passed but no perfect
       shrinking is possible, the method returns a null pointer.)
     */
-    Verbosity verbosity = Verbosity::SILENT;
+    utils::Verbosity verbosity = utils::Verbosity::SILENT;
     unique_ptr<TransitionSystem> ts1 = nullptr;
     if (must_shrink_ts1) {
         ts1 = copy_and_shrink_ts(
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/shrink_bisimulation.cc fast-downward/src/search/merge_and_shrink/shrink_bisimulation.cc
--- fast-downward-original/src/search/merge_and_shrink/shrink_bisimulation.cc	2020-07-09 18:54:18.879686400 -0300
+++ fast-downward/src/search/merge_and_shrink/shrink_bisimulation.cc	2020-06-17 03:29:39.557635300 -0300
@@ -106,7 +106,7 @@
 
        Each other group holds all states with one particular h value.
 
-       Note that some goal state *must* exist because irrelevant und
+       Note that some goal state *must* exist because irrelevant and
        unreachable states are pruned before we shrink and we never
        perform the shrinking if that pruning shows that the problem is
        unsolvable.
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/transition_system.cc fast-downward/src/search/merge_and_shrink/transition_system.cc
--- fast-downward-original/src/search/merge_and_shrink/transition_system.cc	2020-07-09 18:54:18.890695000 -0300
+++ fast-downward/src/search/merge_and_shrink/transition_system.cc	2020-06-17 03:29:39.130112100 -0300
@@ -5,6 +5,7 @@
 #include "labels.h"
 
 #include "../utils/collections.h"
+#include "../utils/logging.h"
 #include "../utils/memory.h"
 #include "../utils/system.h"
 
@@ -115,8 +116,8 @@
     const Labels &labels,
     const TransitionSystem &ts1,
     const TransitionSystem &ts2,
-    Verbosity verbosity) {
-    if (verbosity >= Verbosity::VERBOSE) {
+    utils::Verbosity verbosity) {
+    if (verbosity >= utils::Verbosity::VERBOSE) {
         cout << "Merging " << ts1.get_description() << " and "
              << ts2.get_description() << endl;
     }
@@ -267,13 +268,13 @@
 void TransitionSystem::apply_abstraction(
     const StateEquivalenceRelation &state_equivalence_relation,
     const vector<int> &abstraction_mapping,
-    Verbosity verbosity) {
+    utils::Verbosity verbosity) {
     assert(are_transitions_sorted_unique());
     assert(in_sync_with_label_equivalence_relation());
 
     int new_num_states = state_equivalence_relation.size();
     assert(new_num_states < num_states);
-    if (verbosity >= Verbosity::VERBOSE) {
+    if (verbosity >= utils::Verbosity::VERBOSE) {
         cout << tag() << "applying abstraction (" << get_size()
              << " to " << new_num_states << " states)" << endl;
     }
@@ -323,7 +324,7 @@
 
     num_states = new_num_states;
     init_state = abstraction_mapping[init_state];
-    if (verbosity >= Verbosity::VERBOSE && init_state == PRUNED_STATE) {
+    if (verbosity >= utils::Verbosity::VERBOSE && init_state == PRUNED_STATE) {
         cout << tag() << "initial state pruned; task unsolvable" << endl;
     }
 
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/transition_system.h fast-downward/src/search/merge_and_shrink/transition_system.h
--- fast-downward-original/src/search/merge_and_shrink/transition_system.h	2020-07-09 18:54:18.892653000 -0300
+++ fast-downward/src/search/merge_and_shrink/transition_system.h	2020-06-17 03:29:39.160032800 -0300
@@ -9,6 +9,10 @@
 #include <utility>
 #include <vector>
 
+namespace utils {
+enum class Verbosity;
+}
+
 namespace merge_and_shrink {
 class Distances;
 class LabelEquivalenceRelation;
@@ -150,7 +154,7 @@
         const Labels &labels,
         const TransitionSystem &ts1,
         const TransitionSystem &ts2,
-        Verbosity verbosity);
+        utils::Verbosity verbosity);
 
     /*
       Applies the given state equivalence relation to the transition system.
@@ -162,7 +166,7 @@
     void apply_abstraction(
         const StateEquivalenceRelation &state_equivalence_relation,
         const std::vector<int> &abstraction_mapping,
-        Verbosity verbosity);
+        utils::Verbosity verbosity);
 
     /*
       Applies the given label mapping, mapping old to new label numbers. This
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/types.h fast-downward/src/search/merge_and_shrink/types.h
--- fast-downward-original/src/search/merge_and_shrink/types.h	2020-07-09 18:54:18.894646500 -0300
+++ fast-downward/src/search/merge_and_shrink/types.h	2020-06-17 03:29:39.193958300 -0300
@@ -21,12 +21,6 @@
 */
 using StateEquivalenceClass = std::forward_list<int>;
 using StateEquivalenceRelation = std::vector<StateEquivalenceClass>;
-
-enum class Verbosity {
-    SILENT,
-    NORMAL,
-    VERBOSE
-};
 }
 
 #endif
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/utils.cc fast-downward/src/search/merge_and_shrink/utils.cc
--- fast-downward-original/src/search/merge_and_shrink/utils.cc	2020-07-09 18:54:18.895643900 -0300
+++ fast-downward/src/search/merge_and_shrink/utils.cc	2020-06-17 03:29:39.179995500 -0300
@@ -5,6 +5,7 @@
 #include "shrink_strategy.h"
 #include "transition_system.h"
 
+#include "../utils/logging.h"
 #include "../utils/math.h"
 
 #include <algorithm>
@@ -66,7 +67,7 @@
     int new_size,
     int shrink_threshold_before_merge,
     const ShrinkStrategy &shrink_strategy,
-    Verbosity verbosity) {
+    utils::Verbosity verbosity) {
     /*
       TODO: think about factoring out common logic of this function and the
       function copy_and_shrink_ts in merge_scoring_function_miasm_utils.cc.
@@ -74,7 +75,7 @@
     const TransitionSystem &ts = fts.get_transition_system(index);
     int num_states = ts.get_size();
     if (num_states > min(new_size, shrink_threshold_before_merge)) {
-        if (verbosity >= Verbosity::VERBOSE) {
+        if (verbosity >= utils::Verbosity::VERBOSE) {
             cout << ts.tag() << "current size: " << num_states;
             if (new_size < num_states)
                 cout << " (new size limit: " << new_size;
@@ -101,7 +102,7 @@
     int max_states_before_merge,
     int shrink_threshold_before_merge,
     const ShrinkStrategy &shrink_strategy,
-    Verbosity verbosity) {
+    utils::Verbosity verbosity) {
     /*
       Compute the size limit for both transition systems as imposed by
       max_states and max_states_before_merge.
@@ -126,7 +127,7 @@
         shrink_threshold_before_merge,
         shrink_strategy,
         verbosity);
-    if (verbosity >= Verbosity::VERBOSE && shrunk1) {
+    if (verbosity >= utils::Verbosity::VERBOSE && shrunk1) {
         fts.statistics(index1);
     }
     bool shrunk2 = shrink_factor(
@@ -136,7 +137,7 @@
         shrink_threshold_before_merge,
         shrink_strategy,
         verbosity);
-    if (verbosity >= Verbosity::VERBOSE && shrunk2) {
+    if (verbosity >= utils::Verbosity::VERBOSE && shrunk2) {
         fts.statistics(index2);
     }
     return shrunk1 || shrunk2;
@@ -147,7 +148,7 @@
     int index,
     bool prune_unreachable_states,
     bool prune_irrelevant_states,
-    Verbosity verbosity) {
+    utils::Verbosity verbosity) {
     assert(prune_unreachable_states || prune_irrelevant_states);
     const TransitionSystem &ts = fts.get_transition_system(index);
     const Distances &distances = fts.get_distances(index);
@@ -183,7 +184,7 @@
             state_equivalence_relation.push_back(state_equivalence_class);
         }
     }
-    if (verbosity >= Verbosity::VERBOSE &&
+    if (verbosity >= utils::Verbosity::VERBOSE &&
         (unreachable_count || irrelevant_count)) {
         cout << ts.tag()
              << "unreachable: " << unreachable_count << " states, "
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/merge_and_shrink/utils.h fast-downward/src/search/merge_and_shrink/utils.h
--- fast-downward-original/src/search/merge_and_shrink/utils.h	2020-07-09 18:54:18.897638400 -0300
+++ fast-downward/src/search/merge_and_shrink/utils.h	2020-06-17 03:29:39.196950300 -0300
@@ -6,6 +6,10 @@
 #include <memory>
 #include <vector>
 
+namespace utils {
+enum class Verbosity;
+}
+
 namespace merge_and_shrink {
 class FactoredTransitionSystem;
 class ShrinkStrategy;
@@ -50,7 +54,7 @@
     int max_states_before_merge,
     int shrink_threshold_before_merge,
     const ShrinkStrategy &shrink_strategy,
-    Verbosity verbosity);
+    utils::Verbosity verbosity);
 
 /*
   Prune unreachable and/or irrelevant states of the factor at index. This
@@ -64,7 +68,7 @@
     int index,
     bool prune_unreachable_states,
     bool prune_irrelevant_states,
-    Verbosity verbosity);
+    utils::Verbosity verbosity);
 
 /*
   Compute the abstraction mapping based on the given state equivalence
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.cc fast-downward/src/search/operator_counting/oc_single_shot_heuristic.cc
--- fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.cc	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/oc_single_shot_heuristic.cc	2020-07-07 02:25:31.578546100 -0300
@@ -0,0 +1,438 @@
+#include "oc_single_shot_heuristic.h"
+
+#include "constraint_generator.h"
+
+#include "../option_parser.h"
+#include "../plugin.h"
+
+#include "../utils/markup.h"
+
+#include <cmath>
+#include <fstream>
+#include <algorithm>
+#include <cctype>
+#include <locale>
+
+using namespace std;
+
+// trim from start (in place)
+static inline void ltrim(std::string &s) {
+    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
+        return !std::isspace(ch);
+    }));
+}
+
+// trim from end (in place)
+static inline void rtrim(std::string &s) {
+    s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
+        return !std::isspace(ch);
+    }).base(), s.end());
+}
+
+// trim from both ends (in place)
+static inline void trim(std::string &s) {
+    ltrim(s);
+    rtrim(s);
+}
+
+using namespace std;
+
+namespace operator_counting {
+
+OCSingleShotHeuristic::OCSingleShotHeuristic(const Options &opts)
+    : Heuristic(opts),
+      constraint_generators(
+          opts.get_list<shared_ptr<ConstraintGenerator>>("constraint_generators")),
+      lp_h(lp::LPSolverType(opts.get_enum("lpsolver"))),
+      lp_h_c(lp::LPSolverType(opts.get_enum("lpsolver"))),
+      lp_h_s(lp::LPSolverType(opts.get_enum("lpsolver"))),
+      calculate_h(opts.get<bool>("calculate_h")),
+      calculate_h_c(opts.get<bool>("calculate_h_c")),
+      calculate_h_s(opts.get<bool>("calculate_h_s")),
+      filter(opts.get<int>("filter")),
+      soft_weight(opts.get<int>("weights")) {
+
+    // Initialize map to convert operator name to operator ID
+    map_operators(false);
+
+    // Read observations from file and prune invalid
+    load_observations();
+    prune_observations();
+
+    // Create heuristic constraints
+    double infinity = lp_h.get_infinity();
+    vector<lp::LPConstraint> constraints;
+    for (const auto &generator : constraint_generators) {
+        generator->initialize_constraints(task, constraints, infinity);
+    }
+
+    // Create operator variables
+    vector<lp::LPVariable> variables;
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        variables.push_back(lp::LPVariable(0, infinity, op.get_cost()));
+    }
+
+    // Initialize LP problem without observation constraints
+    if (calculate_h) {
+        lp_h.load_problem(lp::LPObjectiveSense::MINIMIZE, variables, constraints);
+    }
+
+    // Set observation weights 
+    if (calculate_h_s) {
+        if (soft_weight == 1) {
+            double weight_per_op = 1.0 / 1000;
+            for (auto it = observations.begin(); it != observations.end(); ++it)
+                if (op_indexes.find(*it) != op_indexes.end())
+                    weights[*it] = weight_per_op;
+        } else if (soft_weight == 2) {
+            double weight_per_op = 1.0;
+            for (auto it = observations.begin(); it != observations.end(); ++it)
+                if (op_indexes.find(*it) != op_indexes.end())
+                    weights[*it] = weight_per_op;
+        } else if (soft_weight == 3) {
+            double weight_per_op = 1.0;
+            double weight = weight_per_op;
+            for (auto it = observations.begin(); it != observations.end(); ++it) {
+                if (op_indexes.find(*it) != op_indexes.end()) {
+                    max_weight += weight;
+                    weights[*it] += weight;
+                    weight += weight_per_op;
+                }
+            }
+            for (auto it = obs_occurrences.begin(); it != obs_occurrences.end(); ++it)
+                weights[it->first] /= it->second;
+        }
+    }
+
+    // Create observation variables
+    for (auto it = valid_obs_occurrences.begin(); it != valid_obs_occurrences.end(); ++it) {
+        // Determine how many times the same observed operation occurs.
+        string op = it->first;
+        int count_obs = it->second;
+        cout << "constraint " << op << ": " << std::to_string(op_indexes[op]) << endl;
+        int var_id = variables.size();
+        variables.push_back(lp::LPVariable(0, count_obs, -weights[op]));
+        lp::LPConstraint lt_y(0, infinity);
+        lt_y.insert(op_indexes[op], 1);
+        lt_y.insert(var_id, -1);
+        constraints.push_back(lt_y);
+    }
+
+    if (calculate_h_s) {
+        lp_h_s.load_problem(lp::LPObjectiveSense::MINIMIZE, variables, constraints);
+    }
+
+    if (calculate_h_c) {
+        int k = max(0, filter - num_pruned_observations);
+        lp::LPConstraint constraint(num_valid_observations - k, infinity);
+        int var_id = task_proxy.get_operators().size();
+        for (auto it = valid_obs_occurrences.begin(); it != valid_obs_occurrences.end(); ++it) {
+            constraint.insert(var_id, 1);
+            variables[var_id].objective_coefficient = 0;
+            var_id++;
+        }
+        constraints.push_back(constraint);
+        lp_h_c.load_problem(lp::LPObjectiveSense::MINIMIZE, variables, constraints);
+    }
+
+}
+
+void OCSingleShotHeuristic::map_operators(bool show) {
+    if (show) {
+        cout << endl << string(80, '*') << endl;
+        cout << "# Mapping X -> op: " << endl;
+    }
+    int i = 0;
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        // Caching operator variable indexes
+        std::string op_name (op.get_name());
+        for (size_t i = 0; i< op.get_name().size(); ++i) {
+            op_name[i] = tolower(op_name.c_str()[i]);
+        }
+        op_indexes[op_name] = i;
+        if (show) {
+            cout << "["<< op_name<< "]: " << op_indexes[op_name] << endl;
+        }
+        i++;
+    }
+    if (show) {
+        cout << string(80, '*') << endl;
+    }
+}
+
+void OCSingleShotHeuristic::show_variables_and_objective(const vector<lp::LPVariable> &variables) {
+    cout << endl << string(80, '*') << endl;
+    cout << "# Variables(" << variables.size() << "): " << endl;
+    for (int i = 0; i < (int) variables.size(); ++i) {
+        cout << "X[" << i << "] = Variable('X_" << i << "'";
+        cout << ", lb=" << variables[i].lower_bound;
+        cout << ", ub=" << variables[i].upper_bound;
+        cout << ", cost[" << i << "] = " << variables[i].objective_coefficient << endl;
+    }
+    cout << string(80, '*') << endl;
+    cout << endl << string(80, '*') << endl;
+    cout << "# Objective function: " << endl;
+    cout << "obj = Objective(";
+    for (int i = 0; i < (int) variables.size(); ++i) {
+        cout << "cost[" << i << "] * X[" << i << "]";
+        if (i < (int) variables.size() - 1) {
+            cout << " + ";
+        }
+    }
+    cout << ", direction='min')" << endl;
+    cout << string(80, '*') << endl;
+}
+
+void OCSingleShotHeuristic::load_observations() {
+    // Read observations from file
+    cout << endl << string(80, '*') << endl;
+    cout << std::endl << "Load observations" << std::endl;
+    ifstream obs_file;
+    obs_file.open("obs.dat");
+    if(obs_file.is_open()){
+        while(!obs_file.eof()) {
+            string obs;
+            getline(obs_file, obs);
+            trim(obs);
+            if(!obs.empty() && obs[0]!=';') {
+                obs = obs.substr(1,obs.length()-2);
+                std::string obs_name (obs);
+                for (size_t i = 0; i< obs.size(); ++i) {
+                    obs_name[i] = tolower(obs.c_str()[i]);
+                }
+                cout << "Observation: " << obs_name << endl;
+                observations.push_back(obs_name);
+            }
+        }
+    }
+    cout << endl << string(80, '*') << endl;
+    obs_file.close();
+    // =-=-=-=-= Each observation is associated with its number of occurrences. =-=-=-=-= //
+    obs_occurrences.clear();
+    for(auto it = observations.begin() ; it != observations.end(); ++it) {
+        obs_occurrences[*it]++;
+    }
+}
+
+void OCSingleShotHeuristic::prune_observations() { 
+    // Debugging output (cumulative: appends new info with each call)
+    std::fstream outfile("debug/observation_sanity.txt", std::ios::out|std::ios::app) ;
+    // Set output stream (set to std::cout to print to terminal)
+    std::ostream& outstream = outfile;
+    // Reinitialize class variables for invalid (unmapped) observations.
+    num_pruned_observations = 0;
+    pruned_observations.clear();
+    valid_obs_occurrences.clear();
+    vector<string> invalid_operators;
+    int num_invalid_operators = 0;
+    //outstream << endl << string(80, '*') << endl;
+    //outstream << "Enforcing observation constraints" << std::endl;
+    outstream << endl<< "-+-"; // marks start
+    for (auto it = obs_occurrences.begin(); it != obs_occurrences.end(); ++it) {
+        // Observation is mappable?
+        // If not: ignore observation, storing it in a separate list.
+        if (op_indexes.find(it->first) == op_indexes.end()) {
+            //outstream << "[INVALID OP] " << op << endl;
+            invalid_operators.push_back(it->first);
+            num_invalid_operators += 1;
+            num_pruned_observations += it->second;
+        } else {
+            valid_obs_occurrences[it->first] = it->second;
+            num_valid_observations += it->second;
+        }
+    }
+    // =-=-=-=-= Report on pruned and invalid operators/observations. =-=-=-=-= //
+    // Basic structure:
+    // Print invalid observations, number of operators and total number of observations.
+    // Last line holds number of observations and number of invalid observations,
+    //  followed by any relevant tags.
+    for (int i = 0 ; i < num_invalid_operators; i++) {
+        outstream << endl<< "[INVALID OP] " << invalid_operators[i] << ": " << obs_occurrences[invalid_operators[i]] <<" time(s).";
+    }
+    if (num_pruned_observations > 0) {
+        outstream << endl << "# mappable operators: " << op_indexes.size() << endl;
+        outstream << "Obs - Total: " << observations.size() << " | Invalid: " << num_pruned_observations;
+    }
+    outfile.flush();
+    outfile.close();
+}
+
+void OCSingleShotHeuristic::output_results(double result, double result_c, double result_s) {
+    // Log solutions
+    cout << endl << string(80, '*') << endl;
+    vector<double> solution;
+    if (calculate_h_s)
+        solution = lp_h_s.extract_solution();
+    else if (calculate_h_c)
+        solution = lp_h_c.extract_solution();
+    else
+        solution = lp_h.extract_solution();
+    for (int i = 0; i < (int) solution.size(); ++i) {
+        cout << "X[" << i << "] = " << solution[i] << endl;
+    }
+    // Get hits/misses
+    double obs_hits = 0, obs_miss = 0;
+    unordered_map<string, double> counts;
+    for(auto it = observations.begin() ; it != observations.end(); ++it) {
+        if (op_indexes.find(*it) != op_indexes.end()) {
+            if (solution[op_indexes[*it]] > counts[*it]) {
+                obs_hits++;
+                counts[*it]++;
+            } else {
+                obs_miss++;
+            }
+        }
+    }
+    cout << "obs-report: " << observations.size() << " " << num_pruned_observations << " " << obs_hits << " " << obs_miss << endl;
+    cout << "h-values: " << result << " " << result_c << " " << result_s << endl;
+    cout << string(80, '*') << endl << endl;
+    // Write result
+    cout << "Writing results...";
+    ofstream results;
+    results.open("ocsingleshot_heuristic_result.dat");
+    results << "obs-report: " << observations.size() << " " << num_pruned_observations << " " << obs_hits << " " << obs_miss << endl;
+    results << "h-values: " << result << " " << result_c << " " << result_s << endl;
+    // Write counts
+    int var_i = 0;
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        if (solution[var_i] > 0) {
+            results << "(" << op.get_name() << ") = " << solution[var_i] << endl;
+        }
+        var_i++;
+    }
+    results.flush();
+    results.close();
+    cout << "Done!" << endl;
+}
+
+OCSingleShotHeuristic::~OCSingleShotHeuristic() {
+}
+
+int OCSingleShotHeuristic::compute_heuristic(const GlobalState &global_state) {
+    State state = convert_global_state(global_state);
+    return compute_heuristic(state);
+}
+
+int OCSingleShotHeuristic::compute_heuristic(const State &state) {
+    double result = 0, result_c = 0, result_s = 0;
+    assert(!lp_h_c.has_temporary_constraints());
+    for (const auto &generator : constraint_generators) {
+        if (calculate_h && generator->update_constraints(state, lp_h)) {
+            lp_h.clear_temporary_constraints();
+            result = DEAD_END;
+            calculate_h = false;
+        }
+        if (calculate_h_c && generator->update_constraints(state, lp_h_c)) {
+            lp_h_c.clear_temporary_constraints();
+            result_c = DEAD_END;
+            calculate_h_c = false;
+        }
+        if (calculate_h_s && generator->update_constraints(state, lp_h_s)) {
+            lp_h_s.clear_temporary_constraints();
+            result_s = DEAD_END;
+            calculate_h_s = false;
+        }
+    }
+    // LP result without observation constraints
+    if (calculate_h) {
+        lp_h.solve();
+        if (lp_h.has_optimal_solution()) {
+            double epsilon = 0.01;
+            double objective_value = lp_h.get_objective_value();
+            result = ceil(objective_value - epsilon);
+        } else {
+            result = 0.0 / 0.0;
+        }
+        cout << "h: " << result << endl;
+    }
+    // LP result with hard observation constraints
+    if (calculate_h_c) {
+        lp_h_c.solve();
+        if (lp_h_c.has_optimal_solution()) {
+            double epsilon = 0.01;
+            double objective_value = lp_h_c.get_objective_value();
+            result_c = ceil(objective_value - epsilon);
+        } else {
+            result_c = 0.0 / 0.0;
+        }
+        cout << "h_c: " << result_c << endl;
+    }
+    // LP result with soft observation constraints
+    if (calculate_h_s) {
+        lp_h_s.solve();
+        if (lp_h_s.has_optimal_solution()) {
+            double epsilon = 0.01;
+            double objective_value = lp_h_s.get_objective_value();
+            result_s = ceil(objective_value - epsilon) + max_weight;
+        } else {
+            result_s = 0.0 / 0.0;
+        }
+        cout << "h_s: " << result_s << endl;
+    }
+
+    output_results(result, result_c, result_s);
+
+    exit(EXIT_SUCCESS);
+    return 0;
+}
+
+static shared_ptr<Heuristic> _parse(OptionParser &parser) {
+    parser.document_synopsis(
+        "Operator counting heuristic",
+        "An operator counting heuristic computes a linear program (LP) in each "
+        "state. The LP has one variable Count_o for each operator o that "
+        "represents how often the operator is used in a plan. Operator "
+        "counting constraints are linear constraints over these varaibles that "
+        "are guaranteed to have a solution with Count_o = occurrences(o, pi) "
+        "for every plan pi. Minimizing the total cost of operators subject to "
+        "some operator counting constraints is an admissible heuristic. "
+        "For details, see" + utils::format_conference_reference( // TODO - Change this for our paper
+            {"Florian Pommerening", "Gabriele Roeger", "Malte Helmert",
+             "Blai Bonet"},
+            "LP-based Heuristics for Cost-optimal Planning",
+            "http://www.aaai.org/ocs/index.php/ICAPS/ICAPS14/paper/view/7892/8031",
+            "Proceedings of the Twenty-Fourth International Conference"
+            " on Automated Planning and Scheduling (ICAPS 2014)",
+            "226-234",
+            "AAAI Press",
+            "2014"));
+
+    parser.document_language_support("action costs", "supported");
+    parser.document_language_support(
+        "conditional effects",
+        "not supported (the heuristic supports them in theory, but none of "
+        "the currently implemented constraint generators do)");
+    parser.document_language_support(
+        "axioms",
+        "not supported (the heuristic supports them in theory, but none of "
+        "the currently implemented constraint generators do)");
+    parser.document_property("admissible", "yes");
+    parser.document_property(
+        "consistent",
+        "yes, if all constraint generators represent consistent heuristics");
+    parser.document_property("safe", "yes");
+    // TODO: prefer operators that are non-zero in the solution.
+    parser.document_property("preferred operators", "no");
+
+    parser.add_list_option<shared_ptr<ConstraintGenerator>>(
+        "constraint_generators",
+        "methods that generate constraints over operator counting variables");
+    parser.add_option<bool>("calculate_h", "calculate h-value", "true");
+    parser.add_option<bool>("calculate_h_c", "calculate h-value with hard observation constraints", "true");
+    parser.add_option<bool>("calculate_h_s", "calculate h-value with soft observation constraints", "true");
+    parser.add_option<int>("weights", "weight type for soft constraints", "1");
+    parser.add_option<int>("filter", "observation filter", "0");
+    lp::add_lp_solver_option_to_parser(parser);
+    Heuristic::add_options_to_parser(parser);
+    Options opts = parser.parse();
+    if (parser.help_mode())
+        return nullptr;
+    opts.verify_list_non_empty<shared_ptr<ConstraintGenerator>>(
+        "constraint_generators");
+    if (parser.dry_run())
+        return nullptr;
+    return make_shared<OCSingleShotHeuristic>(opts);
+}
+
+static Plugin<Evaluator> _plugin("ocsingleshot", _parse);
+}
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.h fast-downward/src/search/operator_counting/oc_single_shot_heuristic.h
--- fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.h	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/oc_single_shot_heuristic.h	2020-07-03 13:20:01.935927300 -0300
@@ -0,0 +1,54 @@
+#ifndef OPERATOR_COUNTING_OPERATOR_COUNTING_HEURISTIC_H
+#define OPERATOR_COUNTING_OPERATOR_COUNTING_HEURISTIC_H
+
+#include "../heuristic.h"
+
+#include "../lp/lp_solver.h"
+
+#include <memory>
+#include <vector>
+#include <string>
+#include <unordered_map>
+
+namespace options {
+class Options;
+}
+
+namespace operator_counting {
+class ConstraintGenerator;
+
+class OCSingleShotHeuristic : public Heuristic {
+    std::vector<std::shared_ptr<ConstraintGenerator>> constraint_generators;
+    lp::LPSolver lp_h;
+    lp::LPSolver lp_h_c;
+    lp::LPSolver lp_h_s;
+    bool calculate_h, calculate_h_c, calculate_h_s;
+    int filter;
+
+    std::unordered_map<std::string,int> op_indexes;
+    std::vector<std::string> observations;
+    std::vector<std::string> pruned_observations;
+    std::unordered_map<std::string, int> obs_occurrences;
+    std::unordered_map<std::string, int> valid_obs_occurrences;
+    int num_pruned_observations = 0;
+    int num_valid_observations = 0;
+
+    int soft_weight;
+    std::unordered_map<std::string, double> weights;
+    double max_weight = 0;
+
+protected:
+    virtual int compute_heuristic(const GlobalState &global_state) override;
+    int compute_heuristic(const State &state);
+    void load_observations();
+    void prune_observations();
+    void output_results(double result, double result_c, double result_s);
+public:
+    explicit OCSingleShotHeuristic(const options::Options &opts);
+    ~OCSingleShotHeuristic();
+    void map_operators(bool show = false);
+    void show_variables_and_objective(const std::vector<lp::LPVariable> &variables);
+};
+}
+
+#endif
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_engine.cc fast-downward/src/search/search_engine.cc
--- fast-downward-original/src/search/search_engine.cc	2020-07-09 18:54:18.966381800 -0300
+++ fast-downward/src/search/search_engine.cc	2020-06-17 03:29:39.229550700 -0300
@@ -10,6 +10,7 @@
 #include "task_utils/task_properties.h"
 #include "tasks/root_task.h"
 #include "utils/countdown_timer.h"
+#include "utils/logging.h"
 #include "utils/rng_options.h"
 #include "utils/system.h"
 #include "utils/timer.h"
@@ -48,9 +49,12 @@
       state_registry(task_proxy),
       successor_generator(get_successor_generator(task_proxy)),
       search_space(state_registry),
+      search_progress(static_cast<utils::Verbosity>(opts.get_enum("verbosity"))),
+      statistics(static_cast<utils::Verbosity>(opts.get_enum("verbosity"))),
       cost_type(static_cast<OperatorCost>(opts.get_enum("cost_type"))),
       is_unit_cost(task_properties::is_unit_cost(task_proxy)),
-      max_time(opts.get<double>("max_time")) {
+      max_time(opts.get<double>("max_time")),
+      verbosity(static_cast<utils::Verbosity>(opts.get_enum("verbosity"))) {
     if (opts.get<int>("bound") < 0) {
         cerr << "error: negative cost bound " << opts.get<int>("bound") << endl;
         utils::exit_with(ExitCode::SEARCH_INPUT_ERROR);
@@ -62,11 +66,6 @@
 SearchEngine::~SearchEngine() {
 }
 
-void SearchEngine::print_statistics() const {
-    cout << "Bytes per state: "
-         << state_registry.get_state_size_in_bytes() << endl;
-}
-
 bool SearchEngine::found_solution() const {
     return solution_found;
 }
@@ -151,6 +150,7 @@
         "experiments. Timed-out searches are treated as failed searches, "
         "just like incomplete search algorithms that exhaust their search space.",
         "infinity");
+    utils::add_verbosity_option_to_parser(parser);
 }
 
 /* Method doesn't belong here because it's only useful for certain derived classes.
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_engine.h fast-downward/src/search/search_engine.h
--- fast-downward-original/src/search/search_engine.h	2020-07-09 18:54:18.968376100 -0300
+++ fast-downward/src/search/search_engine.h	2020-06-17 03:29:39.213928700 -0300
@@ -26,6 +26,10 @@
 class SuccessorGenerator;
 }
 
+namespace utils {
+enum class Verbosity;
+}
+
 enum SearchStatus {IN_PROGRESS, TIMEOUT, FAILED, SOLVED};
 
 class SearchEngine {
@@ -48,6 +52,7 @@
     OperatorCost cost_type;
     bool is_unit_cost;
     double max_time;
+    const utils::Verbosity verbosity;
 
     virtual void initialize() {}
     virtual SearchStatus step() = 0;
@@ -58,7 +63,7 @@
 public:
     SearchEngine(const options::Options &opts);
     virtual ~SearchEngine();
-    virtual void print_statistics() const;
+    virtual void print_statistics() const = 0;
     virtual void save_plan_if_necessary();
     bool found_solution() const;
     SearchStatus get_status() const;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_engines/eager_search.cc fast-downward/src/search/search_engines/eager_search.cc
--- fast-downward-original/src/search/search_engines/eager_search.cc	2020-07-09 18:54:18.970370900 -0300
+++ fast-downward/src/search/search_engines/eager_search.cc	2020-06-17 03:29:39.229550700 -0300
@@ -9,6 +9,8 @@
 #include "../algorithms/ordered_set.h"
 #include "../task_utils/successor_generator.h"
 
+#include "../utils/logging.h"
+
 #include <cassert>
 #include <cstdlib>
 #include <memory>
@@ -87,7 +89,7 @@
         cout << "Initial state is a dead end." << endl;
     } else {
         if (search_progress.check_progress(eval_context))
-            print_checkpoint_line(0);
+            statistics.print_checkpoint_line(0);
         start_f_value_statistics(eval_context);
         SearchNode node = search_space.get_node(initial_state);
         node.open_initial();
@@ -100,12 +102,6 @@
     pruning_method->initialize(task);
 }
 
-void EagerSearch::print_checkpoint_line(int g) const {
-    cout << "[g=" << g << ", ";
-    statistics.print_basic_statistics();
-    cout << "]" << endl;
-}
-
 void EagerSearch::print_statistics() const {
     statistics.print_detailed_statistics();
     search_space.print_statistics();
@@ -239,7 +235,7 @@
 
             open_list->insert(succ_eval_context, succ_state.get_id());
             if (search_progress.check_progress(succ_eval_context)) {
-                print_checkpoint_line(succ_node.get_g());
+                statistics.print_checkpoint_line(succ_node.get_g());
                 reward_progress();
             }
         } else if (succ_node.get_g() > node->get_g() + get_adjusted_cost(op)) {
@@ -315,4 +311,9 @@
         statistics.report_f_value_progress(f_value);
     }
 }
+
+void add_options_to_parser(OptionParser &parser) {
+    SearchEngine::add_pruning_option(parser);
+    SearchEngine::add_options_to_parser(parser);
+}
 }
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_engines/eager_search.h fast-downward/src/search/search_engines/eager_search.h
--- fast-downward-original/src/search/search_engines/eager_search.h	2020-07-09 18:54:18.972365200 -0300
+++ fast-downward/src/search/search_engines/eager_search.h	2020-06-17 03:29:39.229550700 -0300
@@ -11,6 +11,7 @@
 class PruningMethod;
 
 namespace options {
+class OptionParser;
 class Options;
 }
 
@@ -30,7 +31,6 @@
     void start_f_value_statistics(EvaluationContext &eval_context);
     void update_f_value_statistics(EvaluationContext &eval_context);
     void reward_progress();
-    void print_checkpoint_line(int g) const;
 
 protected:
     virtual void initialize() override;
@@ -44,6 +44,8 @@
 
     void dump_search_space() const;
 };
+
+extern void add_options_to_parser(options::OptionParser &parser);
 }
 
 #endif
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_engines/lazy_search.cc fast-downward/src/search/search_engines/lazy_search.cc
--- fast-downward-original/src/search/search_engines/lazy_search.cc	2020-07-09 18:54:18.977352100 -0300
+++ fast-downward/src/search/search_engines/lazy_search.cc	2020-06-17 03:29:39.229550700 -0300
@@ -173,7 +173,7 @@
             if (current_predecessor_id == StateID::no_state) {
                 node.open_initial();
                 if (search_progress.check_progress(current_eval_context))
-                    print_checkpoint_line(current_g);
+                    statistics.print_checkpoint_line(current_g);
             } else {
                 GlobalState parent_state = state_registry.lookup_state(current_predecessor_id);
                 SearchNode parent_node = search_space.get_node(parent_state);
@@ -189,7 +189,7 @@
             if (check_goal_and_set_plan(current_state))
                 return SOLVED;
             if (search_progress.check_progress(current_eval_context)) {
-                print_checkpoint_line(current_g);
+                statistics.print_checkpoint_line(current_g);
                 reward_progress();
             }
             generate_successors();
@@ -209,12 +209,6 @@
     open_list->boost_preferred();
 }
 
-void LazySearch::print_checkpoint_line(int g) const {
-    cout << "[g=" << g << ", ";
-    statistics.print_basic_statistics();
-    cout << "]" << endl;
-}
-
 void LazySearch::print_statistics() const {
     statistics.print_detailed_statistics();
     search_space.print_statistics();
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_engines/lazy_search.h fast-downward/src/search/search_engines/lazy_search.h
--- fast-downward-original/src/search/search_engines/lazy_search.h	2020-07-09 18:54:18.978349400 -0300
+++ fast-downward/src/search/search_engines/lazy_search.h	2020-06-17 03:29:39.213928700 -0300
@@ -51,9 +51,6 @@
     std::vector<OperatorID> get_successor_operators(
         const ordered_set::OrderedSet<OperatorID> &preferred_operators) const;
 
-    // TODO: Move into SearchEngine?
-    void print_checkpoint_line(int g) const;
-
 public:
     explicit LazySearch(const options::Options &opts);
     virtual ~LazySearch() = default;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_engines/plugin_astar.cc fast-downward/src/search/search_engines/plugin_astar.cc
--- fast-downward-original/src/search/search_engines/plugin_astar.cc	2020-07-09 18:54:18.980344200 -0300
+++ fast-downward/src/search/search_engines/plugin_astar.cc	2020-06-17 03:29:39.229550700 -0300
@@ -33,8 +33,7 @@
         "An evaluator that re-evaluates a state before it is expanded.",
         OptionParser::NONE);
 
-    SearchEngine::add_pruning_option(parser);
-    SearchEngine::add_options_to_parser(parser);
+    eager_search::add_options_to_parser(parser);
     Options opts = parser.parse();
 
     shared_ptr<eager_search::EagerSearch> engine;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_engines/plugin_eager.cc fast-downward/src/search/search_engines/plugin_eager.cc
--- fast-downward-original/src/search/search_engines/plugin_eager.cc	2020-07-09 18:54:18.982338800 -0300
+++ fast-downward/src/search/search_engines/plugin_eager.cc	2020-06-17 03:29:39.245172600 -0300
@@ -22,8 +22,7 @@
         "preferred",
         "use preferred operators of these evaluators", "[]");
 
-    SearchEngine::add_pruning_option(parser);
-    SearchEngine::add_options_to_parser(parser);
+    eager_search::add_options_to_parser(parser);
     Options opts = parser.parse();
 
     shared_ptr<eager_search::EagerSearch> engine;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_engines/plugin_eager_greedy.cc fast-downward/src/search/search_engines/plugin_eager_greedy.cc
--- fast-downward-original/src/search/search_engines/plugin_eager_greedy.cc	2020-07-09 18:54:18.983336100 -0300
+++ fast-downward/src/search/search_engines/plugin_eager_greedy.cc	2020-06-17 03:29:39.245172600 -0300
@@ -55,9 +55,7 @@
         "boost",
         "boost value for preferred operator open lists", "0");
 
-    SearchEngine::add_pruning_option(parser);
-    SearchEngine::add_options_to_parser(parser);
-
+    eager_search::add_options_to_parser(parser);
     Options opts = parser.parse();
     opts.verify_list_non_empty<shared_ptr<Evaluator>>("evals");
 
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_engines/plugin_eager_wastar.cc fast-downward/src/search/search_engines/plugin_eager_wastar.cc
--- fast-downward-original/src/search/search_engines/plugin_eager_wastar.cc	2020-07-09 18:54:18.985330800 -0300
+++ fast-downward/src/search/search_engines/plugin_eager_wastar.cc	2020-06-17 03:29:39.174011300 -0300
@@ -41,8 +41,7 @@
         "evaluator weight",
         "1");
 
-    SearchEngine::add_pruning_option(parser);
-    SearchEngine::add_options_to_parser(parser);
+    eager_search::add_options_to_parser(parser);
     Options opts = parser.parse();
 
     if (parser.dry_run()) {
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_progress.cc fast-downward/src/search/search_progress.cc
--- fast-downward-original/src/search/search_progress.cc	2020-07-09 18:54:18.987325400 -0300
+++ fast-downward/src/search/search_progress.cc	2020-06-17 03:29:39.175008800 -0300
@@ -3,11 +3,17 @@
 #include "evaluation_context.h"
 #include "evaluator.h"
 
+#include "../utils/logging.h"
+
 #include <iostream>
 #include <string>
 using namespace std;
 
 
+SearchProgress::SearchProgress(utils::Verbosity verbosity)
+    : verbosity(verbosity) {
+}
+
 bool SearchProgress::process_evaluator_value(const Evaluator *evaluator, int value) {
     /*
       Handle one evaluator value:
@@ -37,7 +43,8 @@
         [this, &boost](const Evaluator *eval, const EvaluationResult &result) {
             if (eval->is_used_for_reporting_minima() || eval->is_used_for_boosting()) {
                 if (process_evaluator_value(eval, result.get_evaluator_value())) {
-                    if (eval->is_used_for_reporting_minima()) {
+                    if (verbosity >= utils::Verbosity::NORMAL &&
+                        eval->is_used_for_reporting_minima()) {
                         eval->report_new_minimum_value(result);
                     }
                     if (eval->is_used_for_boosting()) {
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_progress.h fast-downward/src/search/search_progress.h
--- fast-downward-original/src/search/search_progress.h	2020-07-09 18:54:18.988322900 -0300
+++ fast-downward/src/search/search_progress.h	2020-06-17 03:29:39.198307900 -0300
@@ -6,6 +6,10 @@
 class EvaluationContext;
 class Evaluator;
 
+namespace utils {
+enum class Verbosity;
+}
+
 /*
   This class helps track search progress.
 
@@ -16,12 +20,13 @@
 
 
 class SearchProgress {
+    const utils::Verbosity verbosity;
     std::unordered_map<const Evaluator *, int> min_values;
 
     bool process_evaluator_value(const Evaluator *evaluator, int value);
 
 public:
-    SearchProgress() = default;
+    explicit SearchProgress(utils::Verbosity verbosity);
     ~SearchProgress() = default;
 
     /*
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_statistics.cc fast-downward/src/search/search_statistics.cc
--- fast-downward-original/src/search/search_statistics.cc	2020-07-09 18:54:18.991314700 -0300
+++ fast-downward/src/search/search_statistics.cc	2020-06-17 03:29:39.229550700 -0300
@@ -1,5 +1,6 @@
 #include "search_statistics.h"
 
+#include "utils/logging.h"
 #include "utils/timer.h"
 #include "utils/system.h"
 
@@ -8,7 +9,8 @@
 using namespace std;
 
 
-SearchStatistics::SearchStatistics() {
+SearchStatistics::SearchStatistics(utils::Verbosity verbosity)
+    : verbosity(verbosity) {
     expanded_states = 0;
     reopened_states = 0;
     evaluated_states = 0;
@@ -37,10 +39,20 @@
 }
 
 void SearchStatistics::print_f_line() const {
-    cout << "f = " << lastjump_f_value
-         << " [";
-    print_basic_statistics();
-    cout << "]" << endl;
+    if (verbosity >= utils::Verbosity::NORMAL) {
+        cout << "f = " << lastjump_f_value
+             << " [";
+        print_basic_statistics();
+        cout << "]" << endl;
+    }
+}
+
+void SearchStatistics::print_checkpoint_line(int g) const {
+    if (verbosity >= utils::Verbosity::NORMAL) {
+        cout << "[g=" << g << ", ";
+        print_basic_statistics();
+        cout << "]" << endl;
+    }
 }
 
 void SearchStatistics::print_basic_statistics() const {
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/search_statistics.h fast-downward/src/search/search_statistics.h
--- fast-downward-original/src/search/search_statistics.h	2020-07-09 18:54:18.992312000 -0300
+++ fast-downward/src/search/search_statistics.h	2020-06-17 03:29:39.229550700 -0300
@@ -9,7 +9,13 @@
   methods.
 */
 
+namespace utils {
+enum class Verbosity;
+}
+
 class SearchStatistics {
+    const utils::Verbosity verbosity;
+
     // General statistics
     int expanded_states;  // no states for which successors were generated
     int evaluated_states; // no states for which h fn was computed
@@ -29,7 +35,7 @@
 
     void print_f_line() const;
 public:
-    SearchStatistics();
+    explicit SearchStatistics(utils::Verbosity verbosity);
     ~SearchStatistics() = default;
 
     // Methods that update statistics.
@@ -66,6 +72,7 @@
       performed by the open list.)
     */
     void report_f_value_progress(int f);
+    void print_checkpoint_line(int g) const;
 
     // output
     void print_basic_statistics() const;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/utils/logging.cc fast-downward/src/search/utils/logging.cc
--- fast-downward-original/src/search/utils/logging.cc	2020-07-09 18:54:19.004317100 -0300
+++ fast-downward/src/search/utils/logging.cc	2020-06-17 03:29:39.260793300 -0300
@@ -3,6 +3,8 @@
 #include "system.h"
 #include "timer.h"
 
+#include "../option_parser.h"
+
 #include <iomanip>
 #include <iostream>
 #include <vector>
@@ -10,6 +12,29 @@
 using namespace std;
 
 namespace utils {
+void add_verbosity_option_to_parser(options::OptionParser &parser) {
+    vector<string> verbosity_levels;
+    vector<string> verbosity_level_docs;
+    verbosity_levels.push_back("silent");
+    verbosity_level_docs.push_back(
+        "only the most basic output");
+    verbosity_levels.push_back("normal");
+    verbosity_level_docs.push_back(
+        "relevant information to monitor progress");
+    verbosity_levels.push_back("verbose");
+    verbosity_level_docs.push_back(
+        "full output");
+    verbosity_levels.push_back("debug");
+    verbosity_level_docs.push_back(
+        "like full with additional debug output");
+    parser.add_enum_option(
+        "verbosity",
+        verbosity_levels,
+        "Option to specify the verbosity level.",
+        "normal",
+        verbosity_level_docs);
+}
+
 class MemoryTracer {
     // The following constants affect the formatting of output.
     static const int INDENT_AMOUNT = 2;
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/utils/logging.h fast-downward/src/search/utils/logging.h
--- fast-downward-original/src/search/utils/logging.h	2020-07-09 18:54:19.006275900 -0300
+++ fast-downward/src/search/utils/logging.h	2020-06-17 03:29:39.186977100 -0300
@@ -8,6 +8,10 @@
 #include <string>
 #include <vector>
 
+namespace options {
+class OptionParser;
+}
+
 namespace utils {
 /*
   Simple logger that prepends time and peak memory info to messages.
@@ -18,7 +22,7 @@
 */
 struct Log {
     template<typename T>
-    std::ostream &operator<<(const T &elem) {
+    std::ostream &operator<<(const T &elem) const {
         return std::cout << "[t=" << g_timer << ", "
                          << get_peak_memory_in_kb() << " KB] " << elem;
     }
@@ -26,6 +30,16 @@
 
 extern Log g_log;
 
+// See add_verbosity_option_to_parser for documentation.
+enum class Verbosity {
+    SILENT,
+    NORMAL,
+    VERBOSE,
+    DEBUG
+};
+
+extern void add_verbosity_option_to_parser(options::OptionParser &parser);
+
 class TraceBlock {
     std::string block_name;
 public:
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/template.pddl fast-downward/template.pddl
--- fast-downward-original/template.pddl	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/template.pddl	2020-07-09 16:16:05.689553000 -0300
@@ -0,0 +1,27 @@
+
+(define (problem blocks_words)
+	(:domain blocks)
+(:objects 
+
+D R A W O E P C - block
+)
+(:init
+(HANDEMPTY)
+(CLEAR O)
+(ONTABLE O)
+(CLEAR R)
+(ON R P)
+(ONTABLE P)
+(CLEAR E)
+(ONTABLE E)
+(CLEAR D)
+(ON D A)
+(ON A C)
+(ONTABLE C)
+(CLEAR W)
+(ONTABLE W)
+)
+(:goal (and
+(CLEAR D) (ONTABLE W) (ON D R) (ON R A) (ON A W)
+))
+)
