diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/DownwardFiles.cmake fast-downward/src/search/DownwardFiles.cmake
--- fast-downward-original/src/search/DownwardFiles.cmake	2020-08-28 09:53:49.771113400 -0300
+++ fast-downward/src/search/DownwardFiles.cmake	2020-10-15 00:04:09.776927900 -0300
@@ -703,6 +703,8 @@
         operator_counting/operator_counting_heuristic
         operator_counting/pho_constraints
         operator_counting/state_equation_constraints
+        operator_counting/delete_relaxation_constraints
+        operator_counting/oc_single_shot_heuristic
     DEPENDS LP_SOLVER LANDMARK_CUT_HEURISTIC PDBS TASK_PROPERTIES
 )
 
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/heuristics/lm_cut_landmarks.cc fast-downward/src/search/heuristics/lm_cut_landmarks.cc
--- fast-downward-original/src/search/heuristics/lm_cut_landmarks.cc	2020-08-28 09:53:47.994421700 -0300
+++ fast-downward/src/search/heuristics/lm_cut_landmarks.cc	2020-10-16 22:03:52.797295900 -0300
@@ -10,6 +10,60 @@
 
 namespace lm_cut_heuristic {
 // construction and destruction
+
+LandmarkCutLandmarks::LandmarkCutLandmarks(const TaskProxy &task_proxy, const vector<int> &observations) {
+    task_properties::verify_no_axioms(task_proxy);
+    task_properties::verify_no_conditional_effects(task_proxy);
+
+    // Build propositions.
+    num_propositions = 2; // artificial goal and artificial precondition
+    VariablesProxy variables = task_proxy.get_variables();
+    propositions.resize(variables.size());
+    for (FactProxy fact : variables.get_facts()) {
+        int var_id = fact.get_variable().get_id();
+        propositions[var_id].push_back(RelaxedProposition());
+        ++num_propositions;
+    }
+
+    // Build relaxed operators for operators and axioms.
+    for (OperatorProxy op : task_proxy.get_operators())
+        build_relaxed_operator(op);
+
+    // Simplify relaxed operators.
+    // simplify();
+    /* TODO: Put this back in and test if it makes sense,
+       but only after trying out whether and how much the change to
+       unary operators hurts. */
+
+    // Build artificial goal proposition and operator.
+    vector<RelaxedProposition *> goal_op_pre, goal_op_eff;
+    for (FactProxy goal : task_proxy.get_goals()) {
+        goal_op_pre.push_back(get_proposition(goal));
+    }
+    cout << "Observation preconditions: " << endl;
+    for (int op_id : observations) {
+        for (FactProxy f : task_proxy.get_operators()[op_id].get_preconditions()) {
+            RelaxedProposition *pre = get_proposition(f);
+            if (std::find(goal_op_pre.begin(), goal_op_pre.end(), pre) == goal_op_pre.end()) {
+                goal_op_pre.push_back(pre);
+                cout << f.get_name() << endl;
+            }
+        }
+    }
+    goal_op_eff.push_back(&artificial_goal);
+    /* Use the invalid operator ID -1 so accessing
+       the artificial operator will generate an error. */
+    add_relaxed_operator(move(goal_op_pre), move(goal_op_eff), -1, 0);
+
+    // Cross-reference relaxed operators.
+    for (RelaxedOperator &op : relaxed_operators) {
+        for (RelaxedProposition *pre : op.preconditions)
+            pre->precondition_of.push_back(&op);
+        for (RelaxedProposition *eff : op.effects)
+            eff->effect_of.push_back(&op);
+    }
+}
+
 LandmarkCutLandmarks::LandmarkCutLandmarks(const TaskProxy &task_proxy) {
     task_properties::verify_no_axioms(task_proxy);
     task_properties::verify_no_conditional_effects(task_proxy);
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/heuristics/lm_cut_landmarks.h fast-downward/src/search/heuristics/lm_cut_landmarks.h
--- fast-downward-original/src/search/heuristics/lm_cut_landmarks.h	2020-08-28 09:53:47.995418800 -0300
+++ fast-downward/src/search/heuristics/lm_cut_landmarks.h	2020-10-07 16:45:11.309799900 -0300
@@ -86,6 +86,7 @@
     using LandmarkCallback = std::function<void (const Landmark &, int)>;
 
     LandmarkCutLandmarks(const TaskProxy &task_proxy);
+    LandmarkCutLandmarks(const TaskProxy &task_proxy, const std::vector<int> &observations);
     virtual ~LandmarkCutLandmarks();
 
     /*
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/constraint_generator.cc fast-downward/src/search/operator_counting/constraint_generator.cc
--- fast-downward-original/src/search/operator_counting/constraint_generator.cc	2020-08-28 09:53:48.386358200 -0300
+++ fast-downward/src/search/operator_counting/constraint_generator.cc	2020-10-16 22:07:06.251407400 -0300
@@ -6,7 +6,11 @@
 
 namespace operator_counting {
 void ConstraintGenerator::initialize_constraints(
-    const shared_ptr<AbstractTask> &, vector<lp::LPConstraint> &, double) {
+    const shared_ptr<AbstractTask> &, vector<lp::LPVariable> &, vector<lp::LPConstraint> &, double) {
+}
+
+void ConstraintGenerator::set_observations(const vector<int>& observations) {
+	this->observations = observations;
 }
 
 static PluginTypePlugin<ConstraintGenerator> _type_plugin(
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/constraint_generator.h fast-downward/src/search/operator_counting/constraint_generator.h
--- fast-downward-original/src/search/operator_counting/constraint_generator.h	2020-08-28 09:53:48.386358200 -0300
+++ fast-downward/src/search/operator_counting/constraint_generator.h	2020-10-16 22:06:58.625402900 -0300
@@ -10,6 +10,12 @@
 namespace lp {
 class LPConstraint;
 class LPSolver;
+class LPVariable;
+}
+
+namespace options {
+class OptionParser;
+class Options;
 }
 
 namespace operator_counting {
@@ -27,10 +33,11 @@
       Example: constraints from landmarks generated for a given state, e.g.
       using the LM-Cut method.
 */
+
 class ConstraintGenerator {
 public:
+    std::vector<int> observations;
     virtual ~ConstraintGenerator() = default;
-
     /*
       Called upon initialization for the given task. Use this to add permanent
       constraints and perform other initialization. The parameter "infinity"
@@ -39,6 +46,7 @@
     */
     virtual void initialize_constraints(
         const std::shared_ptr<AbstractTask> &task,
+        std::vector<lp::LPVariable> &variables,
         std::vector<lp::LPConstraint> &constraints,
         double infinity);
 
@@ -51,6 +59,8 @@
     */
     virtual bool update_constraints(const State &state,
                                     lp::LPSolver &lp_solver) = 0;
+
+    void set_observations(const std::vector<int>& observations);
 };
 }
 
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/delete_relaxation_constraints.cc fast-downward/src/search/operator_counting/delete_relaxation_constraints.cc
--- fast-downward-original/src/search/operator_counting/delete_relaxation_constraints.cc	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/delete_relaxation_constraints.cc	2020-10-14 23:08:57.227471900 -0300
@@ -0,0 +1,252 @@
+#include "delete_relaxation_constraints.h"
+
+#include "../option_parser.h"
+#include "../plugin.h"
+
+#include "../task_proxy.h"
+
+#include "../lp/lp_solver.h"
+
+#include <cassert>
+
+using namespace std;
+
+namespace operator_counting {
+
+void add_lp_variables(int count,
+                      vector<lp::LPVariable> &variables, vector<int> &indices,
+                      double lower, double upper, double objective, bool is_integer) {
+    for (int i = 0; i < count; ++i) {
+        indices.push_back(variables.size());
+        variables.emplace_back(lower, upper, objective/*, is_integer*/);
+    }
+}
+
+
+DeleteRelaxationConstraints::DeleteRelaxationConstraints(const Options &opts)
+    : use_time_vars(opts.get<bool>("use_time_vars")),
+      use_integer_vars(opts.get<bool>("use_integer_vars")) {
+}
+
+
+int DeleteRelaxationConstraints::get_var_op_used(OperatorProxy op) {
+    return lp_var_id_op_used[op.get_id()];
+}
+
+int DeleteRelaxationConstraints::get_var_fact_reached(FactProxy f) {
+    return lp_var_id_fact_reached[f.get_variable().get_id()][f.get_value()];
+}
+
+int DeleteRelaxationConstraints::get_var_first_achiever(OperatorProxy op, FactProxy f) {
+    return lp_var_id_first_achiever[op.get_id()][f.get_variable().get_id()][f.get_value()];
+}
+
+int DeleteRelaxationConstraints::get_var_op_time(OperatorProxy op) {
+    return lp_var_id_op_time[op.get_id()];
+}
+
+int DeleteRelaxationConstraints::get_var_fact_time(FactProxy f) {
+    return lp_var_id_fact_time[f.get_variable().get_id()][f.get_value()];
+}
+
+int DeleteRelaxationConstraints::get_constraint_id(FactProxy f) {
+    return constraint_ids[f.get_variable().get_id()][f.get_value()];
+}
+
+void DeleteRelaxationConstraints::create_auxiliary_variables(
+    TaskProxy task_proxy, vector<lp::LPVariable> &variables) {
+    OperatorsProxy ops = task_proxy.get_operators();
+    int num_ops = ops.size();
+    VariablesProxy vars = task_proxy.get_variables();
+    int num_vars = vars.size();
+
+    // op_used
+    add_lp_variables(num_ops, variables, lp_var_id_op_used, 0, 1, 0, use_integer_vars);
+
+    // fact_reached
+    lp_var_id_fact_reached.resize(num_vars);
+    for (VariableProxy var : vars) {
+        add_lp_variables(var.get_domain_size(), variables,
+                         lp_var_id_fact_reached[var.get_id()],
+                         0, 1, 0, use_integer_vars);
+    }
+
+    // first_achiever
+    lp_var_id_first_achiever.resize(num_ops);
+    for (OperatorProxy op : ops) {
+        lp_var_id_first_achiever[op.get_id()].resize(num_vars);
+        for (VariableProxy var : vars) {
+            add_lp_variables(var.get_domain_size(), variables,
+                             lp_var_id_first_achiever[op.get_id()][var.get_id()],
+                             0, 1, 0, use_integer_vars);
+        }
+    }
+
+    if (use_time_vars) {
+        // op_time
+        add_lp_variables(num_ops, variables, lp_var_id_op_time, 0, num_ops, 0, use_integer_vars);
+
+        // fact_time
+        lp_var_id_fact_time.resize(num_vars);
+        for (VariableProxy var : vars) {
+            add_lp_variables(var.get_domain_size(), variables,
+                             lp_var_id_fact_time[var.get_id()],
+                             0, num_ops, 0, use_integer_vars);
+        }
+    }
+}
+
+void DeleteRelaxationConstraints::create_constraints(
+    TaskProxy task_proxy, vector<lp::LPVariable> &variables,
+    vector<lp::LPConstraint> &constraints, double infinity) {
+    OperatorsProxy ops = task_proxy.get_operators();
+    VariablesProxy vars = task_proxy.get_variables();
+
+    // All goal facts must be reached (handled in variable bound instead of constraint).
+    // R_f = 1 for all goal facts f.
+    for (FactProxy goal : task_proxy.get_goals()) {
+        variables[get_var_fact_reached(goal)].lower_bound = 1;
+    }
+
+    // A fact is reached if it has a first achiever or is true in the current state.
+    // sum_{o \in achievers(f)} F_{o,f} - R_f >= [s |= f] for each fact f.
+    constraint_ids.resize(vars.size());
+    for (VariableProxy var : vars) {
+        constraint_ids[var.get_id()].resize(var.get_domain_size());
+        for (int value = 0; value < var.get_domain_size(); ++value) {
+            constraint_ids[var.get_id()][value] = constraints.size();
+            constraints.emplace_back(0, infinity);
+            /* The constraint is:
+
+               We add "- R_f" here, collect the achiever below and adapt
+               the lower bound in each iteration, i.e., in update_constraints. */
+            constraints.back().insert(get_var_fact_reached(var.get_fact(value)), -1);
+
+        }
+    }
+    for (OperatorProxy op : ops) {
+        for (EffectProxy eff : op.get_effects()) {
+            FactProxy f = eff.get_fact();
+            lp::LPConstraint &constraint = constraints[get_constraint_id(f)];
+            constraint.insert(get_var_first_achiever(op, f), 1);
+        }
+    }
+
+    // If an operator is a first achiever, it must be used.
+    // U_o >= F_{o,f} for each operator o and each of its effects f.
+    for (OperatorProxy op : ops) {
+        for (EffectProxy eff : op.get_effects()) {
+            FactProxy f = eff.get_fact();
+            lp::LPConstraint constraint(0, infinity);
+            constraint.insert(get_var_op_used(op), 1);
+            constraint.insert(get_var_first_achiever(op, f), -1);
+            constraints.push_back(constraint);
+        }
+    }
+
+    // If an operator is used, its preconditions must be reached.
+    // R_f >= U_o for each operator o and each of its preconditions f.
+    for (OperatorProxy op : ops) {
+        for (FactProxy f : op.get_preconditions()) {
+            lp::LPConstraint constraint(0, infinity);
+            constraint.insert(get_var_fact_reached(f), 1);
+            constraint.insert(get_var_op_used(op), -1);
+            constraints.push_back(constraint);
+        }
+    }
+
+    if (use_time_vars) {
+        // Preconditions must be reached before the operator is used.
+        // T_f <= T_o for each operator o and each of its preconditions f.
+        for (OperatorProxy op : ops) {
+            for (FactProxy f : op.get_preconditions()) {
+                lp::LPConstraint constraint(0, infinity);
+                constraint.insert(get_var_op_time(op), 1);
+                constraint.insert(get_var_fact_time(f), -1);
+                constraints.push_back(constraint);
+            }
+        }
+
+        // New (add observations):
+        for (int i = 1; i < observations.size(); i++) {
+            OperatorProxy op0 = task_proxy.get_operators()[observations[i-1]];
+            OperatorProxy op1 = task_proxy.get_operators()[observations[i]];
+            lp::LPConstraint constraint(1, infinity);
+            constraint.insert(get_var_op_time(op0), -1);
+            constraint.insert(get_var_op_time(op1), 1);
+            constraints.push_back(constraint);
+        }
+
+        // If an operator is a first achiever, its effects are reached in the time step following its use.
+        // T_o + 1 <= T_f + M(1 - F_{o,f}) for each operator o and each of its effects f.
+        // <--->  1 - M <= T_f - T_o - M*F_{o,f} <= infty
+        int M = ops.size() + 1;
+        for (OperatorProxy op : ops) {
+            for (EffectProxy eff : op.get_effects()) {
+                FactProxy f = eff.get_fact();
+                lp::LPConstraint constraint(1-M, infinity);
+                constraint.insert(get_var_fact_time(f), 1);
+                constraint.insert(get_var_op_time(op), -1);
+                constraint.insert(get_var_first_achiever(op, f), -M);
+                constraints.push_back(constraint);
+            }
+        }
+    }
+
+    // If an operator is used, it must occur at least once.
+    // U_o <= C_o for each operator o.
+    for (OperatorProxy op : ops) {
+        lp::LPConstraint constraint(0, infinity);
+        constraint.insert(op.get_id(), 1);
+        constraint.insert(get_var_op_used(op), -1);
+        constraints.push_back(constraint);
+    }
+}
+
+
+void DeleteRelaxationConstraints::initialize_constraints(
+    const shared_ptr<AbstractTask> &task,
+    vector<lp::LPVariable> &variables, vector<lp::LPConstraint> &constraints,
+    double infinity) {
+    TaskProxy task_proxy(*task);
+    create_auxiliary_variables(task_proxy, variables);
+    create_constraints(task_proxy, variables, constraints, infinity);
+}
+
+
+bool DeleteRelaxationConstraints::update_constraints(const State &state,
+                                          lp::LPSolver &lp_solver) {
+    // Unset old bounds.
+    for (FactProxy f : last_state) {
+        lp_solver.set_constraint_lower_bound(get_constraint_id(f), 0);
+    }
+    last_state.clear();
+    // Set new bounds.
+    for (FactProxy f : state) {
+        lp_solver.set_constraint_lower_bound(get_constraint_id(f), -1);
+        last_state.push_back(f);
+    }
+    return false;
+}
+
+static shared_ptr<ConstraintGenerator> _parse(OptionParser &parser) {
+    parser.add_option<bool>(
+        "use_time_vars",
+        "use variables for time steps (setting this to false is the time relaxation by Imai and Fukunaga)",
+        "true"
+    );
+
+    parser.add_option<bool>(
+        "use_integer_vars",
+        "auxilliary variables will be restricted to integer values",
+        "false"
+    );
+    Options opts = parser.parse();
+
+    if (parser.dry_run())
+        return nullptr;
+    return make_shared<DeleteRelaxationConstraints>(opts);
+}
+
+static Plugin<ConstraintGenerator> _plugin("delete_relaxation_constraints", _parse);
+}
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/delete_relaxation_constraints.h fast-downward/src/search/operator_counting/delete_relaxation_constraints.h
--- fast-downward-original/src/search/operator_counting/delete_relaxation_constraints.h	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/delete_relaxation_constraints.h	2020-10-14 18:23:44.189328900 -0300
@@ -0,0 +1,69 @@
+#ifndef OPERATOR_COUNTING_DELETE_RELAXATION_CONSTRAINTS_H
+#define OPERATOR_COUNTING_DELETE_RELAXATION_CONSTRAINTS_H
+
+#include  "constraint_generator.h"
+
+#include "../task_proxy.h"
+#include "../lp/lp_solver.h"
+
+#include <memory>
+
+namespace options {
+class Options;
+}
+
+namespace operator_counting {
+class DeleteRelaxationConstraints : public ConstraintGenerator {
+    bool use_time_vars;
+    bool use_integer_vars;
+
+    // [U_o] Is op part of the relaxed plan? Binary, indexed with op.id.
+    std::vector<int> lp_var_id_op_used;
+
+    // [R_f] Is fact <V,v> reached by the relaxed plan? Binary, indexed with var.id, value
+    std::vector<std::vector<int>> lp_var_id_fact_reached;
+
+    // [F_{o,f}] Is o the first achiever of fact <V,v> in the relaxed plan? Binary, indexed with op.id, var.id, value
+    std::vector<std::vector<std::vector<int>>> lp_var_id_first_achiever;
+
+    // [T_o] At what time is o used first? {0, ..., |O|}, indexed with op.id
+    std::vector<int> lp_var_id_op_time;
+
+    // [T_f] At what time is <V,v> first achieved? {0, ..., |O|}, indexed with var.id, value
+    std::vector<std::vector<int>> lp_var_id_fact_time;
+
+    // Indices of constraints that change in every state (indexed with var.id, value)
+    std::vector<std::vector<int>> constraint_ids;
+
+    // The state that is currently used for setting the bounds.
+    // Remembering this makes it faster to unset the bounds when the state changes.
+    std::vector<FactProxy> last_state;
+
+    int get_var_op_used(OperatorProxy op);
+    int get_var_fact_reached(FactProxy f);
+    int get_var_first_achiever(OperatorProxy op, FactProxy f);
+    int get_var_op_time(OperatorProxy op);
+    int get_var_fact_time(FactProxy f);
+
+    int get_constraint_id(FactProxy f);
+
+    void create_auxiliary_variables(TaskProxy task_proxy,
+                                    std::vector<lp::LPVariable> &variables);
+    void create_constraints(TaskProxy task_proxy,
+                            std::vector<lp::LPVariable> &variables,
+                            std::vector<lp::LPConstraint> &constraints,
+                            double infinity);
+public:
+    DeleteRelaxationConstraints(const options::Options &opts);
+
+    virtual void initialize_constraints(
+        const std::shared_ptr<AbstractTask> &task,
+        std::vector<lp::LPVariable> &variables,
+        std::vector<lp::LPConstraint> &constraints,
+        double infinity) override;
+    virtual bool update_constraints(const State &state,
+                                    lp::LPSolver &lp_solver) override;
+};
+}
+
+#endif
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/lm_cut_constraints.cc fast-downward/src/search/operator_counting/lm_cut_constraints.cc
--- fast-downward-original/src/search/operator_counting/lm_cut_constraints.cc	2020-08-28 09:53:48.387355400 -0300
+++ fast-downward/src/search/operator_counting/lm_cut_constraints.cc	2020-10-16 22:06:34.107410600 -0300
@@ -16,11 +16,12 @@
 
 namespace operator_counting {
 void LMCutConstraints::initialize_constraints(
-    const shared_ptr<AbstractTask> &task, vector<lp::LPConstraint> & /*constraints*/,
+    const shared_ptr<AbstractTask> & task, 
+    vector<lp::LPVariable> & /*variables*/,
+    vector<lp::LPConstraint> & /*constraints*/,
     double /*infinity*/) {
     TaskProxy task_proxy(*task);
-    landmark_generator =
-        utils::make_unique_ptr<lm_cut_heuristic::LandmarkCutLandmarks>(task_proxy);
+    landmark_generator = utils::make_unique_ptr<lm_cut_heuristic::LandmarkCutLandmarks>(task_proxy);
 }
 
 
@@ -29,23 +30,44 @@
     assert(landmark_generator);
     vector<lp::LPConstraint> constraints;
     double infinity = lp_solver.get_infinity();
-
+    TaskProxy task_proxy = state.get_task();
+    
     bool dead_end = landmark_generator->compute_landmarks(
         state, nullptr,
         [&](const vector<int> &op_ids, int /*cost*/) {
+            cout << "Landmarks: " << endl;
             constraints.emplace_back(1.0, infinity);
             lp::LPConstraint &landmark_constraint = constraints.back();
             for (int op_id : op_ids) {
+                cout << op_id << " - " << task_proxy.get_operators()[op_id].get_name() << endl;
                 landmark_constraint.insert(op_id, 1.0);
             }
         });
-
-    if (dead_end) {
+    if (dead_end)
         return true;
-    } else {
-        lp_solver.add_temporary_constraints(constraints);
-        return false;
+
+    for (int obs_id : observations) {
+        vector<int> obs;
+        obs.push_back(obs_id);
+        landmark_generator = utils::make_unique_ptr<lm_cut_heuristic::LandmarkCutLandmarks>(task_proxy, obs);
+
+        dead_end = landmark_generator->compute_landmarks(
+            state, nullptr,
+            [&](const vector<int> &op_ids, int /*cost*/) {
+                cout << "Landmarks: " << endl;
+                constraints.emplace_back(1.0, infinity);
+                lp::LPConstraint &landmark_constraint = constraints.back();
+                for (int op_id : op_ids) {
+                    cout << op_id << " - " << task_proxy.get_operators()[op_id].get_name() << endl;
+                    landmark_constraint.insert(op_id, 1.0);
+                }
+            });
+        if (dead_end)
+            return true;
     }
+
+    lp_solver.add_temporary_constraints(constraints);
+    return false;
 }
 
 static shared_ptr<ConstraintGenerator> _parse(OptionParser &parser) {
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/lm_cut_constraints.h fast-downward/src/search/operator_counting/lm_cut_constraints.h
--- fast-downward-original/src/search/operator_counting/lm_cut_constraints.h	2020-08-28 09:53:48.387355400 -0300
+++ fast-downward/src/search/operator_counting/lm_cut_constraints.h	2020-10-16 22:06:39.033101300 -0300
@@ -15,6 +15,7 @@
 public:
     virtual void initialize_constraints(
         const std::shared_ptr<AbstractTask> &task,
+        std::vector<lp::LPVariable> & /*variables*/,
         std::vector<lp::LPConstraint> &constraints,
         double infinity) override;
     virtual bool update_constraints(const State &state,
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.cc fast-downward/src/search/operator_counting/oc_single_shot_heuristic.cc
--- fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.cc	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/oc_single_shot_heuristic.cc	2020-10-14 22:05:06.144983800 -0300
@@ -0,0 +1,480 @@
+#include "oc_single_shot_heuristic.h"
+
+#include "constraint_generator.h"
+
+#include "../option_parser.h"
+#include "../plugin.h"
+
+#include "../utils/markup.h"
+
+#include <cmath>
+#include <fstream>
+#include <algorithm>
+#include <cctype>
+#include <locale>
+
+using namespace std;
+
+// trim from start (in place)
+static inline void ltrim(std::string &s) {
+    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
+        return !std::isspace(ch);
+    }));
+}
+
+// trim from end (in place)
+static inline void rtrim(std::string &s) {
+    s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
+        return !std::isspace(ch);
+    }).base(), s.end());
+}
+
+// trim from both ends (in place)
+static inline void trim(std::string &s) {
+    ltrim(s);
+    rtrim(s);
+}
+
+using namespace std;
+
+namespace operator_counting {
+
+utils::Timer lp_timer;
+
+OCSingleShotHeuristic::OCSingleShotHeuristic(const Options &opts)
+    : Heuristic(opts),
+      constraint_generators(
+          opts.get_list<shared_ptr<ConstraintGenerator>>("constraint_generators")),
+      lp_h(opts.get<lp::LPSolverType>("lpsolver")),
+      lp_h_c(opts.get<lp::LPSolverType>("lpsolver")),
+      lp_h_s(opts.get<lp::LPSolverType>("lpsolver")),
+      calculate_h(opts.get<bool>("calculate_h")),
+      calculate_h_c(opts.get<bool>("calculate_h_c")),
+      calculate_h_s(opts.get<bool>("calculate_h_s")),
+      filter(opts.get<int>("filter")),
+      h_obs(opts.get<bool>("h_obs")),
+      soft_weight(opts.get<int>("weights")) {
+    // Initialize map to convert operator name to operator ID
+    map_operators(true);
+    // Read observations from file and prune invalid
+    load_observations();
+    prune_observations();
+    // Start timer
+    lp_timer.reset();
+    lp_timer.resume();
+}
+
+void OCSingleShotHeuristic::add_observation_variables(vector<lp::LPVariable> &variables, vector<lp::LPConstraint> &constraints) {
+    double infinity = lp_h.get_infinity();
+    if (!h_obs && !calculate_h)
+        for (const auto &generator : constraint_generators)
+            generator->initialize_constraints(task, variables, constraints, infinity);
+    // Create observation variables
+    for (auto it = valid_obs_occurrences.begin(); it != valid_obs_occurrences.end(); ++it) {
+        // Determine how many times the same observed operation occurs.
+        string op = it->first;
+        int count_obs = it->second;
+        cout << "constraint " << op << ": " << std::to_string(op_indexes[op]) << endl;
+        int var_id = variables.size();
+        variables.push_back(lp::LPVariable(0, count_obs, -weights[op]));
+        lp::LPConstraint lt_y(0, infinity);
+        lt_y.insert(op_indexes[op], 1);
+        lt_y.insert(var_id, -1);
+        constraints.push_back(lt_y);
+    }
+}
+
+void OCSingleShotHeuristic::add_observation_hard_constraint(vector<lp::LPVariable> &variables, vector<lp::LPConstraint> &constraints) {
+    double infinity = lp_h.get_infinity();
+    int filter = (int)(this->filter * 0.1 * observations.size());
+    int k = max(0, filter - num_pruned_observations);
+    lp::LPConstraint constraint(num_valid_observations - k, infinity);
+    int var_id = variables.size() - 1;
+    for (auto it = valid_obs_occurrences.begin(); it != valid_obs_occurrences.end(); ++it) {
+        constraint.insert(var_id, 1);
+        variables[var_id].objective_coefficient = 0;
+        var_id--;
+    }
+    constraints.push_back(constraint);
+}
+
+void OCSingleShotHeuristic::set_variable_weights() {
+    if (soft_weight == 1) {
+        double weight_per_op = 1.0 / 1000;
+        for (auto it = observations.begin(); it != observations.end(); ++it)
+            if (op_indexes.find(*it) != op_indexes.end())
+                weights[*it] = weight_per_op;
+    } else if (soft_weight == 2) {
+        double weight_per_op = 1.0;
+        for (auto it = observations.begin(); it != observations.end(); ++it)
+            if (op_indexes.find(*it) != op_indexes.end())
+                weights[*it] = weight_per_op;
+    } else if (soft_weight == 3) {
+        double weight_per_op = 1.0;
+        double weight = weight_per_op;
+        for (auto it = observations.begin(); it != observations.end(); ++it) {
+            if (op_indexes.find(*it) != op_indexes.end()) {
+                max_weight += weight;
+                weights[*it] += weight;
+                weight += weight_per_op;
+            }
+        }
+        for (auto it = obs_occurrences.begin(); it != obs_occurrences.end(); ++it)
+            weights[it->first] /= it->second;
+    }
+}
+
+void OCSingleShotHeuristic::map_operators(bool show) {
+    if (show) {
+        cout << endl << string(80, '*') << endl;
+        cout << "# Mapping X -> op: " << endl;
+    }
+    int i = 0;
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        // Caching operator variable indexes
+        std::string op_name (op.get_name());
+        for (size_t i = 0; i< op.get_name().size(); ++i) {
+            op_name[i] = tolower(op_name.c_str()[i]);
+        }
+        op_indexes[op_name] = i;
+        if (show) {
+            cout << "["<< op_name<< "]: " << op_indexes[op_name] << endl;
+        }
+        i++;
+    }
+    if (show) {
+        cout << string(80, '*') << endl;
+    }
+}
+
+void OCSingleShotHeuristic::show_variables_and_objective(const vector<lp::LPVariable> &variables) {
+    cout << endl << string(80, '*') << endl;
+    cout << "# Variables(" << variables.size() << "): " << endl;
+    for (int i = 0; i < (int) variables.size(); ++i) {
+        cout << "X[" << i << "] = Variable('X_" << i << "'";
+        cout << ", lb=" << variables[i].lower_bound;
+        cout << ", ub=" << variables[i].upper_bound;
+        cout << ", cost[" << i << "] = " << variables[i].objective_coefficient << endl;
+    }
+    cout << string(80, '*') << endl;
+    cout << endl << string(80, '*') << endl;
+    cout << "# Objective function: " << endl;
+    cout << "obj = Objective(";
+    for (int i = 0; i < (int) variables.size(); ++i) {
+        cout << "cost[" << i << "] * X[" << i << "]";
+        if (i < (int) variables.size() - 1) {
+            cout << " + ";
+        }
+    }
+    cout << ", direction='min')" << endl;
+    cout << string(80, '*') << endl;
+}
+
+void OCSingleShotHeuristic::load_observations() {
+    // Read observations from file
+    cout << endl << string(80, '*') << endl;
+    cout << std::endl << "Load observations" << std::endl;
+    ifstream obs_file;
+    obs_file.open("obs.dat");
+    if(obs_file.is_open()){
+        while(!obs_file.eof()) {
+            string obs;
+            getline(obs_file, obs);
+            trim(obs);
+            if(!obs.empty() && obs[0]!=';') {
+                obs = obs.substr(1,obs.length()-2);
+                std::string obs_name (obs);
+                for (size_t i = 0; i< obs.size(); ++i) {
+                    obs_name[i] = tolower(obs.c_str()[i]);
+                }
+                cout << "Observation: " << obs_name << endl;
+                observations.push_back(obs_name);
+            }
+        }
+    }
+    cout << endl << string(80, '*') << endl;
+    obs_file.close();
+    // =-=-=-=-= Each observation is associated with its number of occurrences. =-=-=-=-= //
+    obs_occurrences.clear();
+    for(auto it = observations.begin() ; it != observations.end(); ++it) {
+        obs_occurrences[*it]++;
+    }
+}
+
+void OCSingleShotHeuristic::prune_observations() { 
+    // Debugging output (cumulative: appends new info with each call)
+    std::fstream outfile("debug/observation_sanity.txt", std::ios::out|std::ios::app) ;
+    // Set output stream (set to std::cout to print to terminal)
+    std::ostream& outstream = outfile;
+    // Reinitialize class variables for invalid (unmapped) observations.
+    num_pruned_observations = 0;
+    pruned_observations.clear();
+    valid_obs_occurrences.clear();
+    vector<string> invalid_operators;
+    int num_invalid_operators = 0;
+    //outstream << endl << string(80, '*') << endl;
+    //outstream << "Enforcing observation constraints" << std::endl;
+    outstream << endl<< "-+-"; // marks start
+    for (auto it = obs_occurrences.begin(); it != obs_occurrences.end(); ++it) {
+        // Observation is mappable?
+        // If not: ignore observation, storing it in a separate list.
+        if (op_indexes.find(it->first) == op_indexes.end()) {
+            //outstream << "[INVALID OP] " << op << endl;
+            invalid_operators.push_back(it->first);
+            num_invalid_operators += 1;
+            num_pruned_observations += it->second;
+        } else {
+            valid_obs_occurrences[it->first] = it->second;
+            num_valid_observations += it->second;
+        }
+    }
+    // =-=-=-=-= Report on pruned and invalid operators/observations. =-=-=-=-= //
+    // Basic structure:
+    // Print invalid observations, number of operators and total number of observations.
+    // Last line holds number of observations and number of invalid observations,
+    //  followed by any relevant tags.
+    for (int i = 0 ; i < num_invalid_operators; i++) {
+        outstream << endl<< "[INVALID OP] " << invalid_operators[i] << ": " << obs_occurrences[invalid_operators[i]] <<" time(s).";
+    }
+    if (num_pruned_observations > 0) {
+        outstream << endl << "# mappable operators: " << op_indexes.size() << endl;
+        outstream << "Obs - Total: " << observations.size() << " | Invalid: " << num_pruned_observations;
+    }
+    outfile.flush();
+    outfile.close();
+}
+
+int OCSingleShotHeuristic::compute_heuristic(const GlobalState &global_state) {
+    State state = convert_global_state(global_state);
+    return compute_heuristic(state);
+}
+
+int OCSingleShotHeuristic::compute_heuristic(const State &state) {
+    double infinity = lp_h.get_infinity();
+
+    // Create operator variables
+    vector<lp::LPVariable> variables;
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        variables.push_back(lp::LPVariable(0, infinity, op.get_cost()));
+    }
+
+    // Constraints
+    vector<lp::LPConstraint> constraints;
+
+    // Results
+    double result = 0 / 0, result_c = 0 / 0, result_s = 0 / 0;
+
+    // Compute LP problem without observation constraints
+    if (calculate_h) {
+        // Initialize LP
+        for (const auto &generator : constraint_generators)
+            generator->initialize_constraints(task, variables, constraints, infinity);
+        lp_h.load_problem(lp::LPObjectiveSense::MINIMIZE, variables, constraints);
+        cout << "Loaded basic problem." << endl;
+        // Update constraints
+        for (const auto &generator : constraint_generators) {
+            if (generator->update_constraints(state, lp_h)) {
+                lp_h.clear_temporary_constraints();
+                calculate_h = false;
+                break;
+            }
+        }
+        // Compute result
+        if (calculate_h) {
+            lp_h.solve();
+            if (lp_h.has_optimal_solution()) {
+                double epsilon = 0.01;
+                double objective_value = lp_h.get_objective_value();
+                result = ceil(objective_value - epsilon);
+            }
+        }
+        cout << "h: " << result << endl;
+    }
+
+    if (h_obs) {
+        // Re-initialize constraints using observations
+        vector<int> observation_ids;
+        for (const string &obs : observations)
+            if (op_indexes.find(obs) != op_indexes.end())
+                observation_ids.push_back(op_indexes[obs]);
+        constraints.clear();
+        for (const auto &generator : constraint_generators) {
+            generator->set_observations(observation_ids);
+            generator->initialize_constraints(task, variables, constraints, infinity);
+        }
+    }
+
+    // Compute LP problem with soft observation constraints
+    if (calculate_h_s) {
+        // Initialize LP
+        set_variable_weights();
+        add_observation_variables(variables, constraints);
+        lp_h_s.load_problem(lp::LPObjectiveSense::MINIMIZE, variables, constraints);
+        cout << "Loaded problem with soft constraints." << endl;
+        // Update constraints
+        for (const auto &generator : constraint_generators) {
+            if (generator->update_constraints(state, lp_h_s)) {
+                lp_h_s.clear_temporary_constraints();
+                calculate_h_s = false;
+            }
+        }
+        // Compute result
+        if (calculate_h_s) {
+            lp_h_s.solve();
+            if (lp_h_s.has_optimal_solution()) {
+                double epsilon = 0.01;
+                double objective_value = lp_h_s.get_objective_value();
+                result_s = ceil(objective_value - epsilon) + max_weight;
+            }
+        }
+        cout << "h_s: " << result_s << endl;
+    }
+    
+    // Compute LP problem with hard observation constraints
+    if (calculate_h_c) {
+        if (!calculate_h_s) 
+            add_observation_variables(variables, constraints);
+        add_observation_hard_constraint(variables, constraints);
+        lp_h_c.load_problem(lp::LPObjectiveSense::MINIMIZE, variables, constraints);
+        cout << "Loaded problem with hard constraints." << endl;
+        // Update constraints
+        for (const auto &generator : constraint_generators) {
+            if (generator->update_constraints(state, lp_h_c)) {
+                lp_h_c.clear_temporary_constraints();
+                calculate_h_c = false;
+            }
+        }
+        // Compute LP
+        if (calculate_h_c) {
+            lp_h_c.solve();
+            if (lp_h_c.has_optimal_solution()) {
+                double epsilon = 0.01;
+                double objective_value = lp_h_c.get_objective_value();
+                result_c = ceil(objective_value - epsilon);
+            }
+        }
+        cout << "h_c: " << result_c << endl;
+    }
+
+    lp_timer.stop();
+    output_results(result, result_c, result_s);
+
+    exit(EXIT_SUCCESS);
+    return 0;
+}
+
+void OCSingleShotHeuristic::output_results(double result, double result_c, double result_s) {
+    // Log solutions
+    cout << "Writing solutions..." << endl;
+    cout << endl << string(80, '*') << endl;
+    vector<double> solution;
+    if (calculate_h_s)
+        solution = lp_h_s.extract_solution();
+    else if (calculate_h_c)
+        solution = lp_h_c.extract_solution();
+    else
+        solution = lp_h.extract_solution();
+    for (int i = 0; i < (int) solution.size(); ++i) {
+        cout << "X[" << i << "] = " << solution[i] << endl;
+    }
+    // Get hits/misses
+    double obs_hits = 0, obs_miss = 0;
+    unordered_map<string, double> counts;
+    for(auto it = observations.begin() ; it != observations.end(); ++it) {
+        if (op_indexes.find(*it) != op_indexes.end()) {
+            if (solution[op_indexes[*it]] > counts[*it]) {
+                obs_hits++;
+                counts[*it]++;
+            } else {
+                obs_miss++;
+            }
+        }
+    }
+    cout << "obs-report: " << observations.size() << " " << num_pruned_observations << " " << obs_hits << " " << obs_miss << endl;
+    cout << "time-report: " << lp_timer << endl;
+    cout << "h-values: " << result << " " << result_c << " " << result_s << endl;
+    cout << string(80, '*') << endl << endl;
+    // Write result
+    cout << "Writing results...";
+    ofstream results;
+    results.open("ocsingleshot_heuristic_result.dat");
+    results << "obs-report: " << observations.size() << " " << num_pruned_observations << " " << obs_hits << " " << obs_miss << endl;
+    results << "time-report: " << lp_timer << endl;
+    results << "h-values: " << result << " " << result_c << " " << result_s << endl;
+    // Write counts
+    int var_i = 0;
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        if (solution[var_i] > 0) {
+            results << "(" << op.get_name() << ") = " << solution[var_i] << endl;
+        }
+        var_i++;
+    }
+    results.flush();
+    results.close();
+    cout << "Done!" << endl;
+}
+
+OCSingleShotHeuristic::~OCSingleShotHeuristic() {
+}
+
+static shared_ptr<Heuristic> _parse(OptionParser &parser) {
+    parser.document_synopsis(
+        "Operator counting heuristic",
+        "An operator counting heuristic computes a linear program (LP) in each "
+        "state. The LP has one variable Count_o for each operator o that "
+        "represents how often the operator is used in a plan. Operator "
+        "counting constraints are linear constraints over these varaibles that "
+        "are guaranteed to have a solution with Count_o = occurrences(o, pi) "
+        "for every plan pi. Minimizing the total cost of operators subject to "
+        "some operator counting constraints is an admissible heuristic. "
+        "For details, see" + utils::format_conference_reference( // TODO - Change this for our paper
+            {"Florian Pommerening", "Gabriele Roeger", "Malte Helmert",
+             "Blai Bonet"},
+            "LP-based Heuristics for Cost-optimal Planning",
+            "http://www.aaai.org/ocs/index.php/ICAPS/ICAPS14/paper/view/7892/8031",
+            "Proceedings of the Twenty-Fourth International Conference"
+            " on Automated Planning and Scheduling (ICAPS 2014)",
+            "226-234",
+            "AAAI Press",
+            "2014"));
+
+    parser.document_language_support("action costs", "supported");
+    parser.document_language_support(
+        "conditional effects",
+        "not supported (the heuristic supports them in theory, but none of "
+        "the currently implemented constraint generators do)");
+    parser.document_language_support(
+        "axioms",
+        "not supported (the heuristic supports them in theory, but none of "
+        "the currently implemented constraint generators do)");
+    parser.document_property("admissible", "yes");
+    parser.document_property(
+        "consistent",
+        "yes, if all constraint generators represent consistent heuristics");
+    parser.document_property("safe", "yes");
+    // TODO: prefer operators that are non-zero in the solution.
+    parser.document_property("preferred operators", "no");
+
+    parser.add_list_option<shared_ptr<ConstraintGenerator>>(
+        "constraint_generators",
+        "methods that generate constraints over operator counting variables");
+    parser.add_option<bool>("calculate_h", "calculate h-value", "true");
+    parser.add_option<bool>("calculate_h_c", "calculate h-value with hard observation constraints", "true");
+    parser.add_option<bool>("calculate_h_s", "calculate h-value with soft observation constraints", "true");
+    parser.add_option<int>("weights", "weight type for soft constraints", "1");
+    parser.add_option<int>("filter", "observation filter", "0");
+    parser.add_option<bool>("h_obs", "enable observations inside heuristic constraints", "false");
+    lp::add_lp_solver_option_to_parser(parser);
+    Heuristic::add_options_to_parser(parser);
+    Options opts = parser.parse();
+    if (parser.help_mode())
+        return nullptr;
+    opts.verify_list_non_empty<shared_ptr<ConstraintGenerator>>(
+        "constraint_generators");
+    if (parser.dry_run())
+        return nullptr;
+    return make_shared<OCSingleShotHeuristic>(opts);
+}
+
+static Plugin<Evaluator> _plugin("ocsingleshot", _parse);
+}
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.h fast-downward/src/search/operator_counting/oc_single_shot_heuristic.h
--- fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.h	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/oc_single_shot_heuristic.h	2020-10-13 15:55:08.042282500 -0300
@@ -0,0 +1,58 @@
+#ifndef OPERATOR_COUNTING_OPERATOR_COUNTING_HEURISTIC_H
+#define OPERATOR_COUNTING_OPERATOR_COUNTING_HEURISTIC_H
+
+#include "../heuristic.h"
+
+#include "../lp/lp_solver.h"
+
+#include <memory>
+#include <vector>
+#include <string>
+#include <unordered_map>
+
+namespace options {
+class Options;
+}
+
+namespace operator_counting {
+class ConstraintGenerator;
+
+class OCSingleShotHeuristic : public Heuristic {
+    std::vector<std::shared_ptr<ConstraintGenerator>> constraint_generators;
+    lp::LPSolver lp_h;
+    lp::LPSolver lp_h_c;
+    lp::LPSolver lp_h_s;
+    bool calculate_h, calculate_h_c, calculate_h_s;
+    int filter;
+    bool h_obs;
+
+    std::unordered_map<std::string,int> op_indexes;
+    std::vector<std::string> observations;
+    std::vector<std::string> pruned_observations;
+    std::unordered_map<std::string, int> obs_occurrences;
+    std::unordered_map<std::string, int> valid_obs_occurrences;
+    int num_pruned_observations = 0;
+    int num_valid_observations = 0;
+
+    int soft_weight;
+    std::unordered_map<std::string, double> weights;
+    double max_weight = 0;
+
+protected:
+    virtual int compute_heuristic(const GlobalState &global_state) override;
+    int compute_heuristic(const State &state);
+    void load_observations();
+    void prune_observations();
+    void add_observation_variables(std::vector<lp::LPVariable> &variables, std::vector<lp::LPConstraint> &constraints);
+    void add_observation_hard_constraint(std::vector<lp::LPVariable> &variables, std::vector<lp::LPConstraint> &constraints);
+    void set_variable_weights();
+    void output_results(double result, double result_c, double result_s);
+public:
+    explicit OCSingleShotHeuristic(const options::Options &opts);
+    ~OCSingleShotHeuristic();
+    void map_operators(bool show = false);
+    void show_variables_and_objective(const std::vector<lp::LPVariable> &variables);
+};
+}
+
+#endif
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/operator_counting_heuristic.cc fast-downward/src/search/operator_counting/operator_counting_heuristic.cc
--- fast-downward-original/src/search/operator_counting/operator_counting_heuristic.cc	2020-08-28 09:53:48.389350400 -0300
+++ fast-downward/src/search/operator_counting/operator_counting_heuristic.cc	2020-10-14 18:15:01.118855100 -0300
@@ -25,7 +25,7 @@
     }
     vector<lp::LPConstraint> constraints;
     for (const auto &generator : constraint_generators) {
-        generator->initialize_constraints(task, constraints, infinity);
+        generator->initialize_constraints(task, variables, constraints, infinity);
     }
     lp_solver.load_problem(lp::LPObjectiveSense::MINIMIZE, variables, constraints);
 }
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/pho_constraints.cc fast-downward/src/search/operator_counting/pho_constraints.cc
--- fast-downward-original/src/search/operator_counting/pho_constraints.cc	2020-08-28 09:53:48.390751100 -0300
+++ fast-downward/src/search/operator_counting/pho_constraints.cc	2020-10-14 18:16:29.884860900 -0300
@@ -25,6 +25,7 @@
 
 void PhOConstraints::initialize_constraints(
     const shared_ptr<AbstractTask> &task,
+    vector<lp::LPVariable> & /*variables*/,
     vector<lp::LPConstraint> &constraints,
     double infinity) {
     assert(pattern_generator);
@@ -36,7 +37,7 @@
       create pattern_generator locally and no longer need to explicitly reset
       it.
     */
-    pattern_generator = nullptr;
+    //pattern_generator = nullptr;
     pdbs = pattern_collection_info.get_pdbs();
     TaskProxy task_proxy(*task);
     constraint_offset = constraints.size();
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/pho_constraints.h fast-downward/src/search/operator_counting/pho_constraints.h
--- fast-downward-original/src/search/operator_counting/pho_constraints.h	2020-08-28 09:53:48.391752900 -0300
+++ fast-downward/src/search/operator_counting/pho_constraints.h	2020-10-14 18:25:32.069681700 -0300
@@ -26,6 +26,7 @@
 
     virtual void initialize_constraints(
         const std::shared_ptr<AbstractTask> &task,
+        std::vector<lp::LPVariable> & /*variables*/,
         std::vector<lp::LPConstraint> &constraints,
         double infinity) override;
     virtual bool update_constraints(
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/state_equation_constraints.cc fast-downward/src/search/operator_counting/state_equation_constraints.cc
--- fast-downward-original/src/search/operator_counting/state_equation_constraints.cc	2020-08-28 09:53:48.391752900 -0300
+++ fast-downward/src/search/operator_counting/state_equation_constraints.cc	2020-10-14 18:16:47.117625500 -0300
@@ -68,7 +68,9 @@
 }
 
 void StateEquationConstraints::initialize_constraints(
-    const shared_ptr<AbstractTask> &task, vector<lp::LPConstraint> &constraints,
+    const shared_ptr<AbstractTask> &task, 
+    vector<lp::LPVariable> & /*variables*/,
+    vector<lp::LPConstraint> &constraints,
     double infinity) {
     utils::g_log << "Initializing constraints from state equation." << endl;
     TaskProxy task_proxy(*task);
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/state_equation_constraints.h fast-downward/src/search/operator_counting/state_equation_constraints.h
--- fast-downward-original/src/search/operator_counting/state_equation_constraints.h	2020-08-28 09:53:48.392747100 -0300
+++ fast-downward/src/search/operator_counting/state_equation_constraints.h	2020-10-14 18:39:21.945383600 -0300
@@ -34,6 +34,7 @@
     void add_constraints(std::vector<lp::LPConstraint> &constraints, double infinity);
 public:
     virtual void initialize_constraints(const std::shared_ptr<AbstractTask> &task,
+                                        std::vector<lp::LPVariable> & /*variables*/,
                                         std::vector<lp::LPConstraint> &constraints,
                                         double infinity);
     virtual bool update_constraints(const State &state, lp::LPSolver &lp_solver);
