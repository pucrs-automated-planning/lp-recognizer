diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/fast-downward fast-downward/fast-downward
--- fast-downward-original/fast-downward	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/fast-downward	2018-12-26 11:08:34.000000000 -0200
@@ -0,0 +1,13 @@
+#!/usr/bin/env bash
+DIR=`dirname $0`
+DOMAIN=$1
+shift
+PROBLEM=$1
+shift
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(lmcut())" "$@"
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(seq())" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints()], lpsolver=CPLEX, transform=no_transform(), cache_estimates=true))" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints(), pho_constraints(), state_equation_constraints()]))" "$@"
+${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints(), pho_constraints(), state_equation_constraints()]))" "$@"
+
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --alias seq-opt-lmcut "$@"
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/fd-constraints fast-downward/fd-constraints
--- fast-downward-original/fd-constraints	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/fd-constraints	2018-12-26 11:08:20.000000000 -0200
@@ -0,0 +1,14 @@
+#!/usr/bin/env bash
+DIR=`dirname $0`
+DOMAIN=$1
+shift
+PROBLEM=$1
+shift
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(lmcut())" "$@"
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(seq())" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints()], lpsolver=CPLEX, transform=no_transform(), cache_estimates=true))" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints(), pho_constraints(), state_equation_constraints()]))" "$@"
+
+# ${DIR}/builds/debug64/bin/downward --search "astar(ocsingleshot([lmcut_constraints()], lpsolver=CPLEX, transform=no_transform(), cache_estimates=true))" --internal-plan-file ${DIR}/sas_plan < output.sas
+
+${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(ocsingleshot([lmcut_constraints(), pho_constraints(), state_equation_constraints()]))" "$@"
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/install-osi-linux.sh fast-downward/install-osi-linux.sh
--- fast-downward-original/install-osi-linux.sh	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/install-osi-linux.sh	2018-11-02 06:52:17.000000000 -0300
@@ -0,0 +1,21 @@
+#!/usr/bin/env bash
+export DOWNWARD_CPLEX_ROOT64=/opt/ibm/ILOG/CPLEX_Studio_Community128/cplex
+# You should probably change the line below to match where you want COIN64
+export DOWNWARD_COIN_ROOT64=~/workspace-planning/coin64 
+pushd ..
+wget -c http://www.coin-or.org/download/source/Osi/Osi-0.107.9.tgz
+tar xvzf Osi-0.107.9.tgz
+cd Osi-0.107.9
+./configure CC="gcc"  CFLAGS="-m64 -pthread -Wno-long-long" \
+            CXX="g++" CXXFLAGS="-m64 -pthread -Wno-long-long" \
+            LDFLAGS="-L$DOWNWARD_CPLEX_ROOT64/lib/x86-64_linux/static_pic" \
+            --without-lapack --enable-static=yes \
+            --prefix="$DOWNWARD_COIN_ROOT64" \
+            --disable-zlib --disable-bzlib \
+            --with-cplex-incdir=$DOWNWARD_CPLEX_ROOT64/include/ilcplex --with-cplex-lib="-lcplex -lm"
+make
+make install
+cd ..
+# rm -rf Osi-0.107.9
+# rm Osi-0.107.9.tgz
+popd
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/install-osi-mac.sh fast-downward/install-osi-mac.sh
--- fast-downward-original/install-osi-mac.sh	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/install-osi-mac.sh	2018-11-06 19:17:41.000000000 -0200
@@ -0,0 +1,23 @@
+#!/usr/bin/env bash
+pushd ..
+export DOWNWARD_CPLEX_ROOT64=/Applications/CPLEX_Studio_Community128/cplex
+# You should probably change the line below to match where you want COIN64
+export DOWNWARD_COIN_ROOT64=~/Documents/workspace-planning/coin64 
+wget -c http://www.coin-or.org/download/source/Osi/Osi-0.107.9.tgz
+tar xvzf Osi-0.107.9.tgz
+cd Osi-0.107.9
+
+./configure CC="gcc"  CFLAGS="-m64 -arch x86_64 -pthread -Wno-long-long" \
+            CXX="g++" CXXFLAGS="-m64 -arch x86_64 -pthread -Wno-long-long" \
+            LDFLAGS="-L$DOWNWARD_CPLEX_ROOT64/lib/x86-64_osx/static_pic -arch x86_64 -v" \
+            --without-lapack --disable-shared --enable-static=yes \
+            --prefix="$DOWNWARD_COIN_ROOT64" \
+            --disable-zlib --disable-bzlib \
+            --with-cplex-incdir=$DOWNWARD_CPLEX_ROOT64/include/ilcplex --with-cplex-lib="-lcplex -lm -ldl"
+
+make -j8
+make install
+cd ..
+# rm -rf Osi-0.107.9
+# rm Osi-0.107.9.tgz
+popd
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/new_constraint.txt fast-downward/new_constraint.txt
--- fast-downward-original/new_constraint.txt	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/new_constraint.txt	2018-11-06 19:35:47.000000000 -0200
@@ -0,0 +1,3 @@
+2 1e+20
+0 4
+1 1
Binary files fast-downward-original/src/VAL/validate and fast-downward/src/VAL/validate differ
Binary files fast-downward-original/src/preprocess/preprocess and fast-downward/src/preprocess/preprocess differ
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/DownwardFiles.cmake fast-downward/src/search/DownwardFiles.cmake
--- fast-downward-original/src/search/DownwardFiles.cmake	2018-12-24 16:48:31.000000000 -0200
+++ fast-downward/src/search/DownwardFiles.cmake	2018-12-24 08:27:42.000000000 -0200
@@ -698,6 +698,18 @@
 )
 
 fast_downward_plugin(
+    NAME OC_SINGLESHOT
+    HELP "Plugin containing the code for operator counting single shot"
+    SOURCES
+        operator_counting/constraint_generator
+        operator_counting/lm_cut_constraints
+        operator_counting/oc_single_shot_heuristic
+        operator_counting/pho_constraints
+        operator_counting/state_equation_constraints
+    DEPENDS LP_SOLVER LANDMARK_CUT_HEURISTIC PDBS TASK_PROPERTIES
+)
+
+fast_downward_plugin(
     NAME PDBS
     HELP "Plugin containing the code for PDBs"
     SOURCES
Binary files fast-downward-original/src/search/downward-release and fast-downward/src/search/downward-release differ
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/lp/lp_solver.cc fast-downward/src/search/lp/lp_solver.cc
--- fast-downward-original/src/search/lp/lp_solver.cc	2018-12-24 16:48:31.000000000 -0200
+++ fast-downward/src/search/lp/lp_solver.cc	2018-10-19 10:13:50.000000000 -0300
@@ -3,7 +3,7 @@
 #include "lp_internals.h"
 
 #include "../option_parser.h"
-
+#include "../utils/logging.h"
 #include "../utils/system.h"
 
 #ifdef USE_LP
@@ -67,10 +67,11 @@
 }
 
 LPVariable::LPVariable(double lower_bound, double upper_bound,
-                       double objective_coefficient)
+                       double objective_coefficient, bool is_integer)
     : lower_bound(lower_bound),
       upper_bound(upper_bound),
-      objective_coefficient(objective_coefficient) {
+      objective_coefficient(objective_coefficient),
+      is_integer(is_integer){
 }
 
 LPSolver::~LPSolver() {
@@ -105,6 +106,10 @@
     is_initialized = false;
     num_permanent_constraints = constraints.size();
 
+    ///////////////////////////////////////////////////////////////////
+    all_constraints = constraints;
+    ///////////////////////////////////////////////////////////////////
+
     for (const LPVariable &var : variables) {
         col_lb.push_back(var.lower_bound);
         col_ub.push_back(var.upper_bound);
@@ -156,6 +161,14 @@
                                objective.data(),
                                row_lb.data(),
                                row_ub.data());
+        int num_vars = variables.size();
+        for (int i = 0; i < num_vars; ++i) {
+            if (variables[i].is_integer) {
+                lp_solver->setInteger(i);
+            }
+        }
+        //cout << "Integer tolerance: " << lp_solver->getIntegerTolerance() << endl;
+        //cout << "Number of integer variables: " << lp_solver->getNumIntegers() << endl;
     } catch (CoinError &error) {
         handle_coin_error(error);
     }
@@ -176,7 +189,6 @@
                                constraint.get_coefficients().data(),
                                false));
         }
-
         try {
             lp_solver->addRows(num_rows,
                                rows.data(), row_lb.data(), row_ub.data());
@@ -192,6 +204,36 @@
     }
 }
 
+///////////////////////////////////////////////////////////////////
+void LPSolver::add_new_constraints(const vector<LPConstraint> &constraints) {
+    if (!constraints.empty()) {
+        clear_temporary_data();
+        int num_rows = constraints.size();
+        for (const LPConstraint &constraint : constraints) {
+            row_lb.push_back(constraint.get_lower_bound());
+            row_ub.push_back(constraint.get_upper_bound());
+            rows.push_back(new CoinShallowPackedVector(
+                               constraint.get_variables().size(),
+                               constraint.get_variables().data(),
+                               constraint.get_coefficients().data(),
+                               false));
+        }
+        try {
+            lp_solver->addRows(num_rows,
+                               rows.data(), row_lb.data(), row_ub.data());
+        } catch (CoinError &error) {
+            handle_coin_error(error);
+        }
+        for (CoinPackedVectorBase *row : rows) {
+            delete row;
+        }
+        clear_temporary_data();
+        //has_temporary_constraints_ = false;
+        //is_solved = false;
+    }
+}
+///////////////////////////////////////////////////////////////////
+
 void LPSolver::clear_temporary_constraints() {
     if (has_temporary_constraints_) {
         try {
@@ -297,6 +339,20 @@
     }
 }
 
+void LPSolver::solve_mip() {
+    try {
+        lp_solver->branchAndBound();
+        if (lp_solver->isAbandoned()) {
+            cerr << "Abandoned LP. "
+                 << "Reasons include \"numerical difficulties\" and running out of memory." << endl;
+            utils::exit_with(ExitCode::SEARCH_CRITICAL_ERROR);
+        }
+        is_solved = true;
+    } catch (CoinError &error) {
+        handle_coin_error(error);
+    }
+}
+
 bool LPSolver::has_optimal_solution() const {
     assert(is_solved);
     try {
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/lp/lp_solver.h fast-downward/src/search/lp/lp_solver.h
--- fast-downward-original/src/search/lp/lp_solver.h	2018-12-24 16:48:31.000000000 -0200
+++ fast-downward/src/search/lp/lp_solver.h	2018-10-19 10:14:34.000000000 -0300
@@ -67,10 +67,12 @@
     double lower_bound;
     double upper_bound;
     double objective_coefficient;
+    bool is_integer;
 
     LPVariable(double lower_bound,
                double upper_bound,
-               double objective_coefficient);
+               double objective_coefficient,
+               bool is_integer = false);
 };
 
 #ifdef __GNUG__
@@ -85,7 +87,6 @@
 #ifdef USE_LP
     std::unique_ptr<OsiSolverInterface> lp_solver;
 #endif
-
     /*
       Temporary data for assigning a new problem. We keep the vectors
       around to avoid recreating them in every assignment.
@@ -101,6 +102,11 @@
     std::vector<CoinPackedVectorBase *> rows;
     void clear_temporary_data();
 public:
+
+    ///////////////////////////////////////////////////////////////////
+    std::vector<LPConstraint> all_constraints;
+    ///////////////////////////////////////////////////////////////////
+
     LP_METHOD(explicit LPSolver(LPSolverType solver_type))
     /*
       Note that the destructor does not use LP_METHOD because it should not
@@ -115,6 +121,11 @@
                   const std::vector<LPVariable> &variables,
                   const std::vector<LPConstraint> &constraints))
     LP_METHOD(void add_temporary_constraints(const std::vector<LPConstraint> &constraints))
+
+    ///////////////////////////////////////////////////////////////////
+    LP_METHOD(void add_new_constraints(const std::vector<LPConstraint> &constraints))
+    ///////////////////////////////////////////////////////////////////
+
     LP_METHOD(void clear_temporary_constraints())
     LP_METHOD(double get_infinity() const)
 
@@ -126,6 +137,7 @@
     LP_METHOD(void set_variable_upper_bound(int index, double bound))
 
     LP_METHOD(void solve())
+    LP_METHOD(void solve_mip())
 
     /*
       Return true if the solving the LP showed that it is bounded feasible and
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/lm_cut_constraints.cc fast-downward/src/search/operator_counting/lm_cut_constraints.cc
--- fast-downward-original/src/search/operator_counting/lm_cut_constraints.cc	2018-12-24 16:48:31.000000000 -0200
+++ fast-downward/src/search/operator_counting/lm_cut_constraints.cc	2018-12-27 18:43:57.000000000 -0200
@@ -44,6 +44,30 @@
         return true;
     } else {
         lp_solver.add_temporary_constraints(constraints);
+
+        ///////////////////////////////////////////////////////////////////
+        /*
+        cout << endl << string(80, '*') << endl;
+        cout << "# LM-Cut Constraints(" << constraints.size() << "): " << endl;
+        for (int i = 0; i < (int) constraints.size(); ++i) {
+            lp::LPConstraint constraint = constraints[i];
+
+            cout << "constraints.append(Constraint(";
+            for (int j = 0; j < (int) constraint.get_variables().size(); ++j) {
+                int var = constraint.get_variables()[j];
+                double coe = constraint.get_coefficients()[j];
+                cout << coe << "*X[" << var << "]";
+                if (j < (int) constraint.get_variables().size() - 1) {
+                    cout << " + ";
+                }
+            }
+            cout << ", lb=" << constraint.get_lower_bound();
+            cout << ", ub=" << constraint.get_upper_bound() << "))" << endl;
+        }
+        cout << string(80, '*') << endl << endl;
+        */
+        ///////////////////////////////////////////////////////////////////
+
         return false;
     }
 }
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.cc fast-downward/src/search/operator_counting/oc_single_shot_heuristic.cc
--- fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.cc	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/oc_single_shot_heuristic.cc	2018-12-27 18:41:58.000000000 -0200
@@ -0,0 +1,255 @@
+#include "oc_single_shot_heuristic.h"
+
+#include "constraint_generator.h"
+
+#include "../option_parser.h"
+#include "../plugin.h"
+
+#include "../utils/markup.h"
+
+#include <cmath>
+#include <fstream>
+
+using namespace std;
+
+namespace operator_counting {
+OCSingleShotHeuristic::OCSingleShotHeuristic(const Options &opts)
+    : Heuristic(opts),
+      constraint_generators(
+          opts.get_list<shared_ptr<ConstraintGenerator>>("constraint_generators")),
+      lp_solver(lp::LPSolverType(opts.get_enum("lpsolver"))) {
+    vector<lp::LPVariable> variables;
+    double infinity = lp_solver.get_infinity();
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        int op_cost = op.get_cost();
+        variables.push_back(lp::LPVariable(0, infinity, op_cost));
+    }
+    vector<lp::LPConstraint> constraints;
+    for (const auto &generator : constraint_generators) {
+        generator->initialize_constraints(task, constraints, infinity);
+    }
+    ///////////////////////////////////////////////////////////////////
+    cout << endl << string(80, '*') << endl;
+    cout << "# Mapping X -> op: " << endl;
+    int i = 0;
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        cout << "# X[" << i << "] = " << op.get_name() << endl;
+        i++;
+    }
+    cout << string(80, '*') << endl << endl;
+    ///////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////
+    cout << endl << string(80, '*') << endl;
+    cout << "# Variables(" << variables.size() << "): " << endl;
+    for (int i = 0; i < (int) variables.size(); ++i) {
+        cout << "X[" << i << "] = Variable('X_" << i << "'";
+        cout << ", lb=" << variables[i].lower_bound;
+        cout << ", ub=" << variables[i].upper_bound;
+        cout << ", type='integer')";
+        cout << ", cost[" << i << "] = 1" << endl;
+    }
+    cout << string(80, '*') << endl << endl;
+    ///////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////
+    cout << endl << string(80, '*') << endl;
+    cout << "# Objective function: " << endl;
+    cout << "obj = Objective(";
+    for (int i = 0; i < (int) variables.size(); ++i) {
+        cout << "cost[" << i << "] * X[" << i << "]";
+        if (i < (int) variables.size() - 1) {
+            cout << " + ";
+        }
+    }
+    cout << ", direction='min')" << endl;
+    cout << string(80, '*') << endl << endl;
+    ///////////////////////////////////////////////////////////////////
+
+    lp_solver.load_problem(lp::LPObjectiveSense::MINIMIZE, variables, constraints);
+}
+
+OCSingleShotHeuristic::~OCSingleShotHeuristic() {
+}
+
+int OCSingleShotHeuristic::compute_heuristic(const GlobalState &global_state) {
+    State state = convert_global_state(global_state);
+    return compute_heuristic(state);
+}
+
+int OCSingleShotHeuristic::compute_heuristic(const State &state) {
+    assert(!lp_solver.has_temporary_constraints());
+    for (const auto &generator : constraint_generators) {
+        bool dead_end = generator->update_constraints(state, lp_solver);
+        if (dead_end) {
+            lp_solver.clear_temporary_constraints();
+            return DEAD_END;
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////////
+    ifstream file;
+    file.open("new_constraint.txt");
+    if (file.is_open()) {
+        double lb, ub;
+        file >> lb >> ub;
+
+        file.get();
+
+        string indexes;
+        getline(file, indexes);
+        istringstream indexes_iss(indexes);
+        vector<string> indexes_str((istream_iterator<string>(indexes_iss)), istream_iterator<string>());
+        vector<int> indexes_int;
+        transform(indexes_str.begin(), indexes_str.end(), back_inserter(indexes_int), [](string i){
+            return atoi(i.c_str());
+        });
+
+        string coeffs;
+        getline(file, coeffs);
+        istringstream coeffs_iss(coeffs);
+        vector<string> coeffs_str((istream_iterator<string>(coeffs_iss)), istream_iterator<string>());
+        vector<double> coeffs_double;
+        transform(coeffs_str.begin(), coeffs_str.end(), back_inserter(coeffs_double), [](string i){
+            return atof(i.c_str());
+        });
+
+        file.close();
+
+        vector<lp::LPConstraint> new_constraints;
+        lp::LPConstraint constraint(lb, ub);
+        for (size_t i = 0; i < indexes_int.size(); ++i) {
+            int index = indexes_int[i];
+            double coeff = coeffs_double[i];
+            constraint.insert(index, coeff);
+        }
+        new_constraints.push_back(constraint);
+        lp_solver.add_new_constraints(new_constraints);
+
+        cout << "# Adding constraint from file:" << endl;
+        cout << "constraints.append(Constraint(";
+        for (int j = 0; j < (int) constraint.get_variables().size(); ++j) {
+            int var = constraint.get_variables()[j];
+            double coe = constraint.get_coefficients()[j];
+            cout << coe << "*X[" << var << "]";
+            if (j < (int) constraint.get_variables().size() - 1) {
+                cout << " + ";
+            }
+        }
+        cout << ", lb=" << constraint.get_lower_bound();
+        cout << ", ub=" << constraint.get_upper_bound() << "))" << endl;
+    }
+    ///////////////////////////////////////////////////////////////////
+
+    int result;
+    lp_solver.solve();
+    if (lp_solver.has_optimal_solution()) {
+        double epsilon = 0.01;
+        double objective_value = lp_solver.get_objective_value();
+        result = ceil(objective_value - epsilon);
+        
+    } else {
+        result = DEAD_END;
+    }
+
+    ///////////////////////////////////////////////////////////////////
+    cout << endl << string(80, '*') << endl;
+    cout << "# Objective value: " << result << endl;
+    cout << "# Solution: " << endl;
+    vector<double> solution = lp_solver.extract_solution();
+    for (int i = 0; i < (int) solution.size(); ++i) {
+        cout << "X[" << i << "] = " << solution[i] << endl;
+    }
+    cout << string(80, '*') << endl;
+
+    ofstream h_result;
+    cout << "Writing objective result in h_result.txt" << endl;
+    h_result.open("h_result.txt");
+    // Output the state
+    h_result << "-- ";
+    for (FactProxy fact : state) {
+        string fact_name = fact.get_name();
+        if (fact_name != "<none of those>")
+            h_result << fact_name << " "; // Using this crappy printing for the moment
+    }
+    h_result << endl << result << endl;
+
+    // Printing counts
+    int var_i=0;
+    vector<double> counts = lp_solver.extract_solution();
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        // cout << "(" << op.get_name() << ") = " << counts[var_i] << endl;
+        if (counts[var_i] > 0 ) {
+            h_result << "(" << op.get_name() << ") = " << counts[var_i] << endl;
+        }
+        var_i++;
+    }
+
+    h_result.flush();
+    h_result.close();
+
+    if(result == DEAD_END)
+        exit(EXIT_FAILURE);
+    else
+        exit(EXIT_SUCCESS);
+    ///////////////////////////////////////////////////////////////////
+
+    lp_solver.clear_temporary_constraints();
+    return result;
+}
+
+static shared_ptr<Heuristic> _parse(OptionParser &parser) {
+    parser.document_synopsis(
+        "Operator counting heuristic, single shot call for recognition",
+        "An operator counting heuristic computes a linear program (LP) in each "
+        "state. The LP has one variable Count_o for each operator o that "
+        "represents how often the operator is used in a plan. Operator "
+        "counting constraints are linear constraints over these varaibles that "
+        "are guaranteed to have a solution with Count_o = occurrences(o, pi) "
+        "for every plan pi. Minimizing the total cost of operators subject to "
+        "some operator counting constraints is an admissible heuristic. "
+        "For details, see" + utils::format_paper_reference( // TODO - Change this for our paper
+            {"Florian Pommerening", "Gabriele Roeger", "Malte Helmert",
+             "Blai Bonet"},
+            "LP-based Heuristics for Cost-optimal Planning",
+            "http://www.aaai.org/ocs/index.php/ICAPS/ICAPS14/paper/view/7892/8031",
+            "Proceedings of the Twenty-Fourth International Conference"
+            " on Automated Planning and Scheduling (ICAPS 2014)",
+            "226-234",
+            "AAAI Press 2014"));
+
+    parser.document_language_support("action costs", "supported");
+    parser.document_language_support(
+        "conditional effects",
+        "not supported (the heuristic supports them in theory, but none of "
+        "the currently implemented constraint generators do)");
+    parser.document_language_support(
+        "axioms",
+        "not supported (the heuristic supports them in theory, but none of "
+        "the currently implemented constraint generators do)");
+    parser.document_property("admissible", "yes");
+    parser.document_property(
+        "consistent",
+        "yes, if all constraint generators represent consistent heuristics");
+    parser.document_property("safe", "yes");
+    // TODO: prefer operators that are non-zero in the solution.
+    parser.document_property("preferred operators", "no");
+
+
+    parser.add_list_option<shared_ptr<ConstraintGenerator>>(
+        "constraint_generators",
+        "methods that generate constraints over operator counting variables");
+    lp::add_lp_solver_option_to_parser(parser);
+    Heuristic::add_options_to_parser(parser);
+    Options opts = parser.parse();
+    if (parser.help_mode())
+        return nullptr;
+    opts.verify_list_non_empty<shared_ptr<ConstraintGenerator>>(
+        "constraint_generators");
+    if (parser.dry_run())
+        return nullptr;
+    return make_shared<OCSingleShotHeuristic>(opts);
+}
+
+static Plugin<Evaluator> _plugin("ocsingleshot", _parse);
+}
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.h fast-downward/src/search/operator_counting/oc_single_shot_heuristic.h
--- fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.h	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/oc_single_shot_heuristic.h	2018-12-23 10:50:46.000000000 -0200
@@ -0,0 +1,30 @@
+#ifndef OPERATOR_COUNTING_OPERATOR_COUNTING_HEURISTIC_H
+#define OPERATOR_COUNTING_OPERATOR_COUNTING_HEURISTIC_H
+
+#include "../heuristic.h"
+
+#include "../lp/lp_solver.h"
+
+#include <memory>
+#include <vector>
+
+namespace options {
+class Options;
+}
+
+namespace operator_counting {
+class ConstraintGenerator;
+
+class OCSingleShotHeuristic : public Heuristic {
+    std::vector<std::shared_ptr<ConstraintGenerator>> constraint_generators;
+    lp::LPSolver lp_solver;
+protected:
+    virtual int compute_heuristic(const GlobalState &global_state) override;
+    int compute_heuristic(const State &state);
+public:
+    explicit OCSingleShotHeuristic(const options::Options &opts);
+    ~OCSingleShotHeuristic();
+};
+}
+
+#endif
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/operator_counting_heuristic.cc.orig fast-downward/src/search/operator_counting/operator_counting_heuristic.cc.orig
--- fast-downward-original/src/search/operator_counting/operator_counting_heuristic.cc.orig	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/operator_counting_heuristic.cc.orig	2018-12-21 20:15:05.000000000 -0200
@@ -0,0 +1,225 @@
+#include "operator_counting_heuristic.h"
+
+#include "constraint_generator.h"
+
+#include "../option_parser.h"
+#include "../plugin.h"
+
+#include "../utils/markup.h"
+
+#include <cmath>
+#include <fstream>
+
+using namespace std;
+
+namespace operator_counting {
+OperatorCountingHeuristic::OperatorCountingHeuristic(const Options &opts)
+    : Heuristic(opts),
+      constraint_generators(
+          opts.get_list<shared_ptr<ConstraintGenerator>>("constraint_generators")),
+      lp_solver(lp::LPSolverType(opts.get_enum("lpsolver"))) {
+    vector<lp::LPVariable> variables;
+    double infinity = lp_solver.get_infinity();
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        int op_cost = op.get_cost();
+        variables.push_back(lp::LPVariable(0, infinity, op_cost));
+    }
+    vector<lp::LPConstraint> constraints;
+    for (const auto &generator : constraint_generators) {
+        generator->initialize_constraints(task, constraints, infinity);
+    }
+    ///////////////////////////////////////////////////////////////////
+    cout << endl << string(80, '*') << endl;
+    cout << "# Mapping X -> op: " << endl;
+    int i = 0;
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        cout << "# X[" << i << "] = " << op.get_name() << endl;
+        i++;
+    }
+    cout << string(80, '*') << endl << endl;
+    ///////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////
+    cout << endl << string(80, '*') << endl;
+    cout << "# Variables(" << variables.size() << "): " << endl;
+    for (int i = 0; i < (int) variables.size(); ++i) {
+        cout << "X[" << i << "] = Variable('X_" << i << "'";
+        cout << ", lb=" << variables[i].lower_bound;
+        cout << ", ub=" << variables[i].upper_bound;
+        cout << ", type='integer')";
+        cout << ", cost[" << i << "] = 1" << endl;
+    }
+    cout << string(80, '*') << endl << endl;
+    ///////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////
+    cout << endl << string(80, '*') << endl;
+    cout << "# Objective function: " << endl;
+    cout << "obj = Objective(";
+    for (int i = 0; i < (int) variables.size(); ++i) {
+        cout << "cost[" << i << "] * X[" << i << "]";
+        if (i < (int) variables.size() - 1) {
+            cout << " + ";
+        }
+    }
+    cout << ", direction='min')" << endl;
+    cout << string(80, '*') << endl << endl;
+    ///////////////////////////////////////////////////////////////////
+
+    lp_solver.load_problem(lp::LPObjectiveSense::MINIMIZE, variables, constraints);
+}
+
+OperatorCountingHeuristic::~OperatorCountingHeuristic() {
+}
+
+int OperatorCountingHeuristic::compute_heuristic(const GlobalState &global_state) {
+    State state = convert_global_state(global_state);
+    return compute_heuristic(state);
+}
+
+int OperatorCountingHeuristic::compute_heuristic(const State &state) {
+    assert(!lp_solver.has_temporary_constraints());
+    for (const auto &generator : constraint_generators) {
+        bool dead_end = generator->update_constraints(state, lp_solver);
+        if (dead_end) {
+            lp_solver.clear_temporary_constraints();
+            return DEAD_END;
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////////
+    ifstream file;
+    file.open("new_constraint.txt");
+    if (file.is_open()) {
+        double lb, ub;
+        file >> lb >> ub;
+
+        file.get();
+
+        string indexes;
+        getline(file, indexes);
+        istringstream indexes_iss(indexes);
+        vector<string> indexes_str((istream_iterator<string>(indexes_iss)), istream_iterator<string>());
+        vector<int> indexes_int;
+        transform(indexes_str.begin(), indexes_str.end(), back_inserter(indexes_int), [](string i){
+            return atoi(i.c_str());
+        });
+
+        string coeffs;
+        getline(file, coeffs);
+        istringstream coeffs_iss(coeffs);
+        vector<string> coeffs_str((istream_iterator<string>(coeffs_iss)), istream_iterator<string>());
+        vector<double> coeffs_double;
+        transform(coeffs_str.begin(), coeffs_str.end(), back_inserter(coeffs_double), [](string i){
+            return atof(i.c_str());
+        });
+
+        file.close();
+
+        vector<lp::LPConstraint> new_constraints;
+        lp::LPConstraint constraint(lb, ub);
+        for (size_t i = 0; i < indexes_int.size(); ++i) {
+            int index = indexes_int[i];
+            double coeff = coeffs_double[i];
+            constraint.insert(index, coeff);
+        }
+        new_constraints.push_back(constraint);
+        lp_solver.add_new_constraints(new_constraints);
+
+        cout << "# Adding constraint from file:" << endl;
+        cout << "constraints.append(Constraint(";
+        for (int j = 0; j < (int) constraint.get_variables().size(); ++j) {
+            int var = constraint.get_variables()[j];
+            double coe = constraint.get_coefficients()[j];
+            cout << coe << "*X[" << var << "]";
+            if (j < (int) constraint.get_variables().size() - 1) {
+                cout << " + ";
+            }
+        }
+        cout << ", lb=" << constraint.get_lower_bound();
+        cout << ", ub=" << constraint.get_upper_bound() << "))" << endl;
+    }
+    ///////////////////////////////////////////////////////////////////
+
+    int result;
+    lp_solver.solve();
+    if (lp_solver.has_optimal_solution()) {
+        double epsilon = 0.01;
+        double objective_value = lp_solver.get_objective_value();
+        result = ceil(objective_value - epsilon);
+    } else {
+        result = DEAD_END;
+    }
+
+    ///////////////////////////////////////////////////////////////////
+    cout << endl << string(80, '*') << endl;
+    cout << "# Objective value: " << result << endl;
+    cout << "# Solution: " << endl;
+    vector<double> solution = lp_solver.extract_solution();
+    for (int i = 0; i < (int) solution.size(); ++i) {
+        cout << "X[" << i << "] = " << solution[i] << endl;
+    }
+    cout << string(80, '*') << endl;
+
+    exit(100);
+    ///////////////////////////////////////////////////////////////////
+
+    lp_solver.clear_temporary_constraints();
+    return result;
+}
+
+static shared_ptr<Heuristic> _parse(OptionParser &parser) {
+    parser.document_synopsis(
+        "Operator counting heuristic",
+        "An operator counting heuristic computes a linear program (LP) in each "
+        "state. The LP has one variable Count_o for each operator o that "
+        "represents how often the operator is used in a plan. Operator "
+        "counting constraints are linear constraints over these varaibles that "
+        "are guaranteed to have a solution with Count_o = occurrences(o, pi) "
+        "for every plan pi. Minimizing the total cost of operators subject to "
+        "some operator counting constraints is an admissible heuristic. "
+        "For details, see" + utils::format_paper_reference(
+            {"Florian Pommerening", "Gabriele Roeger", "Malte Helmert",
+             "Blai Bonet"},
+            "LP-based Heuristics for Cost-optimal Planning",
+            "http://www.aaai.org/ocs/index.php/ICAPS/ICAPS14/paper/view/7892/8031",
+            "Proceedings of the Twenty-Fourth International Conference"
+            " on Automated Planning and Scheduling (ICAPS 2014)",
+            "226-234",
+            "AAAI Press 2014"));
+
+    parser.document_language_support("action costs", "supported");
+    parser.document_language_support(
+        "conditional effects",
+        "not supported (the heuristic supports them in theory, but none of "
+        "the currently implemented constraint generators do)");
+    parser.document_language_support(
+        "axioms",
+        "not supported (the heuristic supports them in theory, but none of "
+        "the currently implemented constraint generators do)");
+    parser.document_property("admissible", "yes");
+    parser.document_property(
+        "consistent",
+        "yes, if all constraint generators represent consistent heuristics");
+    parser.document_property("safe", "yes");
+    // TODO: prefer operators that are non-zero in the solution.
+    parser.document_property("preferred operators", "no");
+
+
+    parser.add_list_option<shared_ptr<ConstraintGenerator>>(
+        "constraint_generators",
+        "methods that generate constraints over operator counting variables");
+    lp::add_lp_solver_option_to_parser(parser);
+    Heuristic::add_options_to_parser(parser);
+    Options opts = parser.parse();
+    if (parser.help_mode())
+        return nullptr;
+    opts.verify_list_non_empty<shared_ptr<ConstraintGenerator>>(
+        "constraint_generators");
+    if (parser.dry_run())
+        return nullptr;
+    return make_shared<OperatorCountingHeuristic>(opts);
+}
+
+static Plugin<Evaluator> _plugin("operatorcounting", _parse);
+}
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/pho_constraints.cc fast-downward/src/search/operator_counting/pho_constraints.cc
--- fast-downward-original/src/search/operator_counting/pho_constraints.cc	2018-12-24 16:48:31.000000000 -0200
+++ fast-downward/src/search/operator_counting/pho_constraints.cc	2018-12-27 18:46:07.000000000 -0200
@@ -53,6 +53,14 @@
 
 bool PhOConstraints::update_constraints(const State &state,
                                         lp::LPSolver &lp_solver) {
+
+    ///////////////////////////////////////////////////////////////////
+    /*
+    cout << endl << string(80, '*') << endl;
+    cout << "# Posthoc Constraints(" << pdbs->size() << "): " << endl;
+    */
+    ///////////////////////////////////////////////////////////////////
+
     for (size_t i = 0; i < pdbs->size(); ++i) {
         int constraint_id = constraint_offset + i;
         shared_ptr<pdbs::PatternDatabase> pdb = (*pdbs)[i];
@@ -61,7 +69,31 @@
             return true;
         }
         lp_solver.set_constraint_lower_bound(constraint_id, h);
+
+        ///////////////////////////////////////////////////////////////////
+        /*
+        lp_solver.all_constraints[constraint_id].set_lower_bound(h);
+        lp::LPConstraint constraint = lp_solver.all_constraints[constraint_id];
+        cout << "constraints.append(Constraint(";
+        for (int j = 0; j < (int) constraint.get_variables().size(); ++j) {
+            int var = constraint.get_variables()[j];
+            double coe = constraint.get_coefficients()[j];
+            cout << coe << "*X[" << var << "]";
+            if (j < (int) constraint.get_variables().size() - 1) {
+                cout << " + ";
+            }
+        }
+        cout << ", lb=" << constraint.get_lower_bound();
+        cout << ", ub=" << constraint.get_upper_bound() << "))" << endl;
+        */
+        ///////////////////////////////////////////////////////////////////
+
     }
+
+    ///////////////////////////////////////////////////////////////////
+    cout << string(80, '*') << endl << endl;
+    ///////////////////////////////////////////////////////////////////
+
     return false;
 }
 
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/pho_constraints.h fast-downward/src/search/operator_counting/pho_constraints.h
--- fast-downward-original/src/search/operator_counting/pho_constraints.h	2018-12-24 16:48:31.000000000 -0200
+++ fast-downward/src/search/operator_counting/pho_constraints.h	2018-11-06 18:41:04.000000000 -0200
@@ -23,6 +23,7 @@
     std::shared_ptr<pdbs::PDBCollection> pdbs;
 public:
     explicit PhOConstraints(const options::Options &opts);
+    ~PhOConstraints() = default;
 
     virtual void initialize_constraints(
         const std::shared_ptr<AbstractTask> &task,
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/state_equation_constraints.cc fast-downward/src/search/operator_counting/state_equation_constraints.cc
--- fast-downward-original/src/search/operator_counting/state_equation_constraints.cc	2018-12-24 16:48:31.000000000 -0200
+++ fast-downward/src/search/operator_counting/state_equation_constraints.cc	2018-11-06 18:47:12.000000000 -0200
@@ -86,6 +86,24 @@
 
 bool StateEquationConstraints::update_constraints(const State &state,
                                                   lp::LPSolver &lp_solver) {
+
+    int size = 0;
+    for (size_t var = 0; var < propositions.size(); ++var) {
+        int num_values = propositions[var].size();
+        for (int value = 0; value < num_values; ++value) {
+            const Proposition &prop = propositions[var][value];
+            if (prop.constraint_index >= 0) {
+                size++;
+            }
+        }
+    }
+
+    ///////////////////////////////////////////////////////////////////
+    cout << endl;
+    cout << string(80, '*') << endl;
+    cout << "# StateEquation Constraints(" << size << "): " << endl;
+    ///////////////////////////////////////////////////////////////////
+
     // Compute the bounds for the rows in the LP.
     for (size_t var = 0; var < propositions.size(); ++var) {
         int num_values = propositions[var].size();
@@ -106,9 +124,31 @@
                 }
                 lp_solver.set_constraint_lower_bound(
                     prop.constraint_index, lower_bound);
+
+                ///////////////////////////////////////////////////////////////////
+                lp_solver.all_constraints[prop.constraint_index].set_lower_bound(lower_bound);
+                lp::LPConstraint constraint = lp_solver.all_constraints[prop.constraint_index];
+                cout << "constraints.append(Constraint(";
+                for (int j = 0; j < (int) constraint.get_variables().size(); ++j) {
+                    int var = constraint.get_variables()[j];
+                    double coe = constraint.get_coefficients()[j];
+                    cout << coe << "*X[" << var << "]";
+                    if (j < (int) constraint.get_variables().size() - 1) {
+                        cout << " + ";
+                    }
+                }
+                cout << ", lb=" << constraint.get_lower_bound();
+                cout << ", ub=" << constraint.get_upper_bound() << "))" << endl;
+                ///////////////////////////////////////////////////////////////////
+
             }
         }
     }
+
+    ///////////////////////////////////////////////////////////////////
+    cout << string(80, '*') << endl << endl;
+    ///////////////////////////////////////////////////////////////////
+
     return false;
 }
 
@@ -151,4 +191,5 @@
 }
 
 static Plugin<ConstraintGenerator> _plugin("state_equation_constraints", _parse);
+
 }
Binary files fast-downward-original/src/validate and fast-downward/src/validate differ
