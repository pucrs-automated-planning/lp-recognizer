diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/fast-downward fast-downward/fast-downward
--- fast-downward-original/fast-downward	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/fast-downward	2019-08-20 15:46:01.000000000 -0300
@@ -0,0 +1,13 @@
+#!/usr/bin/env bash
+DIR=`dirname $0`
+DOMAIN=$1
+shift
+PROBLEM=$1
+shift
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(lmcut())" "$@"
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(seq())" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints()], lpsolver=CPLEX, transform=no_transform(), cache_estimates=true))" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints(), pho_constraints(), state_equation_constraints()]))" "$@"
+${DIR}/fast-downward.py --build=release $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints(), pho_constraints(), state_equation_constraints()]))" "$@"
+
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --alias seq-opt-lmcut "$@"
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/fd-constraints fast-downward/fd-constraints
--- fast-downward-original/fd-constraints	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/fd-constraints	2019-08-26 17:31:27.000000000 -0300
@@ -0,0 +1,14 @@
+#!/usr/bin/env bash
+DIR=`dirname $0`
+DOMAIN=$1
+shift
+PROBLEM=$1
+shift
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(lmcut())" "$@"
+# ${DIR}/fast-downward.py $DOMAIN $PROBLEM --search "astar(seq())" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints()], lpsolver=CPLEX, transform=no_transform(), cache_estimates=true))" "$@"
+# ${DIR}/fast-downward.py --build=release64 $DOMAIN $PROBLEM --search "astar(operatorcounting([lmcut_constraints(), pho_constraints(), state_equation_constraints()]))" "$@"
+
+# ${DIR}/builds/debug64/bin/downward --search "astar(ocsingleshot([lmcut_constraints()], lpsolver=CPLEX, transform=no_transform(), cache_estimates=true))" --internal-plan-file ${DIR}/sas_plan < output.sas
+
+${DIR}/fast-downward.py --build=release $DOMAIN $PROBLEM --search "astar(ocsingleshot([lmcut_constraints(), pho_constraints(), state_equation_constraints()],enforce_observations=false))" "$@"
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/install-osi-linux.sh fast-downward/install-osi-linux.sh
--- fast-downward-original/install-osi-linux.sh	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/install-osi-linux.sh	2019-08-26 16:42:35.000000000 -0300
@@ -0,0 +1,22 @@
+#!/usr/bin/env bash
+export DOWNWARD_CPLEX_ROOT=/opt/ibm/ILOG/CPLEX_Studio129/cplex
+# You should probably change the line below to match where you want COIN64
+export DOWNWARD_COIN_ROOT=~/workspace-planning/coin64 
+mkdir $DOWNWARD_COIN_ROOT
+pushd ..
+wget -c http://www.coin-or.org/download/source/Osi/Osi-0.107.9.tgz
+tar xvzf Osi-0.107.9.tgz
+cd Osi-0.107.9
+./configure CC="gcc"  CFLAGS="-m64 -pthread -Wno-long-long" \
+            CXX="g++" CXXFLAGS="-m64 -pthread -Wno-long-long" \
+            LDFLAGS="-L$DOWNWARD_CPLEX_ROOT/lib/x86-64_linux/static_pic" \
+            --without-lapack --enable-static=yes \
+            --prefix="$DOWNWARD_COIN_ROOT" \
+            --disable-zlib --disable-bzlib \
+            --with-cplex-incdir=$DOWNWARD_CPLEX_ROOT/include/ilcplex --with-cplex-lib="-lcplex -lm"
+make
+make install
+cd ..
+# rm -rf Osi-0.107.9
+# rm Osi-0.107.9.tgz
+popd
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/install-osi-mac.sh fast-downward/install-osi-mac.sh
--- fast-downward-original/install-osi-mac.sh	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/install-osi-mac.sh	2019-08-26 17:29:21.000000000 -0300
@@ -0,0 +1,26 @@
+#!/usr/bin/env bash
+# Ensure we are using the system's gcc/g++ rather than brew's
+export PATH=/usr/bin:$PATH
+pushd ..
+export DOWNWARD_CPLEX_ROOT=/Applications/CPLEX_Studio129/cplex/
+# You should probably change the line below to match where you want COIN64
+export DOWNWARD_COIN_ROOT=`pwd`/coin64
+mkdir $DOWNWARD_COIN_ROOT
+wget -c http://www.coin-or.org/download/source/Osi/Osi-0.107.9.tgz
+tar xvzf Osi-0.107.9.tgz
+cd Osi-0.107.9
+
+./configure CC="gcc"  CFLAGS="-m64 -arch x86_64 -pthread -Wno-long-long" \
+            CXX="g++" CXXFLAGS="-m64 -arch x86_64 -pthread -Wno-long-long" \
+            LDFLAGS="-L$DOWNWARD_CPLEX_ROOT/lib/x86-64_osx/static_pic -arch x86_64 -v" \
+            --without-lapack --disable-shared --enable-static=yes \
+            --prefix="$DOWNWARD_COIN_ROOT" \
+            --disable-zlib --disable-bzlib \
+            --with-cplex-incdir=$DOWNWARD_CPLEX_ROOT/include/ilcplex --with-cplex-lib="-lcplex -lm -ldl"
+
+make -j8
+make install
+cd ..
+# rm -rf Osi-0.107.9
+# rm Osi-0.107.9.tgz
+popd
\ No newline at end of file
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/DownwardFiles.cmake fast-downward/src/search/DownwardFiles.cmake
--- fast-downward-original/src/search/DownwardFiles.cmake	2019-08-26 17:37:21.000000000 -0300
+++ fast-downward/src/search/DownwardFiles.cmake	2019-08-26 16:36:44.000000000 -0300
@@ -699,6 +699,18 @@
 )
 
 fast_downward_plugin(
+    NAME OC_SINGLESHOT
+    HELP "Plugin containing the code for operator counting single shot"
+    SOURCES
+        operator_counting/constraint_generator
+        operator_counting/lm_cut_constraints
+        operator_counting/oc_single_shot_heuristic
+        operator_counting/pho_constraints
+        operator_counting/state_equation_constraints
+    DEPENDS LP_SOLVER LANDMARK_CUT_HEURISTIC PDBS TASK_PROPERTIES
+)
+
+fast_downward_plugin(
     NAME PDBS
     HELP "Plugin containing the code for PDBs"
     SOURCES
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.cc fast-downward/src/search/operator_counting/oc_single_shot_heuristic.cc
--- fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.cc	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/oc_single_shot_heuristic.cc	2019-08-19 17:21:26.000000000 -0300
@@ -0,0 +1,349 @@
+#include "oc_single_shot_heuristic.h"
+
+#include "constraint_generator.h"
+
+#include "../option_parser.h"
+#include "../plugin.h"
+
+#include "../utils/markup.h"
+
+#include <cmath>
+#include <fstream>
+
+#include <algorithm> 
+#include <cctype>
+#include <locale>
+
+// trim from start (in place)
+static inline void ltrim(std::string &s) {
+    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
+        return !std::isspace(ch);
+    }));
+}
+
+// trim from end (in place)
+static inline void rtrim(std::string &s) {
+    s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
+        return !std::isspace(ch);
+    }).base(), s.end());
+}
+
+// trim from both ends (in place)
+static inline void trim(std::string &s) {
+    ltrim(s);
+    rtrim(s);
+}
+
+using namespace std;
+
+namespace operator_counting {
+
+OCSingleShotHeuristic::OCSingleShotHeuristic(const Options &opts)
+    : Heuristic(opts),
+      constraint_generators(
+          opts.get_list<shared_ptr<ConstraintGenerator>>("constraint_generators")),
+      lp_solver(lp::LPSolverType(opts.get_enum("lpsolver"))),
+      enforce_observations(opts.get("enforce_observations",false)),
+      soft_constraints(opts.get("soft_constraints",false)),
+      op_indexes(),
+      observations(){
+
+    load_observations();
+
+    vector<lp::LPVariable> variables;
+    double infinity = lp_solver.get_infinity();
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        int op_cost = op.get_cost();
+        if (soft_constraints == false) {
+            variables.push_back(lp::LPVariable(0, infinity, op_cost));
+        } else { // Add variables to create soft constraints
+            variables.push_back(lp::LPVariable(0, infinity, 10000*op_cost));
+        }
+    }
+
+    vector<lp::LPConstraint> constraints;
+    for (const auto &generator : constraint_generators) {
+        generator->initialize_constraints(task, constraints, infinity);
+    }
+
+    map_operators(false);
+
+    if (soft_constraints == true) {
+        add_observation_soft_constraints(variables, constraints);
+    }
+    if(enforce_observations == true) {
+        enforce_observation_constraints(constraints);
+    }
+
+    show_variables_and_objective(variables, false);
+
+    lp_solver.load_problem(lp::LPObjectiveSense::MINIMIZE, variables, constraints);
+}
+
+void OCSingleShotHeuristic::map_operators(bool show) {
+    if (show == true) {
+        cout << endl << string(80, '*') << endl;
+        cout << "# Mapping X -> op: " << endl;
+    }
+    int i = 0;
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        // Caching operator variable indexes
+        std::string op_name (op.get_name());
+        for (size_t i = 0; i< op.get_name().size(); ++i) {
+            op_name[i] = tolower(op_name.c_str()[i]);
+        }
+
+        op_indexes[op_name] = i;
+        if (show == true) {
+            cout << "["<< op_name<< "]: " << op_indexes[op_name] << endl;
+        }
+        i++;
+    }
+    if (show == true) {
+        cout << string(80, '*') << endl << endl;
+    }
+}
+
+void OCSingleShotHeuristic::show_variables_and_objective(const std::vector<lp::LPVariable> &variables, bool show) {
+    if (show == true) {
+        cout << endl << string(80, '*') << endl;
+        cout << "# Variables(" << variables.size() << "): " << endl;
+        for (int i = 0; i < (int) variables.size(); ++i) {
+            cout << "X[" << i << "] = Variable('X_" << i << "'";
+            cout << ", lb=" << variables[i].lower_bound;
+            cout << ", ub=" << variables[i].upper_bound;
+            cout << ", cost[" << i << "] = " << variables[i].objective_coefficient << endl;
+        }
+        cout << string(80, '*') << endl << endl;
+
+        cout << endl << string(80, '*') << endl;
+        cout << "# Objective function: " << endl;
+        cout << "obj = Objective(";
+        for (int i = 0; i < (int) variables.size(); ++i) {
+            cout << "cost[" << i << "] * X[" << i << "]";
+            if (i < (int) variables.size() - 1) {
+                cout << " + ";
+            }
+        }
+        cout << ", direction='min')" << endl;
+        cout << string(80, '*') << endl << endl;
+    }
+}
+
+void OCSingleShotHeuristic::add_observation_soft_constraints(std::vector<lp::LPVariable> &variables, std::vector<lp::LPConstraint> &constraints) {
+    double infinity = lp_solver.get_infinity();
+    cout << endl << string(80, '*') << endl;
+    // Adding constraints
+    cout << "Add soft constraints" << endl;
+    for(vector<string>::iterator it = observations.begin() ; it != observations.end(); ++it) {
+        variables.push_back(lp::LPVariable(-infinity, infinity, -1.0));
+
+        cout << "Adding soft constraint on (" << (*it) << "), index " << std::to_string(op_indexes[*it]) << endl;
+        lp::LPConstraint constraint(0.0, 0.0);
+        constraint.insert(op_indexes[*it], 1.0);
+        constraint.insert(variables.size() - 1, -1.0);
+
+        cout << "X[" << op_indexes[*it] << "] = Variable('X_" << op_indexes[*it]  << "'";
+        cout << ", lb=" << variables[op_indexes[*it]].lower_bound;
+        cout << ", ub=" << variables[op_indexes[*it]].upper_bound;
+        cout << ", cost[" << op_indexes[*it] << "] = " << variables[op_indexes[*it]].objective_coefficient << endl;
+
+        cout << "X[" << variables.size() - 1 << "] = Variable('X_" << variables.size() - 1  << "'";
+        cout << ", lb=" << variables[variables.size() - 1].lower_bound;
+        cout << ", ub=" << variables[variables.size() - 1].upper_bound;
+        cout << ", cost[" << variables.size() - 1 << "] = " << variables[variables.size() - 1].objective_coefficient << endl;
+
+        cout << "constraint variables: " << constraint.get_variables()[0];
+        cout << ", " << constraint.get_variables()[1] << " - ";
+        cout << "constraint coefficients: " << constraint.get_coefficients()[0];
+        cout << ", " << constraint.get_coefficients()[1] << endl << endl;
+        constraints.push_back(constraint);
+    }
+    cout << endl << string(80, '*') << endl;
+}
+
+void OCSingleShotHeuristic::load_observations() {
+    // Read observations from file
+    cout << endl << string(80, '*') << endl;
+    cout << std::endl << "Load observations" << std::endl;
+    ifstream obs_file;
+    obs_file.open("obs.dat");
+    if(obs_file.is_open()){
+        while(!obs_file.eof()) {
+            string obs;
+            getline(obs_file, obs);
+            trim(obs);
+            if(!obs.empty() && obs[0]!=';') {
+                obs = obs.substr(1,obs.length()-2);
+                std::string obs_name (obs);
+                for (size_t i = 0; i< obs.size(); ++i) {
+                    obs_name[i] = tolower(obs.c_str()[i]);
+                }
+                cout << "Observation: " << obs_name << endl;
+                observations.push_back(obs_name);
+            }
+        }
+    }
+    cout << endl << string(80, '*') << endl;
+
+    obs_file.close();
+}
+
+void OCSingleShotHeuristic::enforce_observation_constraints(std::vector<lp::LPConstraint> &constraints) {
+    cout << endl << string(80, '*') << endl;
+    // Adding constraints
+    std::cout << "Enforcing observation constraints" << std::endl;
+
+    double infinity = lp_solver.get_infinity();
+    for(vector<string>::iterator it = observations.begin() ; it != observations.end(); ++it) {
+        double num_count = std::count(observations.begin(), observations.end(), (*it));
+        cout << num_count << endl;
+        lp::LPConstraint constraint(num_count, infinity);
+
+        cout << "constraint " << (*it) << ": " << std::to_string(op_indexes[*it]) << endl;
+        constraint.insert(op_indexes[*it], 1);
+        constraints.push_back(constraint);
+    }
+    cout << endl << string(80, '*') << endl;
+}
+
+void OCSingleShotHeuristic::output_results(int result) {
+    cout << endl << string(80, '*') << endl;
+    vector<double> solution = lp_solver.extract_solution();
+    for (int i = 0; i < (int) solution.size(); ++i) {
+        cout << "X[" << i << "] = " << solution[i] << endl;
+    }
+    std::cout << "# observations in solution (" << observations.size() << "): " << std::endl;
+    double sat_observations = 0.0;
+    for(vector<string>::iterator it = observations.begin() ; it != observations.end(); ++it) {
+        cout << (*it) << ": " << solution[op_indexes[*it]] << endl;
+        sat_observations += solution[op_indexes[*it]];
+    }
+    cout << "# sat observations: " << sat_observations << endl;
+    cout << "# h-value: " << result << endl;
+    cout << string(80, '*') << endl;
+
+    cout << endl << string(80, '*') << endl;
+
+    cout << "Writing results" << endl;
+    ofstream results;
+    //cout << "Writing results" << endl;
+    results.open("ocsingleshot_heuristic_result.dat");
+    results << "-- ";
+    results << endl << result << endl;
+    // Printing counts
+    int var_i=0;
+    vector<double> counts = lp_solver.extract_solution();
+    for (OperatorProxy op : task_proxy.get_operators()) {
+        // cout << "(" << op.get_name() << ") = " << counts[var_i] << endl;
+        if (counts[var_i] > 0 ) {
+            results << "(" << op.get_name() << ") = " << counts[var_i] << endl;
+        }
+        var_i++;
+    }
+
+    results.flush();
+    results.close();
+}
+
+OCSingleShotHeuristic::~OCSingleShotHeuristic() {
+}
+
+int OCSingleShotHeuristic::compute_heuristic(const GlobalState &global_state) {
+    State state = convert_global_state(global_state);
+    return compute_heuristic(state);
+}
+
+int OCSingleShotHeuristic::compute_heuristic(const State &state) {
+    assert(!lp_solver.has_temporary_constraints());
+    for (const auto &generator : constraint_generators) {
+          bool dead_end = generator->update_constraints(state, lp_solver);
+        if (dead_end) {
+            lp_solver.clear_temporary_constraints();
+            return DEAD_END;
+        }
+    }
+
+    int result;
+    lp_solver.solve();
+    if (lp_solver.has_optimal_solution()) {
+        double epsilon = 0.01;
+        double objective_value = lp_solver.get_objective_value();
+        result = ceil(objective_value - epsilon);
+        
+    } else {
+        result = DEAD_END;
+    }
+
+    lp_solver.print_statistics();
+
+    ///////////////////////////////////////////////////////////////////
+    output_results(result);
+
+    if(result == DEAD_END)
+        exit(EXIT_FAILURE);
+    else
+        exit(EXIT_SUCCESS);
+    ///////////////////////////////////////////////////////////////////
+
+    lp_solver.clear_temporary_constraints();
+    return result;
+}
+
+static shared_ptr<Heuristic> _parse(OptionParser &parser) {
+    parser.document_synopsis(
+        "Operator counting heuristic",
+        "An operator counting heuristic computes a linear program (LP) in each "
+        "state. The LP has one variable Count_o for each operator o that "
+        "represents how often the operator is used in a plan. Operator "
+        "counting constraints are linear constraints over these varaibles that "
+        "are guaranteed to have a solution with Count_o = occurrences(o, pi) "
+        "for every plan pi. Minimizing the total cost of operators subject to "
+        "some operator counting constraints is an admissible heuristic. "
+        "For details, see" + utils::format_conference_reference( // TODO - Change this for our paper
+            {"Florian Pommerening", "Gabriele Roeger", "Malte Helmert",
+             "Blai Bonet"},
+            "LP-based Heuristics for Cost-optimal Planning",
+            "http://www.aaai.org/ocs/index.php/ICAPS/ICAPS14/paper/view/7892/8031",
+            "Proceedings of the Twenty-Fourth International Conference"
+            " on Automated Planning and Scheduling (ICAPS 2014)",
+            "226-234",
+            "AAAI Press",
+            "2014"));
+
+    parser.document_language_support("action costs", "supported");
+    parser.document_language_support(
+        "conditional effects",
+        "not supported (the heuristic supports them in theory, but none of "
+        "the currently implemented constraint generators do)");
+    parser.document_language_support(
+        "axioms",
+        "not supported (the heuristic supports them in theory, but none of "
+        "the currently implemented constraint generators do)");
+    parser.document_property("admissible", "yes");
+    parser.document_property(
+        "consistent",
+        "yes, if all constraint generators represent consistent heuristics");
+    parser.document_property("safe", "yes");
+    // TODO: prefer operators that are non-zero in the solution.
+    parser.document_property("preferred operators", "no");
+
+    parser.add_list_option<shared_ptr<ConstraintGenerator>>(
+        "constraint_generators",
+        "methods that generate constraints over operator counting variables");
+    parser.add_option<bool>("enforce_observations", "whether or not to enforce constraints on observations");
+    parser.add_option<bool>("soft_constraints", "whether or not to use observations as soft constraints");
+    lp::add_lp_solver_option_to_parser(parser);
+    Heuristic::add_options_to_parser(parser);
+    Options opts = parser.parse();
+    if (parser.help_mode())
+        return nullptr;
+    opts.verify_list_non_empty<shared_ptr<ConstraintGenerator>>(
+        "constraint_generators");
+    if (parser.dry_run())
+        return nullptr;
+    return make_shared<OCSingleShotHeuristic>(opts);
+}
+
+static Plugin<Evaluator> _plugin("ocsingleshot", _parse);
+}
diff -X lp-recognizer/fd-patch.ignore -ruN fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.h fast-downward/src/search/operator_counting/oc_single_shot_heuristic.h
--- fast-downward-original/src/search/operator_counting/oc_single_shot_heuristic.h	1969-12-31 21:00:00.000000000 -0300
+++ fast-downward/src/search/operator_counting/oc_single_shot_heuristic.h	2019-01-17 17:20:02.000000000 -0200
@@ -0,0 +1,41 @@
+#ifndef OPERATOR_COUNTING_OPERATOR_COUNTING_HEURISTIC_H
+#define OPERATOR_COUNTING_OPERATOR_COUNTING_HEURISTIC_H
+
+#include "../heuristic.h"
+
+#include "../lp/lp_solver.h"
+
+#include <memory>
+#include <vector>
+#include <string>
+
+namespace options {
+class Options;
+}
+
+namespace operator_counting {
+class ConstraintGenerator;
+
+class OCSingleShotHeuristic : public Heuristic {
+    std::vector<std::shared_ptr<ConstraintGenerator>> constraint_generators;
+    lp::LPSolver lp_solver;
+    bool enforce_observations;
+    bool soft_constraints;
+    std::unordered_map<std::string,int> op_indexes;
+    std::vector<std::string> observations;
+protected:
+    virtual int compute_heuristic(const GlobalState &global_state) override;
+    int compute_heuristic(const State &state);
+    void load_observations();
+    void enforce_observation_constraints(std::vector<lp::LPConstraint> &constraints);
+    void add_observation_soft_constraints(std::vector<lp::LPVariable> &variables, std::vector<lp::LPConstraint> &constraints);
+    void output_results(int result);
+public:
+    explicit OCSingleShotHeuristic(const options::Options &opts);
+    ~OCSingleShotHeuristic();
+    void map_operators(bool show = false);
+    void show_variables_and_objective(const std::vector<lp::LPVariable> &variables, bool show = false);
+};
+}
+
+#endif
